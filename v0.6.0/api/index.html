<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · BAT</title><link rel="canonical" href="https://bat.github.io/BAT.jl/stable/api/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BAT</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Functions-and-macros-1">Functions and macros</a></li><li class="toplevel"><a class="toctext" href="#Documentation-1">Documentation</a></li></ul></li><li><a class="toctext" href="../developing/">Developer instructions</a></li><li><a class="toctext" href="../license/">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/bat/BAT.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><ul><li><a href="#BAT.AbstractDensity"><code>BAT.AbstractDensity</code></a></li><li><a href="#BAT.AbstractMCMCCallback"><code>BAT.AbstractMCMCCallback</code></a></li><li><a href="#BAT.AbstractPosteriorDensity"><code>BAT.AbstractPosteriorDensity</code></a></li><li><a href="#BAT.AbstractProposalDist"><code>BAT.AbstractProposalDist</code></a></li><li><a href="#BAT.AbstractSamplingAlgorithm"><code>BAT.AbstractSamplingAlgorithm</code></a></li><li><a href="#BAT.AdaptiveMetropolisTuning"><code>BAT.AdaptiveMetropolisTuning</code></a></li><li><a href="#BAT.DataSet"><code>BAT.DataSet</code></a></li><li><a href="#BAT.DistLikeDensity"><code>BAT.DistLikeDensity</code></a></li><li><a href="#BAT.GelmanRubinConvergence"><code>BAT.GelmanRubinConvergence</code></a></li><li><a href="#BAT.GenericDensity"><code>BAT.GenericDensity</code></a></li><li><a href="#BAT.HMIData"><code>BAT.HMIData</code></a></li><li><a href="#BAT.HMISettings"><code>BAT.HMISettings</code></a></li><li><a href="#BAT.IntegrationVolume"><code>BAT.IntegrationVolume</code></a></li><li><a href="#BAT.IntegrationVolume-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T}}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.IntegrationVolume</code></a></li><li><a href="#BAT.MCMCCallbackWrapper"><code>BAT.MCMCCallbackWrapper</code></a></li><li><a href="#BAT.NamedTupleDist"><code>BAT.NamedTupleDist</code></a></li><li><a href="#BAT.OnlineMvMean"><code>BAT.OnlineMvMean</code></a></li><li><a href="#BAT.OnlineUvMean"><code>BAT.OnlineUvMean</code></a></li><li><a href="#BAT.PointCloud"><code>BAT.PointCloud</code></a></li><li><a href="#BAT.PointCloud-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.PointCloud</code></a></li><li><a href="#BAT.PosteriorSampleVector"><code>BAT.PosteriorSampleVector</code></a></li><li><a href="#BAT.RandSampling"><code>BAT.RandSampling</code></a></li><li><a href="#BAT.RandomResampling"><code>BAT.RandomResampling</code></a></li><li><a href="#BAT.SearchResult"><code>BAT.SearchResult</code></a></li><li><a href="#BAT.WhiteningResult"><code>BAT.WhiteningResult</code></a></li></ul><h2><a class="nav-anchor" id="Functions-and-macros-1" href="#Functions-and-macros-1">Functions and macros</a></h2><ul><li><a href="#BAT.apply_bounds-Union{Tuple{H}, Tuple{L}, Tuple{X}, Tuple{X,L,H,BoundsType}, Tuple{X,L,H,BoundsType,Any}} where H&lt;:Real where L&lt;:Real where X&lt;:Real"><code>BAT.apply_bounds</code></a></li><li><a href="#BAT.apply_bounds"><code>BAT.apply_bounds</code></a></li><li><a href="#BAT.apply_bounds!"><code>BAT.apply_bounds!</code></a></li><li><a href="#BAT.autocrl-Union{Tuple{AbstractArray{T,1}}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{Int64,1}}} where T&lt;:Real"><code>BAT.autocrl</code></a></li><li><a href="#BAT.bat_integrate"><code>BAT.bat_integrate</code></a></li><li><a href="#BAT.bat_read"><code>BAT.bat_read</code></a></li><li><a href="#BAT.bat_read-Tuple{Any}"><code>BAT.bat_read</code></a></li><li><a href="#BAT.bat_sample-Tuple{Random.AbstractRNG,AbstractPosteriorDensity,Tuple{Integer,Integer},MCMCAlgorithm}"><code>BAT.bat_sample</code></a></li><li><a href="#BAT.bat_sample"><code>BAT.bat_sample</code></a></li><li><a href="#BAT.bat_sampler"><code>BAT.bat_sampler</code></a></li><li><a href="#BAT.bat_stats-Tuple{StructArrays.StructArray{PosteriorSample{P,T,W,R,PA},1,NamedTuple{(:params, :log_posterior, :log_prior, :weight, :info),Tuple{PAV,TV,TV,WV,RV}},I} where I where RV&lt;:AbstractArray{R,1} where WV&lt;:AbstractArray{W,1} where TV&lt;:AbstractArray{T,1} where PAV&lt;:(AbstractArray{#s29,1} where #s29&lt;:AbstractArray{P,1}) where PA&lt;:AbstractArray{P,1} where R where W&lt;:Real where T&lt;:AbstractFloat where P&lt;:Real}"><code>BAT.bat_stats</code></a></li><li><a href="#BAT.bat_write"><code>BAT.bat_write</code></a></li><li><a href="#BAT.bat_write-Tuple{Any,Any}"><code>BAT.bat_write</code></a></li><li><a href="#BAT.calculate_localmode-Tuple{Any}"><code>BAT.calculate_localmode</code></a></li><li><a href="#BAT.create_hypercube-Union{Tuple{T}, Tuple{Array{T,1},T}} where T&lt;:AbstractFloat"><code>BAT.create_hypercube</code></a></li><li><a href="#BAT.create_hyperrectangle-Union{Tuple{I}, Tuple{T}, Tuple{I,BAT.DataSet{T,I},T,BAT.HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.create_hyperrectangle</code></a></li><li><a href="#BAT.default_sampling_algorithm"><code>BAT.default_sampling_algorithm</code></a></li><li><a href="#BAT.density_logval"><code>BAT.density_logval</code></a></li><li><a href="#BAT.distribution_logpdf"><code>BAT.distribution_logpdf</code></a></li><li><a href="#BAT.distribution_logpdf!"><code>BAT.distribution_logpdf!</code></a></li><li><a href="#BAT.drop_low_weight_samples"><code>BAT.drop_low_weight_samples</code></a></li><li><a href="#BAT.effective_sample_size-Tuple{StructArrays.StructArray{PosteriorSample{P,T,W,R,PA},1,NamedTuple{(:params, :log_posterior, :log_prior, :weight, :info),Tuple{PAV,TV,TV,WV,RV}},I} where I where RV&lt;:AbstractArray{R,1} where WV&lt;:AbstractArray{W,1} where TV&lt;:AbstractArray{T,1} where PAV&lt;:(AbstractArray{#s29,1} where #s29&lt;:AbstractArray{P,1}) where PA&lt;:AbstractArray{P,1} where R where W&lt;:Real where T&lt;:AbstractFloat where P&lt;:Real}"><code>BAT.effective_sample_size</code></a></li><li><a href="#BAT.effective_sample_size-Tuple{AbstractArray,AbstractArray{T,1} where T}"><code>BAT.effective_sample_size</code></a></li><li><a href="#BAT.effective_sample_size-Union{Tuple{AbstractArray{T1,1}}, Tuple{T1}, Tuple{T2}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1}}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},AbstractArray{Int64,1}}} where T1&lt;:Real where T2&lt;:Number"><code>BAT.effective_sample_size</code></a></li><li><a href="#BAT.eval_density_logval-Tuple{AbstractDensity,AbstractArray{#s28,1} where #s28&lt;:Real,ValueShapes.AbstractValueShape}"><code>BAT.eval_density_logval</code></a></li><li><a href="#BAT.eval_prior_posterior_logval!"><code>BAT.eval_prior_posterior_logval!</code></a></li><li><a href="#BAT.eval_prior_posterior_logval_strict!-Tuple{AbstractPosteriorDensity,AbstractArray{#s28,1} where #s28&lt;:Real}"><code>BAT.eval_prior_posterior_logval_strict!</code></a></li><li><a href="#BAT.find_hypercube_centers-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},BAT.WhiteningResult{T},BAT.HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.find_hypercube_centers</code></a></li><li><a href="#BAT.fromuhc-Tuple{AbstractArray{T,1} where T,SpatialVolume}"><code>BAT.fromuhc</code></a></li><li><a href="#BAT.fromuhc!"><code>BAT.fromuhc!</code></a></li><li><a href="#BAT.fromui"><code>BAT.fromui</code></a></li><li><a href="#BAT.gr_Rsqr-Tuple{AbstractArray{#s21,1} where #s21&lt;:MCMCBasicStats}"><code>BAT.gr_Rsqr</code></a></li><li><a href="#BAT.hm_init-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},BAT.HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_init</code></a></li><li><a href="#BAT.hm_integrate!-Union{Tuple{HMIData{T,I,V}}, Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},Symbol}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_integrate!</code></a></li><li><a href="#BAT.hm_whiteningtransformation!-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},BAT.HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_whiteningtransformation!</code></a></li><li><a href="#BAT.hyperrectangle_creationproccess!-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},T,BAT.HMISettings,Array{BAT.IntegrationVolume{T,I,HyperRectVolume{T}},1},Array{HyperRectVolume{T},1},Array{I,1},Base.Threads.Atomic{I},ProgressMeter.Progress}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hyperrectangle_creationproccess!</code></a></li><li><a href="#BAT.initial_params!"><code>BAT.initial_params!</code></a></li><li><a href="#BAT.issymmetric_around_origin"><code>BAT.issymmetric_around_origin</code></a></li><li><a href="#BAT.log_volume"><code>BAT.log_volume</code></a></li><li><a href="#BAT.modify_hypercube!-Union{Tuple{T}, Tuple{HyperRectVolume{T},Array{T,1},T}} where T&lt;:AbstractFloat"><code>BAT.modify_hypercube!</code></a></li><li><a href="#BAT.modify_integrationvolume!-Union{Tuple{I}, Tuple{T}, Tuple{BAT.IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,BAT.DataSet{T,I},HyperRectVolume{T}}, Tuple{BAT.IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.modify_integrationvolume!</code></a></li><li><a href="#BAT.nparams"><code>BAT.nparams</code></a></li><li><a href="#BAT.nparams-Tuple{AbstractDensity}"><code>BAT.nparams</code></a></li><li><a href="#BAT.nparams-Tuple{DistLikeDensity}"><code>BAT.nparams</code></a></li><li><a href="#BAT.param_bounds"><code>BAT.param_bounds</code></a></li><li><a href="#BAT.param_bounds-Tuple{AbstractDensity}"><code>BAT.param_bounds</code></a></li><li><a href="#BAT.params_shape"><code>BAT.params_shape</code></a></li><li><a href="#BAT.proposal_rand!"><code>BAT.proposal_rand!</code></a></li><li><a href="#BAT.spatialvolume"><code>BAT.spatialvolume</code></a></li><li><a href="#BAT.wgt_effective_sample_size-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Real"><code>BAT.wgt_effective_sample_size</code></a></li></ul><h1><a class="nav-anchor" id="Documentation-1" href="#Documentation-1">Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.AbstractDensity" href="#BAT.AbstractDensity"><code>BAT.AbstractDensity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractDensity</code></pre><p>Subtypes of <code>AbstractDensity</code> only have to imlement the function</p><ul><li><code>BAT.density_logval</code></li></ul><p>However, densities with known parameters bounds should also implement</p><ul><li><code>BAT.param_bounds</code></li></ul><p>If the parameter bounds are unkown, but the number of parameters is known, the function</p><ul><li><code>BAT.nparams</code></li></ul><p>should be implemented directly (usually it is inferred from the bounds).</p><p>Densities that support named parameters should also implement</p><ul><li><code>BAT.params_shape</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/abstract_density.jl#L7-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.AbstractMCMCCallback" href="#BAT.AbstractMCMCCallback"><code>BAT.AbstractMCMCCallback</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractMCMCCallback &lt;: Function</code></pre><p>Subtypes (e.g. <code>X</code>) must support</p><pre><code class="language-none">(::X)(level::Integer, chain::MCMCIterator) =&gt; nothing
(::X)(level::Integer, tuner::AbstractMCMCTuner) =&gt; nothing</code></pre><p>to be compabtible with <code>mcmc_iterate!</code>, <code>mcmc_tune_burnin!</code>, etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/mcmc/mcmc_callback.jl#L4-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.AbstractPosteriorDensity" href="#BAT.AbstractPosteriorDensity"><code>BAT.AbstractPosteriorDensity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type AbstractPosteriorDensity &lt;: AbstractDensity end</code></pre><p>Abstract super-type for posterior probability densities.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/posterior_density.jl#L4-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.AbstractProposalDist" href="#BAT.AbstractProposalDist"><code>BAT.AbstractProposalDist</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractProposalDist</code></pre><p>The following functions must be implemented for subtypes:</p><ul><li><code>BAT.distribution_logpdf</code></li><li><code>BAT.proposal_rand!</code></li><li><code>BAT.nparams</code>, returning the number of parameters (i.e. dimensionality).</li><li><code>LinearAlgebra.issymmetric</code>, indicating whether p(a -&gt; b) == p(b -&gt; a) holds true.</li></ul><p>In some cases, it may be desirable to override the default implementation of <code>BAT.distribution_logpdf!</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/mcmc/proposaldist.jl#L4-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.AdaptiveMetropolisTuning" href="#BAT.AdaptiveMetropolisTuning"><code>BAT.AdaptiveMetropolisTuning</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AdaptiveMetropolisTuning(...)</code></pre><p>Ajusts the proposal function based on the acceptance ratio and covariance of the previous samples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8c4656b97aaa0e2c7491c84cacbc70afc84d6601/base/#L0-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.DistLikeDensity" href="#BAT.DistLikeDensity"><code>BAT.DistLikeDensity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DistLikeDensity &lt;: AbstractDensity</code></pre><p>A density that implements part of the <code>Distributions.Distribution</code> interface. Such densities are suitable to be used as a priors.</p><p>Subtypes of <code>DistLikeDensity</code> are required to support more functionality than a <code>AbstractDensity</code>, but less than a <code>Distribution{Multivariate,Continuous}</code>.</p><p>The following functions must be implemented for subtypes:</p><ul><li><p><code>BAT.density_logval</code></p></li><li><p><code>BAT.param_bounds</code></p></li><li><p><code>BAT.params_shape</code></p></li><li><p><code>Distributions.sampler</code></p></li><li><p><code>Statistics.cov</code></p></li></ul><p>Prior densities that support named parameters should also implement</p><ul><li><code>BAT.params_shape</code></li></ul><p>A <code>d::Distribution{Multivariate,Continuous}</code> can be converted into (wrapped in) an <code>DistLikeDensity</code> via <code>conv(DistLikeDensity, d)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/abstract_density.jl#L140-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.GelmanRubinConvergence" href="#BAT.GelmanRubinConvergence"><code>BAT.GelmanRubinConvergence</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GelmanRubinConvergence</code></pre><p>Gelman-Rubin <span>$$maximum(R^2)$$</span> convergence test.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/8c4656b97aaa0e2c7491c84cacbc70afc84d6601/base/#L0-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.GenericDensity" href="#BAT.GenericDensity"><code>BAT.GenericDensity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GenericDensity{F&lt;:Function} &lt;: AbstractDensity</code></pre><p>Constructors:</p><pre><code class="language-none">GenericDensity(log_f)</code></pre><p>Turns the logarithmic density function <code>log_f</code> into a BAT-compatible <code>AbstractDensity</code>. <code>log_f</code> must support</p><pre><code class="language-none">`log_f(params::Any)::Real`</code></pre><p>It must be safe to execute <code>log_f</code> in parallel on multiple threads and processes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/generic_density.jl#L4-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.HMIData" href="#BAT.HMIData"><code>BAT.HMIData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HMIData{T&lt;:AbstractFloat, I&lt;:Integer}</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>Includes all the informations of the integration process, including a list of hyper-rectangles, the results of the whitening transformation, the starting ids, and the average number of points and volume of the created hyper-rectangles.</p><p><strong>Variables</strong></p><ul><li>&#39;dataset1&#39; : Data Set 1</li><li>&#39;dataset2&#39; : Data Set 2</li><li>&#39;whiteningresult&#39; : contains the whitening matrix and its determinant, required to scale the final integral estimate</li><li>&#39;volumelist1&#39; : An array of integration volumes created using dataset1, but filled with samples from dataset2</li><li>&#39;volumelist2&#39; : An array of integration volumes created using dataset2, but filled with samples from dataset1</li><li>&#39;cubelist1&#39; : An array of small hyper-cubes created around seeding samples of dataset 1</li><li>&#39;cubelist2&#39; : An array of small hyper-cubes created around seeding samples of dataset 2</li><li>&#39;iterations1&#39; : The number of volume adapting iterations for the creating volumelist1</li><li>&#39;iterations2&#39; : The number of volume adapting iterations for the creating volumelist2</li><li>&#39;rejectedrects1&#39; : An array of ids, indicating which hyper-rectangles of volumelist1 were rejected due to trimming</li><li>&#39;rejectedrects2&#39; : An array of ids, indicating which hyper-rectangles of volumelist2 were rejected due to trimming</li><li>&#39;integralestimates&#39; : A dictionary containing the final integral estimates with uncertainty estimation using different uncertainty estimators. Also includes all intermediate results required for the integral estimate combination</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/data_types.jl#L286-L307">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.NamedTupleDist" href="#BAT.NamedTupleDist"><code>BAT.NamedTupleDist</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NamedTupleDist &lt;: MultivariateDistribution
NamedTupleDist &lt;: MultivariateDistribution</code></pre><p>A distribution with <code>NamedTuple</code>-typed variates.</p><p>Can be used to describe the distribution of each parameter in a set of named parameters. If the distribution is used as a Bayesian prior, the <code>NamedTupleDist</code> then specifies the prior on each named parameter.</p><p>A <code>NamedTupleDist</code> implies a <code>NamedTupleShape</code>:</p><pre><code class="language-none">valshape(d::NamedTupleDist) isa NamedTupleShape</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/named_tuple_dist.jl#L57-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.OnlineMvMean" href="#BAT.OnlineMvMean"><code>BAT.OnlineMvMean</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OnlineMvMean{T&lt;:AbstractFloat} &lt;: AbstractVector{T}</code></pre><p>Multi-variate mean implemented via Kahan-Babuška-Neumaier summation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/statistics/onlinemvstats.jl#L30-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.OnlineUvMean" href="#BAT.OnlineUvMean"><code>BAT.OnlineUvMean</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OnlineUvMean{T&lt;:AbstractFloat}</code></pre><p>Univariate mean implemented via Kahan-Babuška-Neumaier summation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/statistics/onlineuvstats.jl#L6-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.PosteriorSampleVector" href="#BAT.PosteriorSampleVector"><code>BAT.PosteriorSampleVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PosteriorSampleVector</code></pre><p>Type alias for <code>StructArrays.StructArray{&lt;:PosteriorSample,...}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/density_sample.jl#L72-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.bat_integrate" href="#BAT.bat_integrate"><code>BAT.bat_integrate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bat_integrate(
    posterior::BAT.AnyPosterior,
)::PosteriorSampleVector</code></pre><p>Calculate the integral (evidence) of <code>posterior</code>.</p><p>Returns a NamedTuple: (integral = x::Measurement.Measurement, ...)</p><p>Result properties not listed here are algorithm-specific and are not part of the stable BAT API.</p><p><code>posterior</code> may be a</p><ul><li><p><a href="#BAT.AbstractPosteriorDensity"><code>BAT.AbstractPosteriorDensity</code></a></p></li><li><p><a href="#BAT.DistLikeDensity"><code>BAT.DistLikeDensity</code></a></p></li><li><p><a href="#BAT.PosteriorSampleVector"><code>BAT.PosteriorSampleVector</code></a></p></li><li><p><code>Distributions.MultivariateDistribution</code></p></li></ul><p>Uses the AHMI algorithm by default.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/bat_integrate.jl#L6-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.bat_read" href="#BAT.bat_read"><code>BAT.bat_read</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bat_read(filename::AbstractString, data)
bat_read(fn_with_subpath::Tuple{AbstractString, AbstractString}, data)</code></pre><p>Read data from a file <code>filename</code>, resp. from an internal sub-path of the file (if supported by the file format), e.g. an HDF5 group.</p><p>Currently supported file formats are:</p><ul><li>HDF5 with file extension &quot;.h5&quot; or &quot;.hdf5&quot;</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/io/bat_io.jl#L17-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.bat_read-Tuple{Any}" href="#BAT.bat_read-Tuple{Any}"><code>BAT.bat_read</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bat_read(src::HDF5.DataFile)
bat_read(src_with_subpath::Tuple{HDF5.DataFile, AbstractString})</code></pre><p>Read data from HDF5 file or group <code>src</code> (optionally from an HDF5-path relative to <code>src</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/io/hdf5_specific.jl#L26-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.bat_sample" href="#BAT.bat_sample"><code>BAT.bat_sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bat_sample(
    [rng::AbstractRNG],
    posterior::BAT.AnyPosterior,
    n::BAT.AnyNSamples,
    [algorithm::BAT.AbstractSamplingAlgorithm]
)::PosteriorSampleVector</code></pre><p>Draw <code>n</code> samples from <code>posterior</code>.</p><p>Returns a NamedTuple of the shape</p><pre><code class="language-julia">(
    samples = X::PosteriorSampleVector,...
    stats = s::@test stats isa NamedTuple{(:mode,:mean,:cov,...)},
    ...
)</code></pre><p>Result properties not listed here are algorithm-specific and are not part of the stable BAT API.</p><p><code>posterior</code> may be a</p><ul><li><p><a href="#BAT.AbstractPosteriorDensity"><code>BAT.AbstractPosteriorDensity</code></a></p></li><li><p><a href="#BAT.DistLikeDensity"><code>BAT.DistLikeDensity</code></a></p></li><li><p><a href="#BAT.PosteriorSampleVector"><code>BAT.PosteriorSampleVector</code></a></p></li><li><p><code>Distributions.MultivariateDistribution</code></p></li></ul><p>Depending on the type of posterior, <code>n</code> may be of type</p><ul><li><p><code>Integer</code>: Number of samples</p></li><li><p><code>Tuple{Integer,Integer}</code>: Tuple of number of samples per sample source  and number of sample sources (e.g. number of MCMC chains). The total number  of samples is <code>product(n)</code>.</p></li></ul><p>Depending on the type of <code>posterior</code>, the number of samples returned may be somewhat larger or smaller than specified by <code>product(n)</code>.</p><p>Also depending on the <code>posterior</code> type, the samples may be independent or correlated (e.g. when using MCMC).</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/bat_sample.jl#L45-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.bat_sample-Tuple{Random.AbstractRNG,AbstractPosteriorDensity,Tuple{Integer,Integer},MCMCAlgorithm}" href="#BAT.bat_sample-Tuple{Random.AbstractRNG,AbstractPosteriorDensity,Tuple{Integer,Integer},MCMCAlgorithm}"><code>BAT.bat_sample</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">function bat_sample(
    rng::AbstractRNG,
    posterior::AbstractPosteriorDensity,
    n::Union{Integer,Tuple{Integer,Integer}},
    algorithm::MCMCAlgorithm;
    max_nsteps::Integer,
    max_time::Real,
    tuning::AbstractMCMCTunerConfig,
    init::MCMCInitStrategy,
    burnin::MCMCBurninStrategy,
    convergence::MCMCConvergenceTest,
    strict::Bool = false,
    filter::Bool = true
)</code></pre><p>Sample <code>posterior</code> via Markov chain Monte Carlo (MCMC).</p><p><code>n</code> must be either a tuple <code>(nsteps, nchains)</code> or an integer. <code>nchains</code> specifies the (approximate) number of MCMC steps per chain, <code>nchains</code> the number of MCMC chains. If n is an integer, it is interpreted as <code>nsteps * nchains</code>, and the number of steps and chains are chosen automatically.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/mcmc/mcmc_sample.jl#L126-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.bat_sampler" href="#BAT.bat_sampler"><code>BAT.bat_sampler</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bat_sampler(d::Distribution)</code></pre><p>Tries to return a BAT-compatible sampler for Distribution d. A sampler is BAT-compatible if it supports random number generation using an arbitrary <code>AbstractRNG</code>:</p><pre><code class="language-none">rand(rng::AbstractRNG, s::SamplerType)
rand!(rng::AbstractRNG, s::SamplerType, x::AbstractArray)</code></pre><p>If no specific method of <code>bat_sampler</code> is defined for the type of <code>d</code>, it will default to <code>sampler(d)</code>, which may or may not return a BAT-compatible sampler.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/distributions/distribution_functions.jl#L11-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.bat_stats-Tuple{StructArrays.StructArray{PosteriorSample{P,T,W,R,PA},1,NamedTuple{(:params, :log_posterior, :log_prior, :weight, :info),Tuple{PAV,TV,TV,WV,RV}},I} where I where RV&lt;:AbstractArray{R,1} where WV&lt;:AbstractArray{W,1} where TV&lt;:AbstractArray{T,1} where PAV&lt;:(AbstractArray{#s29,1} where #s29&lt;:AbstractArray{P,1}) where PA&lt;:AbstractArray{P,1} where R where W&lt;:Real where T&lt;:AbstractFloat where P&lt;:Real}" href="#BAT.bat_stats-Tuple{StructArrays.StructArray{PosteriorSample{P,T,W,R,PA},1,NamedTuple{(:params, :log_posterior, :log_prior, :weight, :info),Tuple{PAV,TV,TV,WV,RV}},I} where I where RV&lt;:AbstractArray{R,1} where WV&lt;:AbstractArray{W,1} where TV&lt;:AbstractArray{T,1} where PAV&lt;:(AbstractArray{#s29,1} where #s29&lt;:AbstractArray{P,1}) where PA&lt;:AbstractArray{P,1} where R where W&lt;:Real where T&lt;:AbstractFloat where P&lt;:Real}"><code>BAT.bat_stats</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bat_stats(samples::PosteriorSampleVector)</code></pre><p>Calculated parameter statistics on <code>samples</code>. Returns a <code>NamedTuple{(:mode,:mean,:cov,...)}</code>. Result properties not listed here are not part of the stable BAT API and subject to change.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/density_sample.jl#L186-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.bat_write" href="#BAT.bat_write"><code>BAT.bat_write</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bat_write(filename::AbstractString, data)
bat_write(fn_with_subpath::Tuple{AbstractString, AbstractString}, data)</code></pre><p>Write data to a file <code>filename</code>, resp. to an internal sub-path of the file (if supported by the file format), e.g. an HDF5 group.</p><p>Currently supported file formats are:</p><ul><li>HDF5 with file extension &quot;.h5&quot; or &quot;.hdf5&quot;</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/io/bat_io.jl#L43-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.bat_write-Tuple{Any,Any}" href="#BAT.bat_write-Tuple{Any,Any}"><code>BAT.bat_write</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bat_write(dest::HDF5.DataFile, data)
bat_write(dest_with_subpath::Tuple{HDF5.DataFile, AbstractString}, data)</code></pre><p>Write <code>data</code> to HDF5 file or group <code>dest</code> (optionally to an HDF5-path relative to <code>dest</code>).</p><p><code>data</code> must be a table (i.e. implement the Tables.jl API).</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/io/hdf5_specific.jl#L38-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.density_logval" href="#BAT.density_logval"><code>BAT.density_logval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">density_logval(density::AbstractDensity, params::Any)</code></pre><p>Compute log of value of a multi-variate density function at the given parameter values.</p><p>Input:</p><ul><li><code>density</code>: density function</li><li><code>params</code>: parameter values</li></ul><p>Note: If <code>density_logval</code> is called with out-of-bounds parameters (see <code>param_bounds</code>), the behaviour is undefined. The result for parameters that are not within bounds is <em>implicitly</em> <code>-Inf</code>, but it is the caller&#39;s responsibility to handle these cases.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/abstract_density.jl#L33-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.distribution_logpdf" href="#BAT.distribution_logpdf"><code>BAT.distribution_logpdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">distribution_logpdf(
    pdist::AbstractProposalDist,
    params_new::AbstractVector,
    params_old:::AbstractVector
)</code></pre><p>Analog to <code>distribution_logpdf!</code>, but for a single parameter vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/mcmc/proposaldist.jl#L21-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.distribution_logpdf!" href="#BAT.distribution_logpdf!"><code>BAT.distribution_logpdf!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">distribution_logpdf!(
    p::AbstractArray,
    pdist::AbstractProposalDist,
    params_new::Union{AbstractVector,VectorOfSimilarVectors},
    params_old:::Union{AbstractVector,VectorOfSimilarVectors}
)</code></pre><p>Returns log(PDF) value of <code>pdist</code> for transitioning from old to new parameter values for multiple parameter sets.</p><p>end</p><p>Input:</p><ul><li><code>params_new</code>: New parameter values (column vectors)</li><li><code>params_old</code>: Old parameter values (column vectors)</li></ul><p>Output is stored in</p><ul><li><code>p</code>: Array of PDF values, length must match, shape is ignored</li></ul><p>Array size requirements:</p><ul><li><code>size(params_old, 1) == size(params_new, 1) == length(pdist)</code></li><li><code>size(params_old, 2) == size(params_new, 2)</code> or <code>size(params_old, 2) == 1</code></li><li><code>size(params_new, 2) == length(p)</code></li></ul><p>Implementations of <code>distribution_logpdf!</code> must be thread-safe.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/mcmc/proposaldist.jl#L36-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.fromuhc!" href="#BAT.fromuhc!"><code>BAT.fromuhc!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fromuhc!(Y::AbstractVector, X::AbstractVector, vol::SpatialVolume)
fromuhc!(Y::VectorOfSimilarVectors, X::VectorOfSimilarVectors, vol::SpatialVolume)</code></pre><p>Bijective transformation of coordinates <code>X</code> within the unit hypercube to coordinates <code>Y</code> in <code>vol</code>. If <code>X</code> and <code>Y</code> are matrices, the transformation is applied to the column vectors. Use <code>Y === X</code> to transform in-place.</p><p>Use <code>inv(fromuhc!)</code> to get the the inverse transformation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/spatialvolume.jl#L27-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.fromuhc-Tuple{AbstractArray{T,1} where T,SpatialVolume}" href="#BAT.fromuhc-Tuple{AbstractArray{T,1} where T,SpatialVolume}"><code>BAT.fromuhc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fromuhc(X::AbstractVector, vol::SpatialVolume)
fromuhc(X::VectorOfSimilarVectors, vol::SpatialVolume)</code></pre><p>Bijective transformation from unit hypercube to <code>vol</code>. See <code>fromuhc!</code>.</p><p>Use <code>inv(fromuhc)</code> to get the the inverse transformation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/spatialvolume.jl#L46-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.fromui" href="#BAT.fromui"><code>BAT.fromui</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">y = fromui(x::Real, lo::Real, hi::Real)
y = fromui(x::Real, lo_hi::ClosedInterval{&lt;:Real})</code></pre><p>Linear bijective transformation from the unit inverval (i.e. <code>x ∈ 0..1</code>) to <code>y ∈ lo..hi</code>.</p><p>Use <code>inv(fromui)</code> to get the the inverse transformation.</p><p>Use <code>@inbounds</code> to disable range checking on the input value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/utils/coord_utils.jl#L7-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.issymmetric_around_origin" href="#BAT.issymmetric_around_origin"><code>BAT.issymmetric_around_origin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">issymmetric_around_origin(d::Distribution)</code></pre><p>Returns <code>true</code> (resp. <code>false</code>) if the Distribution is symmetric (resp. non-symmetric) around the origin.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/distributions/distribution_functions.jl#L32-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.log_volume" href="#BAT.log_volume"><code>BAT.log_volume</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">log_volume(vol::SpatialVolume)</code></pre><p>Get the logarithm of the volume of the space in <code>vol</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/spatialvolume.jl#L18-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.nparams" href="#BAT.nparams"><code>BAT.nparams</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nparams(X::Union{AbstractParamBounds,MCMCIterator,...})</code></pre><p>Get the number of parameters of <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/parambounds.jl#L4-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.nparams-Tuple{AbstractDensity}" href="#BAT.nparams-Tuple{AbstractDensity}"><code>BAT.nparams</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">nparams(density::AbstractDensity)::Union{Int,Missing}</code></pre><p>Get the number of parameters of <code>density</code>. May return <code>missing</code>, if the density supports a variable number of parameters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/abstract_density.jl#L66-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.nparams-Tuple{DistLikeDensity}" href="#BAT.nparams-Tuple{DistLikeDensity}"><code>BAT.nparams</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">nparams(density::DistLikeDensity)::Int</code></pre><p>Get the number of parameters of prior density <code>density</code>. Must not be <code>missing</code>, prior densities must have a fixed number of parameters. By default, the number of parameters is inferred from the parameter bounds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/abstract_density.jl#L181-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.param_bounds" href="#BAT.param_bounds"><code>BAT.param_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">param_bounds(density::DistLikeDensity)::AbstractParamBounds</code></pre><p>Get the parameter bounds of <code>density</code>. Must not be <code>missing</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/abstract_density.jl#L173-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.param_bounds-Tuple{AbstractDensity}" href="#BAT.param_bounds-Tuple{AbstractDensity}"><code>BAT.param_bounds</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">param_bounds(
    density::AbstractDensity
)::Union{AbstractParamBounds,Missing}</code></pre><p>Get the parameter bounds of <code>density</code>. See <code>density_logval</code> for the implications and handling of the bounds. If the bounds are missing, <code>density_logval</code> must be prepared to handle any parameter values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/abstract_density.jl#L53-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.params_shape" href="#BAT.params_shape"><code>BAT.params_shape</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">params_shape(
    density::AbstractDensity
)::Union{ValueShapes.AbstractValueShape,Missing}

params_shape(
    density::DistLikeDensity
)::ValueShapes.AbstractValueShape

params_shape(
    distribution::Distributions.Distribution
)::ValueShapes.AbstractValueShape</code></pre><p>Get the shapes of parameters of <code>density</code>.</p><p>For prior densities, the result must not be <code>missing</code>, but may be <code>nothing</code> if the prior only supports flat parameter vectors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/abstract_density.jl#L78-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.proposal_rand!" href="#BAT.proposal_rand!"><code>BAT.proposal_rand!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function proposal_rand!(
    rng::AbstractRNG,
    pdist::GenericProposalDist,
    params_new::Union{AbstractVector,VectorOfSimilarVectors},
    params_old::Union{AbstractVector,VectorOfSimilarVectors}
)</code></pre><p>Generate one or multiple proposed parameter vectors, based on one or multiple previous parameter vectors.</p><p>Input:</p><ul><li><code>rng</code>: Random number generator to use</li><li><code>pdist</code>: Proposal distribution to use</li><li><code>params_old</code>: Old parameter values (vector or column vectors, if a matrix)</li></ul><p>Output is stored in</p><ul><li><code>params_new</code>: New parameter values (vector or column vectors, if a matrix)</li></ul><p>The caller must guarantee:</p><ul><li><code>size(params_old, 1) == size(params_new, 1)</code></li><li><code>size(params_old, 2) == size(params_new, 2)</code> or <code>size(params_old, 2) == 1</code></li><li><code>params_new !== params_old</code> (no aliasing)</li></ul><p>Implementations of <code>proposal_rand!</code> must be thread-safe.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/mcmc/proposaldist.jl#L72-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.spatialvolume" href="#BAT.spatialvolume"><code>BAT.spatialvolume</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">spatialvolume(b::ParamVolumeBounds)::SpatialVolume</code></pre><p>Returns the spatial volume that defines the parameter bounds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/parambounds.jl#L145-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.AbstractSamplingAlgorithm" href="#BAT.AbstractSamplingAlgorithm"><code>BAT.AbstractSamplingAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BAT.AbstractSamplingAlgorithm</code></pre><p>Abstract type for BAT sampling algorithms. See <a href="#BAT.bat_sample"><code>bat_sample</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/bat_sample.jl#L29-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.DataSet" href="#BAT.DataSet"><code>BAT.DataSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DataSet{T&lt;:AbstractFloat, I&lt;:Integer}</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>Holds the MCMC output. For construction use constructor: function DataSet{T&lt;:Real}(data::Matrix{T}, logprob::Vector{T}, weights::Vector{T})</p><p><strong>Variables</strong></p><ul><li>&#39;data&#39; : An P x N array with N data points with P parameters.</li><li>&#39;logprob&#39; : The logarithmic probability for each samples stored in an array</li><li>&#39;weights&#39; : How often each sample occurred. Set to an array of ones if working directly on MCMC output</li><li>&#39;ids&#39; : Array which is used to assign each sample to a batch, required for the cov. weighed uncertainty estimation</li><li>.sortids : an array of indices which stores the original ordering of the samples (the space partitioning tree reorders the samples), required to calculate an effective sample size.</li><li>&#39;N&#39; : number of samples</li><li>&#39;P&#39; : number of parameters</li><li>&#39;nsubsets&#39; : the number of batches</li><li>&#39;iswhitened&#39; : a boolean value which indicates whether the data set is iswhitened</li><li>&#39;isnew&#39; : a boolean value which indicates whether the data set was swapped out with a different one (it is possible to redo the integration with a different sample set using previously generated hyper-rectangles)</li><li>&#39;partitioningtree&#39; : The space partitioning tree, used to efficiently identify samples in a point cloud</li><li>&#39;startingIDs&#39; : The Hyper-Rectangle Seed Samples are stored in this array</li><li>&#39;tolerance&#39; : A threshold required for the hyper-rectangle creation process.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/data_types.jl#L18-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.HMISettings" href="#BAT.HMISettings"><code>BAT.HMISettings</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HMISettings</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>holds the settings for the hm_integrate function. There are several default constructors available: HMIFastSettings() HMIStandardSettings() HMIPrecisionSettings()</p><p>#Variables</p><ul><li>&#39;whitening_method::Symbol&#39; : which whitening method to use</li><li>&#39;max_startingIDs::Integer&#39; : influences how many starting ids are allowed to be generated</li><li>&#39;max<em>startingIDs</em>fraction::AbstractFloat&#39; : how many points are considered as possible starting points as a fraction of total points available</li><li>&#39;rect_increase::AbstractFloat&#39; : describes the procentual rectangle volume increase/decrease during hyperrectangle creation. Low values can increase the precision if enough points are available but can cause systematically wrong results if not enough points are available.</li><li>&#39;use<em>all</em>rects::Bool&#39; : All rectangles are used for the integration process no matter how big their overlap is. If enabled the rectangles are weighted by their overlap.</li><li>&#39;useMultiThreading&#39; : activate multithreading support.</li><li>&#39;warning_minstartingids&#39; : the required minimum amount of starting samples</li><li>&#39;dotrimming&#39; : determines whether the integral estimates are trimmed (1σ trim) before combining them into a final result (more robust)</li><li>&#39;uncertainty<em>estimators&#39; : A dictionary of different uncertainty estimator functions. Currently three functions are available: hm</em>combineresults<em>legacy! (outdated, overestimates uncertainty significantly in higher dimensions), hm</em>combineresults<em>covweighted! (very fast) and hm</em>combineresults_analyticestimation! (recommended)</li></ul><p>end</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/data_types.jl#L111-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.IntegrationVolume" href="#BAT.IntegrationVolume"><code>BAT.IntegrationVolume</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IntegrationVolume{T&lt;:AbstractFloat, I&lt;:Integer}</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p><strong>Variables</strong></p><ul><li>&#39;pointcloud&#39; : holds the point cloud of the integration volume</li><li>&#39;spatialvolume&#39; : the boundaries of the integration volume</li><li>&#39;volume&#39; : the volume</li></ul><p>Hold the point cloud and the spatial volume for integration.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/data_types.jl#L234-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.IntegrationVolume-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T}}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.IntegrationVolume-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T}}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.IntegrationVolume</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IntegrationVolume(dataset::DataSet{T, I}, spvol::HyperRectVolume{T}, searchpts::Bool = true)::IntegrationVolume{T, I}</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>creates an integration region by calculating the point cloud an the volume of the spatial volume.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/integration_volume.jl#L2-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.MCMCCallbackWrapper" href="#BAT.MCMCCallbackWrapper"><code>BAT.MCMCCallbackWrapper</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MCMCCallbackWrapper{F} &lt;: AbstractMCMCCallback</code></pre><p>Wraps a callable object to turn it into an <code>AbstractMCMCCallback</code>.</p><p>Constructor:</p><pre><code class="language-none">MCMCCallbackWrapper(f::Any)</code></pre><p><code>f</code> needs to support the call syntax of an <code>AbstractMCMCCallback</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/mcmc/mcmc_callback.jl#L38-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.PointCloud" href="#BAT.PointCloud"><code>BAT.PointCloud</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PointCloud{T&lt;:AbstractFloat, I&lt;:Integer}</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>Stores the information of the points of an e.g. HyperRectVolume</p><p><strong>Variables</strong></p><ul><li>&#39;maxLogProb&#39; : The maximum log. probability of one of the points inside the hyper-rectangle</li><li>&#39;minLogProb&#39; : The minimum log. probability of one of the points inside the hyper-rectangle</li><li>&#39;maxWeightProb&#39; : the weighted max. log. probability</li><li>&#39;minWeightProb&#39; : the weighted min. log. probability</li><li>&#39;probfactor&#39; : The probability factor of the hyper-rectangle</li><li>&#39;probweightfactor&#39; : The weighted probability factor</li><li>&#39;points&#39; : The number of points inside the hyper-rectangle</li><li>&#39;pointIDs&#39; : the IDs of the points inside the hyper-rectangle, might be empty because it is optional and costs performance</li><li>&#39;searchres&#39; : used to boost performance</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/data_types.jl#L202-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.PointCloud-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.PointCloud-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.PointCloud</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">PointCloud{T&lt;:AbstractFloat, I&lt;:Integer}(dataset::DataSet{T, I}, hyperrect::HyperRectVolume{T}, searchpts::Bool = false)::PointCloud</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>creates a point cloud by searching the data tree for points which are inside the hyper-rectangle The parameter searchpts determines if an array of the point IDs is created as well</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/point_cloud.jl#L2-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.RandSampling" href="#BAT.RandSampling"><code>BAT.RandSampling</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BAT.RandSampling</code></pre><p>Constructors:</p><pre><code class="language-none">BAT.RandSampling()</code></pre><p>Sample via <code>Random.rand</code>. Only supported for posteriors of type <code>Distributions.MultivariateDistribution</code> and <code>BAT.DistLikeDensity</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/bat_sample.jl#L125-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.RandomResampling" href="#BAT.RandomResampling"><code>BAT.RandomResampling</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BAT.RandomResampling</code></pre><p>Constructors:</p><pre><code class="language-none">BAT.RandomResampling()</code></pre><p>Resample from a given set of samples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/bat_sample.jl#L159-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.SearchResult" href="#BAT.SearchResult"><code>BAT.SearchResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SearchResult{T&lt;:AbstractFloat, I&lt;:Integer}</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>Stores the results of the space partitioning tree&#39;s search function</p><p><strong>Variables</strong></p><ul><li>&#39;pointIDs&#39; : the IDs of samples found, might be empty because it is optional</li><li>&#39;points&#39; : The number of points found.</li><li>&#39;maxLogProb&#39; : the maximum log. probability of the points found.</li><li>&#39;minLogProb&#39; : the minimum log. probability of the points found.</li><li>&#39;maxWeightProb&#39; : the weighted minimum log. probability found.</li><li>&#39;minWeightProb&#39; : the weighted maximum log. probfactor found.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/data_types.jl#L170-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.WhiteningResult" href="#BAT.WhiteningResult"><code>BAT.WhiteningResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">WhiteningResult{T&lt;:AbstractFloat}</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>Stores the information obtained during the Whitening Process</p><p><strong>Variables</strong></p><ul><li>&#39;determinant&#39; : The determinant of the whitening matrix</li><li>&#39;targetprobfactor&#39; : The suggested target probability factor</li><li>&#39;whiteningmatrix&#39; : The whitening matrix</li><li>&#39;meanvalue&#39; : the mean vector of the input data</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/data_types.jl#L148-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.apply_bounds" href="#BAT.apply_bounds"><code>BAT.apply_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_bounds(x::Real, interval::ClosedInterval, boundary_type::BoundsType)</code></pre><p>Specify lower and upper bound via <code>interval</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/parambounds.jl#L94-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.apply_bounds!" href="#BAT.apply_bounds!"><code>BAT.apply_bounds!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_bounds!(params::AbstractVector, bounds::AbstractParamBounds)</code></pre><p>Apply <code>bounds</code> to parameters <code>params</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/parambounds.jl#L53-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.apply_bounds-Union{Tuple{H}, Tuple{L}, Tuple{X}, Tuple{X,L,H,BoundsType}, Tuple{X,L,H,BoundsType,Any}} where H&lt;:Real where L&lt;:Real where X&lt;:Real" href="#BAT.apply_bounds-Union{Tuple{H}, Tuple{L}, Tuple{X}, Tuple{X,L,H,BoundsType}, Tuple{X,L,H,BoundsType,Any}} where H&lt;:Real where L&lt;:Real where X&lt;:Real"><code>BAT.apply_bounds</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">apply_bounds(x::&lt;:Real, lo::&lt;:Real, hi::&lt;:Real, boundary_type::BoundsType)</code></pre><p>Apply lower/upper bound <code>lo</code>/<code>hi</code> to value <code>x</code>. <code>boundary_type</code> may be <code>hard_bounds</code>, <code>cyclic_bounds</code> or <code>reflective_bounds</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/parambounds.jl#L61-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.autocrl-Union{Tuple{AbstractArray{T,1}}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{Int64,1}}} where T&lt;:Real" href="#BAT.autocrl-Union{Tuple{AbstractArray{T,1}}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{Int64,1}}} where T&lt;:Real"><code>BAT.autocrl</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">autocrl(xv::AbstractVector{T}, kv::AbstractVector{Int} = Vector{Int}())</code></pre><p>autocorrelation := Σ Cov[x<em>i,x</em>(i+k)]/Var[x]</p><p>Computes the autocorrelations at various leg k of the input vector (time series) xv. The vector kv is the collections of lags to take into account</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/statistics/effective_sample_size.jl#L4-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.calculate_localmode-Tuple{Any}" href="#BAT.calculate_localmode-Tuple{Any}"><code>BAT.calculate_localmode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">calculate_localmode(hist)</code></pre><p>Calculates the modes of a 1d statsbase histogram. A vector containing the bin-center(s) of the heighest bin(s) is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/plotting/localmodes.jl#L4-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.create_hypercube-Union{Tuple{T}, Tuple{Array{T,1},T}} where T&lt;:AbstractFloat" href="#BAT.create_hypercube-Union{Tuple{T}, Tuple{Array{T,1},T}} where T&lt;:AbstractFloat"><code>BAT.create_hypercube</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">create_hypercube{T&lt;:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>creates a hypercube shaped spatial volume</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/hyper_rectangle.jl#L2-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.create_hyperrectangle-Union{Tuple{I}, Tuple{T}, Tuple{I,BAT.DataSet{T,I},T,BAT.HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.create_hyperrectangle-Union{Tuple{I}, Tuple{T}, Tuple{I,BAT.DataSet{T,I},T,BAT.HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.create_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">create_hyperrectangle(...)</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>This function creates a hyper-rectangle around each starting sample. It starts by building a hyper-cube  and subsequently adapts each face individually, thus turning the hyper-cube into a hyper-rectangle. The faces are adjusted in a way to match the shape of the distribution as best as possible.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/hyper_rectangle.jl#L350-L359">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.default_sampling_algorithm" href="#BAT.default_sampling_algorithm"><code>BAT.default_sampling_algorithm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">BAT.default_sampling_algorithm(posterior)</code></pre><p>Get BAT&#39;s default sampling algorithm for <code>posterior</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/bat_sample.jl#L37-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.drop_low_weight_samples" href="#BAT.drop_low_weight_samples"><code>BAT.drop_low_weight_samples</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">drop_low_weight_samples(
    samples::PosteriorSampleVector,
    fraction::Real = 10^-4
)</code></pre><p>Drop <code>fraction</code> of the total probability mass from samples to filter out the samples with the lowest weight.</p><p>Note: BAT-internal function, not part of stable API.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/parameters/density_sample.jl#L209-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.effective_sample_size-Tuple{AbstractArray,AbstractArray{T,1} where T}" href="#BAT.effective_sample_size-Tuple{AbstractArray,AbstractArray{T,1} where T}"><code>BAT.effective_sample_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">effective_sample_size(params::AbstractArray, weights::AbstractVector; with_weights=true)</code></pre><p>Effective size estimation for a (multidimensional) ElasticArray. By default applies the Kish approximation with the weigths available, but can be turned off (with_weights=false).</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/statistics/effective_sample_size.jl#L72-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.effective_sample_size-Tuple{StructArrays.StructArray{PosteriorSample{P,T,W,R,PA},1,NamedTuple{(:params, :log_posterior, :log_prior, :weight, :info),Tuple{PAV,TV,TV,WV,RV}},I} where I where RV&lt;:AbstractArray{R,1} where WV&lt;:AbstractArray{W,1} where TV&lt;:AbstractArray{T,1} where PAV&lt;:(AbstractArray{#s29,1} where #s29&lt;:AbstractArray{P,1}) where PA&lt;:AbstractArray{P,1} where R where W&lt;:Real where T&lt;:AbstractFloat where P&lt;:Real}" href="#BAT.effective_sample_size-Tuple{StructArrays.StructArray{PosteriorSample{P,T,W,R,PA},1,NamedTuple{(:params, :log_posterior, :log_prior, :weight, :info),Tuple{PAV,TV,TV,WV,RV}},I} where I where RV&lt;:AbstractArray{R,1} where WV&lt;:AbstractArray{W,1} where TV&lt;:AbstractArray{T,1} where PAV&lt;:(AbstractArray{#s29,1} where #s29&lt;:AbstractArray{P,1}) where PA&lt;:AbstractArray{P,1} where R where W&lt;:Real where T&lt;:AbstractFloat where P&lt;:Real}"><code>BAT.effective_sample_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">effective_sample_size(samples::PosteriorSampleVector; with_weights=true)</code></pre><p>Effective size estimation for a (multidimensional) PosteriorSampleVector. By default applies the Kish approximation with the weigths available, but can be turned off (with_weights=false).</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/statistics/effective_sample_size.jl#L92-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.effective_sample_size-Union{Tuple{AbstractArray{T1,1}}, Tuple{T1}, Tuple{T2}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1}}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},AbstractArray{Int64,1}}} where T1&lt;:Real where T2&lt;:Number" href="#BAT.effective_sample_size-Union{Tuple{AbstractArray{T1,1}}, Tuple{T1}, Tuple{T2}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1}}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},AbstractArray{Int64,1}}} where T1&lt;:Real where T2&lt;:Number"><code>BAT.effective_sample_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Effective size estimation for a vector of samples xv. If a weight vector w is provided, the Kish approximation is applied.</p><p>By default computes the autocorrelation up to the square root of the number of entries in the vector, unless an explicit list of lags is provided (kv).</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/statistics/effective_sample_size.jl#L45-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.eval_density_logval-Tuple{AbstractDensity,AbstractArray{#s28,1} where #s28&lt;:Real,ValueShapes.AbstractValueShape}" href="#BAT.eval_density_logval-Tuple{AbstractDensity,AbstractArray{#s28,1} where #s28&lt;:Real,ValueShapes.AbstractValueShape}"><code>BAT.eval_density_logval</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">eval_density_logval(
    density::AbstractDensity,
    params::AbstractVector{&lt;:Real},
    parshapes::ValueShapes.AbstractValueShape
)</code></pre><p>Internal function to evaluate density log-value, calls <code>density_logval</code>.</p><p><code>parshapes</code> <em>must</em> be compatible with <code>params_shape(density)</code>.</p><p>Checks that:</p><ul><li>The number of parameters of <code>density</code> (if known) matches the length of <code>params</code>.</li><li>The return value of <code>density_logval</code> is not <code>NaN</code>.</li><li>The return value of <code>density_logval</code> is less than <code>+Inf</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/abstract_density.jl#L104-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.eval_prior_posterior_logval!" href="#BAT.eval_prior_posterior_logval!"><code>BAT.eval_prior_posterior_logval!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">BAT.eval_prior_posterior_logval!(
    T::Type{&lt;:Real},
    density::AbstractDensity,
    params::AbstractVector{&lt;:Real}
)</code></pre><p>First apply bounds to the parameters, compute prior and posterior log values by via <code>eval_density_logval</code>.</p><p>May modify <code>params</code>.</p><p>Returns a <code>NamedTuple{(:log_prior, :log_posterior),Tuple{T,T}}</code></p><p>Guarantees that  :</p><ul><li>If parameters are still out of bounds after applying bounds, <code>density_logval</code> is not called for either prior or likelihood. </li><li>If <code>density_logval</code> for prior returns <code>-Inf</code>, <code>density_logval</code> is not called for likelihood.</li></ul><p>In both cases, <code>T(-Inf)</code> is returned for both prior and posterior.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/posterior_density.jl#L32-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.eval_prior_posterior_logval_strict!-Tuple{AbstractPosteriorDensity,AbstractArray{#s28,1} where #s28&lt;:Real}" href="#BAT.eval_prior_posterior_logval_strict!-Tuple{AbstractPosteriorDensity,AbstractArray{#s28,1} where #s28&lt;:Real}"><code>BAT.eval_prior_posterior_logval_strict!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">BAT.eval_prior_posterior_logval_strict!(
    density::AbstractDensity,
    params::AbstractVector{&lt;:Real}
)</code></pre><p>First apply bounds to the parameters, compute prior and posterior log values by via <code>eval_density_logval</code>.</p><p>May modify <code>params</code>.</p><p>Returns a <code>NamedTuple{(:log_prior, :log_posterior),Tuple{T,T}}</code>. T is inferred from value returned by <code>eval_density_logval</code> for the likelihood.</p><p>Guarantees that  :</p><ul><li>If parameters are still out of bounds after applying bounds, <code>density_logval</code> is not called for either prior or likelihood. </li><li>If <code>density_logval</code> for prior returns <code>-Inf</code>, <code>density_logval</code> is not called for likelihood.</li></ul><p>In both cases, an exception is thrown.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/densities/posterior_density.jl#L86-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.find_hypercube_centers-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},BAT.WhiteningResult{T},BAT.HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.find_hypercube_centers-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},BAT.WhiteningResult{T},BAT.HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.find_hypercube_centers</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">find_hypercube_centers(dataset::DataSet{T, I}, whiteningresult::WhiteningResult, settings::HMISettings)::Vector{I}</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>finds possible starting points for the hyperrectangle creation</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/hyper_rectangle.jl#L53-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.gr_Rsqr-Tuple{AbstractArray{#s21,1} where #s21&lt;:MCMCBasicStats}" href="#BAT.gr_Rsqr-Tuple{AbstractArray{#s21,1} where #s21&lt;:MCMCBasicStats}"><code>BAT.gr_Rsqr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">gr_Rsqr(stats::AbstractVector{&lt;:MCMCBasicStats})</code></pre><p>Gelman-Rubin <span>$$R^2$$</span> for all parameters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/mcmc/mcmc_convergence.jl#L23-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.hm_init-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},BAT.HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.hm_init-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},BAT.HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_init</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hm_init!(result, settings)</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>Sets the global multithreading setting and ensures that a minimum number of samples, dependent on the number of dimensions, are provided.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/harmonic_mean_integration.jl#L73-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.hm_integrate!-Union{Tuple{HMIData{T,I,V}}, Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},Symbol}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.hm_integrate!-Union{Tuple{HMIData{T,I,V}}, Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},Symbol}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_integrate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hm_integrate!(result, settings = HMIPrecisionSettings())</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>This function starts the adaptive harmonic mean integration. See arXiv:1808.08051 for more details. It needs a HMIData struct as input, which holds the samples, in form of a dataset, the integration volumes and other properties, required for the integration, and the final result.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/harmonic_mean_integration.jl#L23-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.hm_whiteningtransformation!-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},BAT.HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.hm_whiteningtransformation!-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},BAT.HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_whiteningtransformation!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hm_whiteningtransformation!(result, settings)</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>Applies a whitening transformation to the samples. A custom whitening method can be used by overriding settings.whitening_function!</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/harmonic_mean_integration.jl#L94-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.hyperrectangle_creationproccess!-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},T,BAT.HMISettings,Array{BAT.IntegrationVolume{T,I,HyperRectVolume{T}},1},Array{HyperRectVolume{T},1},Array{I,1},Base.Threads.Atomic{I},ProgressMeter.Progress}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.hyperrectangle_creationproccess!-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},T,BAT.HMISettings,Array{BAT.IntegrationVolume{T,I,HyperRectVolume{T}},1},Array{HyperRectVolume{T},1},Array{I,1},Base.Threads.Atomic{I},ProgressMeter.Progress}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hyperrectangle_creationproccess!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hyperrectangle_creationproccess!(...)</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>This function assigns each thread its own hyper-rectangle to build, if in multithreading-mode.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/hm_integration_rectangle.jl#L102-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.initial_params!" href="#BAT.initial_params!"><code>BAT.initial_params!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">BAT.initial_params!(
    params::Union{AbstractVector{&lt;:Real},VectorOfSimilarVectors{&lt;:Real}},
    rng::AbstractRNG,
    posterior::AbstractPosteriorDensity,
    algorithm::MCMCAlgorithm
)::typeof(params)</code></pre><p>Fill <code>params</code> with random initial parameters suitable for <code>posterior</code> and <code>algorithm</code>. The default implementation will try to draw the initial parameters from the prior of the posterior.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/samplers/mcmc/mcmc_algorithm.jl#L35-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.modify_hypercube!-Union{Tuple{T}, Tuple{HyperRectVolume{T},Array{T,1},T}} where T&lt;:AbstractFloat" href="#BAT.modify_hypercube!-Union{Tuple{T}, Tuple{HyperRectVolume{T},Array{T,1},T}} where T&lt;:AbstractFloat"><code>BAT.modify_hypercube!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">create_hypercube!{T&lt;:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>resizes a hypercube shaped spatial volume</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/hyper_rectangle.jl#L22-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.modify_integrationvolume!-Union{Tuple{I}, Tuple{T}, Tuple{BAT.IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,BAT.DataSet{T,I},HyperRectVolume{T}}, Tuple{BAT.IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.modify_integrationvolume!-Union{Tuple{I}, Tuple{T}, Tuple{BAT.IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,BAT.DataSet{T,I},HyperRectVolume{T}}, Tuple{BAT.IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.modify_integrationvolume!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">modify_integrationvolume!(intvol::IntegrationVolume{T, I}, dataset::DataSet{T, I}, spvol::HyperRectVolume{T}, searchpts::Bool = true)</code></pre><p>Note: AHMI-internal, not part of stable API.</p><p>updates an integration volume with new boundaries. Recalculates the pointcloud and volume.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/integration/ahmi/integration_volume.jl#L22-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.wgt_effective_sample_size-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Real" href="#BAT.wgt_effective_sample_size-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Real"><code>BAT.wgt_effective_sample_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">wgt_effective_sample_size(w::AbstractVector{T})</code></pre><p>Kish&#39;s approximation for weighted samples effective<em>sample</em>size estimation. Computes the weighting factor for weigthed samples, where w is the vector of weigths.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/8c8c8abbcb30c46bc89b70cf3cca77537dc9c682/src/statistics/effective_sample_size.jl#L33-L39">source</a></section><footer><hr/><a class="previous" href="../tutorial/"><span class="direction">Previous</span><span class="title">Tutorial</span></a><a class="next" href="../developing/"><span class="direction">Next</span><span class="title">Developer instructions</span></a></footer></article></body></html>
