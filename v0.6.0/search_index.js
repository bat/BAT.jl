var documenterSearchIndex = {"docs":
[{"location":"publications/#Publications-and-Talks-1","page":"Publications and Talks","title":"Publications and Talks","text":"","category":"section"},{"location":"publications/#","page":"Publications and Talks","title":"Publications and Talks","text":"... to be written ...","category":"page"},{"location":"basics/#Statistical-Basics-1","page":"Statistical Basics","title":"Statistical Basics","text":"","category":"section"},{"location":"basics/#","page":"Statistical Basics","title":"Statistical Basics","text":"... to be written ...","category":"page"},{"location":"installation/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"BAT.jl is written in the Julia programming language. To use BAT.jl, you will need to install Julia itself, the BAT.jl Julia package, and some additional Julia packages. Depending on your use case, you may also want to need a Python installation with certain Python packages (optional).","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Table of contents:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Pages = [\"installation.md\"]\nDepth = 3","category":"page"},{"location":"installation/#Installing-Julia-1","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Julia is available for Linux, OS-X and Windows, and easy to install:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Download Julia.\nExtract the archive, resp. run the installer.\nYou may want to add the Julia bin directory to your $PATH. To get the location of the Julia bin directory on OS-X or Windows, start a Julia session (via applications menu) and run the Julia command Sys.BINDIR.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"note: Note\nBAT.jl requires Julia >= v1.0.5. Julia v1.3 or higher is recommended for full functionality and performance.","category":"page"},{"location":"installation/#Installing-Jupyter-and-matplotlib/pyplot-(optional)-1","page":"Installation","title":"Installing Jupyter and matplotlib/pyplot (optional)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"If you plan to use Jupyter notebooks and/or the matplotlib/pyplot backend of the Julia Plots.jl package, you will also need a Python installation and certain Python packages (see below). BAT.jl is fully usable without Jupyter and matplotlib/pyplot, but both can come in very handy.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Julia can either use existing installations of Jupyter and pyplot , or install both internally by creating an internal Conda installation within $HOME/.julia/conda. We recommend the first approach (especially using Anaconda), since Julia will otherwise have to download over 1 GB of software, the $HOME/.julia directory will grow very large, and you will need to start Jupyter in an indirect fashion via Julia (only to have Jupyter then start additional Julia instances as Jupyter kernels in return).","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"For details, see the IJulia.jl, PyCall.jl and PyPlot.jl documentation (you should not need to if you follow the steps below).","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On Linux, Julia (more specifically the Julia packages IJulia.jl, PyCall.jl, and PyPlot.jl) will by default try to use the matplotlib/pyplot installation associated with the python3 (resp. python) executable on your $PATH. Likewise, Julia will by default try to use the Jupyter installation associated with the jupyter executable on your $PATH.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"However, on OS-X and Windows, both IJulia.jl and PyCall.jl by default always create a Julia-internal Conda installation (see above), even if Jupyter and matplotlib/pyplot are available (apparently broken Jupyter/Python installations on these platforms caused frequent support requests).  In contrast to this default behavior, we recommend to use a standalone Jupyter and Python installation on all OS platforms. Set the environment variables $JUPYTER and $PYTHON to point to your Jupyter and Python executable to force Julia to use the existing installation.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"We recommend that you install the Anaconda Python distribution, it includes both Jupyter and pyplot (it is of course possible to use non-Anaconda Jupyter and pyplot installations instead).","category":"page"},{"location":"installation/#Installing-Anaconda-(optional)-1","page":"Installation","title":"Installing Anaconda (optional)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To install Anaconda","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Download Anaconda.\nRun the installer\nSet the environment variables $JUPYTER and $PYTHON to the full path of the Jupyter and Python executables (see above).\nNote: OS-X => v1.15 (\"Catalina\") by default uses the \"zsh\" shell instead of \"bash\". However, the Anaconda installer (at least in some versions) still seems to add add it's $PATH settings to \"HOMEbash_profile instead of HOME/.zshrc\". You may have to copy the Anaconda-related section to the correct file.","category":"page"},{"location":"installation/#Environment-variables-1","page":"Installation","title":"Environment variables","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"You may want/need to set the following environment variables:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"$PATH: Include the Julia bin-directory in your binary search path, see above.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"If you intend to use Jupyter, you will probably want to include the directory containing the jupyter binary to your PATH as well.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"$JULIA_NUM_THREADS: Number of threads to use for Julia multi-threading\n$JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR: If you want Julia to install packages in another location than $HOME/.julia.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"See the Julia manual for a description of other Julia-specific environment variables.","category":"page"},{"location":"installation/#Installing-BAT.jl-and-related-Julia-packages-1","page":"Installation","title":"Installing BAT.jl and related Julia packages","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"BAT.jl is provided as a registered Julia package. To install it, simply run","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> pkg\"add BAT\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"However, you will likely need other Julia packages too. We recommend that you install certain statistics, plotting, I/O and array packages as well:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> pkg\"add BAT ArraysOfArrays Distributions ElasticArrays IntervalSets Parameters Plots ValueShapes StatsBase Tables TypedTables\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To install the latest development version of BAT (master branch), instead of the latest stable release, use","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia> pkg\"add BAT#master\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"If you'd like to precompile all installed packages right aways (otherwise they'll get precompiled when loaded for the first time), run","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia> pkg\"precompile\"","category":"page"},{"location":"installation/#Installing-additional-Julia-packages-1","page":"Installation","title":"Installing additional Julia packages","text":"","category":"section"},{"location":"installation/#HDF5-(File-I/O)-1","page":"Installation","title":"HDF5 (File I/O)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To enable BAT's HDF5 file I/O capabilities, add the package \"HDF5.jl\":","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"pkg\"add HDF5\"","category":"page"},{"location":"installation/#IJulia-(Jupyter-Julia-kernel)-1","page":"Installation","title":"IJulia (Jupyter Julia kernel)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To use the the Julia Jupyter kernel, you need to add the package \"IJulia.jl\":","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On Linux, simply use","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"pkg\"add IJulia\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On OS-X, if you have an existing Jupyter installation (e.g. via Anaconda) and would like Julia to use it (instead of an internal Conda installation, see above), use (e.g.)","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"ENV[\"JUPYTER\"] = \"$(homedir())/opt/anaconda3/bin/jupyter\"; pkg\"add IJulia\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On Windows, if would like Julia to use an existing Jupyter installation (see above), use something like","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"ENV[\"JUPYTER\"] = \"DRIVE:/path/to/your/anaconda/.../jupyter.exe\"; pkg\"add IJulia\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Julia will remember the chosen Jupyter installation permanently, ENV[\"JUPYTER\"] only needs to be set the first time you run pkg\"add IJulia\".","category":"page"},{"location":"installation/#PyPlot-(optinal-backend-for-Plots.jl)-1","page":"Installation","title":"PyPlot (optinal backend for Plots.jl)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To use the Plots.jl matplotlib/pyplot backend (see above), add the package \"PyPlot.jl\". To call Python code from Julia yourself directly, you may want to add \"PyCall.jl\" as well:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On Linux, use:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"pkg\"add PyPlot PyCall\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On OS-X, if you have an existing Python/matplotlib/pyplot installation and would like Julia to use it (see above), use (e.g.):","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"ENV[\"PYTHON\"] = \"$(homedir())/opt/anaconda3/bin/python\", pkg\"add PyPlot PyCall\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On Windows, if would like Julia to use an existing Python installation (see above), use something like:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"ENV[\"PYTHON\"] = \"DRIVE:/path/to/your/anaconda/.../python.exe\"; pkg\"add PyPlot PyCall\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Julia will remember the chosen Python installation permanently, ENV[\"PYTHON\"] only needs to be set the first time you run pkg\"add PyPlot PyCall\".","category":"page"},{"location":"installation/#Additional-customization-options-1","page":"Installation","title":"Additional customization options","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Note: If you want Julia to install packages in another location than $HOME/.julia, set the environment variables JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR (see above).","category":"page"},{"location":"benchmarks/#Benchmarks-and-Performance-Tests-1","page":"Benchmarks and Performance Tests","title":"Benchmarks and Performance Tests","text":"","category":"section"},{"location":"benchmarks/#","page":"Benchmarks and Performance Tests","title":"Benchmarks and Performance Tests","text":"... to be written ...","category":"page"},{"location":"faq/#Frequently-Asked-Questions-1","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"... to be written ...","category":"page"},{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"DocTestSetup  = quote\n    using BAT\nend","category":"page"},{"location":"api/#Types-1","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Order = [:type]","category":"page"},{"location":"api/#Functions-and-macros-1","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation-1","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [BAT]\nOrder = [:type, :macro, :function]","category":"page"},{"location":"api/#BAT.AbstractDensity","page":"API","title":"BAT.AbstractDensity","text":"AbstractDensity\n\nSubtypes of AbstractDensity only have to imlement the function\n\nBAT.density_logval\n\nHowever, densities with known parameters bounds should also implement\n\nBAT.param_bounds\n\nIf the parameter bounds are unkown, but the number of parameters is known, the function\n\nBAT.nparams\n\nshould be implemented directly (usually it is inferred from the bounds).\n\nDensities that support named parameters should also implement\n\nBAT.params_shape\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.AbstractMCMCCallback","page":"API","title":"BAT.AbstractMCMCCallback","text":"AbstractMCMCCallback <: Function\n\nSubtypes (e.g. X) must support\n\n(::X)(level::Integer, chain::MCMCIterator) => nothing\n(::X)(level::Integer, tuner::AbstractMCMCTuner) => nothing\n\nto be compabtible with mcmc_iterate!, mcmc_tune_burnin!, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.AbstractPosteriorDensity","page":"API","title":"BAT.AbstractPosteriorDensity","text":"abstract type AbstractPosteriorDensity <: AbstractDensity end\n\nAbstract super-type for posterior probability densities.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.AbstractProposalDist","page":"API","title":"BAT.AbstractProposalDist","text":"AbstractProposalDist\n\nThe following functions must be implemented for subtypes:\n\nBAT.distribution_logpdf\nBAT.proposal_rand!\nBAT.nparams, returning the number of parameters (i.e. dimensionality).\nLinearAlgebra.issymmetric, indicating whether p(a -> b) == p(b -> a) holds true.\n\nIn some cases, it may be desirable to override the default implementation of BAT.distribution_logpdf!.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.AdaptiveMetropolisTuning","page":"API","title":"BAT.AdaptiveMetropolisTuning","text":"AdaptiveMetropolisTuning(...)\n\nAjusts the proposal function based on the acceptance ratio and covariance of the previous samples.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.DistLikeDensity","page":"API","title":"BAT.DistLikeDensity","text":"DistLikeDensity <: AbstractDensity\n\nA density that implements part of the Distributions.Distribution interface. Such densities are suitable to be used as a priors.\n\nSubtypes of DistLikeDensity are required to support more functionality than a AbstractDensity, but less than a Distribution{Multivariate,Continuous}.\n\nThe following functions must be implemented for subtypes:\n\nBAT.density_logval\nBAT.param_bounds\nBAT.params_shape\nDistributions.sampler\nStatistics.cov\n\nPrior densities that support named parameters should also implement\n\nBAT.params_shape\n\nA d::Distribution{Multivariate,Continuous} can be converted into (wrapped in) an DistLikeDensity via conv(DistLikeDensity, d).\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.GelmanRubinConvergence","page":"API","title":"BAT.GelmanRubinConvergence","text":"GelmanRubinConvergence\n\nGelman-Rubin maximum(R^2) convergence test.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.GenericDensity","page":"API","title":"BAT.GenericDensity","text":"GenericDensity{F<:Function} <: AbstractDensity\n\nConstructors:\n\nGenericDensity(log_f)\n\nTurns the logarithmic density function log_f into a BAT-compatible AbstractDensity. log_f must support\n\n`log_f(params::Any)::Real`\n\nIt must be safe to execute log_f in parallel on multiple threads and processes.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.HMIData","page":"API","title":"BAT.HMIData","text":"HMIData{T<:AbstractFloat, I<:Integer}\n\nNote: AHMI-internal, not part of stable API.\n\nIncludes all the informations of the integration process, including a list of hyper-rectangles, the results of the whitening transformation, the starting ids, and the average number of points and volume of the created hyper-rectangles.\n\nVariables\n\n'dataset1' : Data Set 1\n'dataset2' : Data Set 2\n'whiteningresult' : contains the whitening matrix and its determinant, required to scale the final integral estimate\n'volumelist1' : An array of integration volumes created using dataset1, but filled with samples from dataset2\n'volumelist2' : An array of integration volumes created using dataset2, but filled with samples from dataset1\n'cubelist1' : An array of small hyper-cubes created around seeding samples of dataset 1\n'cubelist2' : An array of small hyper-cubes created around seeding samples of dataset 2\n'iterations1' : The number of volume adapting iterations for the creating volumelist1\n'iterations2' : The number of volume adapting iterations for the creating volumelist2\n'rejectedrects1' : An array of ids, indicating which hyper-rectangles of volumelist1 were rejected due to trimming\n'rejectedrects2' : An array of ids, indicating which hyper-rectangles of volumelist2 were rejected due to trimming\n'integralestimates' : A dictionary containing the final integral estimates with uncertainty estimation using different uncertainty estimators. Also includes all intermediate results required for the integral estimate combination\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.NamedTupleDist","page":"API","title":"BAT.NamedTupleDist","text":"NamedTupleDist <: MultivariateDistribution\nNamedTupleDist <: MultivariateDistribution\n\nA distribution with NamedTuple-typed variates.\n\nCan be used to describe the distribution of each parameter in a set of named parameters. If the distribution is used as a Bayesian prior, the NamedTupleDist then specifies the prior on each named parameter.\n\nA NamedTupleDist implies a NamedTupleShape:\n\nvalshape(d::NamedTupleDist) isa NamedTupleShape\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.OnlineMvMean","page":"API","title":"BAT.OnlineMvMean","text":"OnlineMvMean{T<:AbstractFloat} <: AbstractVector{T}\n\nMulti-variate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.OnlineUvMean","page":"API","title":"BAT.OnlineUvMean","text":"OnlineUvMean{T<:AbstractFloat}\n\nUnivariate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.PosteriorSampleVector","page":"API","title":"BAT.PosteriorSampleVector","text":"PosteriorSampleVector\n\nType alias for StructArrays.StructArray{<:PosteriorSample,...}.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.bat_integrate","page":"API","title":"BAT.bat_integrate","text":"bat_integrate(\n    posterior::BAT.AnyPosterior,\n)::PosteriorSampleVector\n\nCalculate the integral (evidence) of posterior.\n\nReturns a NamedTuple: (integral = x::Measurement.Measurement, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable BAT API.\n\nposterior may be a\n\nBAT.AbstractPosteriorDensity\nBAT.DistLikeDensity\nBAT.PosteriorSampleVector\nDistributions.MultivariateDistribution\n\nUses the AHMI algorithm by default.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.bat_read","page":"API","title":"BAT.bat_read","text":"bat_read(filename::AbstractString, data)\nbat_read(fn_with_subpath::Tuple{AbstractString, AbstractString}, data)\n\nRead data from a file filename, resp. from an internal sub-path of the file (if supported by the file format), e.g. an HDF5 group.\n\nCurrently supported file formats are:\n\nHDF5 with file extension \".h5\" or \".hdf5\"\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.bat_read-Tuple{Any}","page":"API","title":"BAT.bat_read","text":"bat_read(src::HDF5.DataFile)\nbat_read(src_with_subpath::Tuple{HDF5.DataFile, AbstractString})\n\nRead data from HDF5 file or group src (optionally from an HDF5-path relative to src).\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.bat_sample","page":"API","title":"BAT.bat_sample","text":"bat_sample(\n    [rng::AbstractRNG],\n    posterior::BAT.AnyPosterior,\n    n::BAT.AnyNSamples,\n    [algorithm::BAT.AbstractSamplingAlgorithm]\n)::PosteriorSampleVector\n\nDraw n samples from posterior.\n\nReturns a NamedTuple of the shape\n\n(\n    samples = X::PosteriorSampleVector,...\n    stats = s::@test stats isa NamedTuple{(:mode,:mean,:cov,...)},\n    ...\n)\n\nResult properties not listed here are algorithm-specific and are not part of the stable BAT API.\n\nposterior may be a\n\nBAT.AbstractPosteriorDensity\nBAT.DistLikeDensity\nBAT.PosteriorSampleVector\nDistributions.MultivariateDistribution\n\nDepending on the type of posterior, n may be of type\n\nInteger: Number of samples\nTuple{Integer,Integer}: Tuple of number of samples per sample source  and number of sample sources (e.g. number of MCMC chains). The total number  of samples is product(n).\n\nDepending on the type of posterior, the number of samples returned may be somewhat larger or smaller than specified by product(n).\n\nAlso depending on the posterior type, the samples may be independent or correlated (e.g. when using MCMC).\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.bat_sample-Tuple{Random.AbstractRNG,AbstractPosteriorDensity,Tuple{Integer,Integer},MCMCAlgorithm}","page":"API","title":"BAT.bat_sample","text":"function bat_sample(\n    rng::AbstractRNG,\n    posterior::AbstractPosteriorDensity,\n    n::Union{Integer,Tuple{Integer,Integer}},\n    algorithm::MCMCAlgorithm;\n    max_nsteps::Integer,\n    max_time::Real,\n    tuning::AbstractMCMCTunerConfig,\n    init::MCMCInitStrategy,\n    burnin::MCMCBurninStrategy,\n    convergence::MCMCConvergenceTest,\n    strict::Bool = false,\n    filter::Bool = true\n)\n\nSample posterior via Markov chain Monte Carlo (MCMC).\n\nn must be either a tuple (nsteps, nchains) or an integer. nchains specifies the (approximate) number of MCMC steps per chain, nchains the number of MCMC chains. If n is an integer, it is interpreted as nsteps * nchains, and the number of steps and chains are chosen automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.bat_sampler","page":"API","title":"BAT.bat_sampler","text":"bat_sampler(d::Distribution)\n\nTries to return a BAT-compatible sampler for Distribution d. A sampler is BAT-compatible if it supports random number generation using an arbitrary AbstractRNG:\n\nrand(rng::AbstractRNG, s::SamplerType)\nrand!(rng::AbstractRNG, s::SamplerType, x::AbstractArray)\n\nIf no specific method of bat_sampler is defined for the type of d, it will default to sampler(d), which may or may not return a BAT-compatible sampler.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.bat_stats-Tuple{StructArrays.StructArray{PosteriorSample{P,T,W,R,PA},1,NamedTuple{(:params, :log_posterior, :log_prior, :weight, :info),Tuple{PAV,TV,TV,WV,RV}},I} where I where RV<:AbstractArray{R,1} where WV<:AbstractArray{W,1} where TV<:AbstractArray{T,1} where PAV<:(AbstractArray{#s29,1} where #s29<:AbstractArray{P,1}) where PA<:AbstractArray{P,1} where R where W<:Real where T<:AbstractFloat where P<:Real}","page":"API","title":"BAT.bat_stats","text":"bat_stats(samples::PosteriorSampleVector)\n\nCalculated parameter statistics on samples. Returns a NamedTuple{(:mode,:mean,:cov,...)}. Result properties not listed here are not part of the stable BAT API and subject to change.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.bat_write","page":"API","title":"BAT.bat_write","text":"bat_write(filename::AbstractString, data)\nbat_write(fn_with_subpath::Tuple{AbstractString, AbstractString}, data)\n\nWrite data to a file filename, resp. to an internal sub-path of the file (if supported by the file format), e.g. an HDF5 group.\n\nCurrently supported file formats are:\n\nHDF5 with file extension \".h5\" or \".hdf5\"\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.bat_write-Tuple{Any,Any}","page":"API","title":"BAT.bat_write","text":"bat_write(dest::HDF5.DataFile, data)\nbat_write(dest_with_subpath::Tuple{HDF5.DataFile, AbstractString}, data)\n\nWrite data to HDF5 file or group dest (optionally to an HDF5-path relative to dest).\n\ndata must be a table (i.e. implement the Tables.jl API).\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.density_logval","page":"API","title":"BAT.density_logval","text":"density_logval(density::AbstractDensity, params::Any)\n\nCompute log of value of a multi-variate density function at the given parameter values.\n\nInput:\n\ndensity: density function\nparams: parameter values\n\nNote: If density_logval is called with out-of-bounds parameters (see param_bounds), the behaviour is undefined. The result for parameters that are not within bounds is implicitly -Inf, but it is the caller's responsibility to handle these cases.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.distribution_logpdf","page":"API","title":"BAT.distribution_logpdf","text":"distribution_logpdf(\n    pdist::AbstractProposalDist,\n    params_new::AbstractVector,\n    params_old:::AbstractVector\n)\n\nAnalog to distribution_logpdf!, but for a single parameter vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.distribution_logpdf!","page":"API","title":"BAT.distribution_logpdf!","text":"distribution_logpdf!(\n    p::AbstractArray,\n    pdist::AbstractProposalDist,\n    params_new::Union{AbstractVector,VectorOfSimilarVectors},\n    params_old:::Union{AbstractVector,VectorOfSimilarVectors}\n)\n\nReturns log(PDF) value of pdist for transitioning from old to new parameter values for multiple parameter sets.\n\nend\n\nInput:\n\nparams_new: New parameter values (column vectors)\nparams_old: Old parameter values (column vectors)\n\nOutput is stored in\n\np: Array of PDF values, length must match, shape is ignored\n\nArray size requirements:\n\nsize(params_old, 1) == size(params_new, 1) == length(pdist)\nsize(params_old, 2) == size(params_new, 2) or size(params_old, 2) == 1\nsize(params_new, 2) == length(p)\n\nImplementations of distribution_logpdf! must be thread-safe.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.fromuhc!","page":"API","title":"BAT.fromuhc!","text":"fromuhc!(Y::AbstractVector, X::AbstractVector, vol::SpatialVolume)\nfromuhc!(Y::VectorOfSimilarVectors, X::VectorOfSimilarVectors, vol::SpatialVolume)\n\nBijective transformation of coordinates X within the unit hypercube to coordinates Y in vol. If X and Y are matrices, the transformation is applied to the column vectors. Use Y === X to transform in-place.\n\nUse inv(fromuhc!) to get the the inverse transformation.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.fromuhc-Tuple{AbstractArray{T,1} where T,SpatialVolume}","page":"API","title":"BAT.fromuhc","text":"fromuhc(X::AbstractVector, vol::SpatialVolume)\nfromuhc(X::VectorOfSimilarVectors, vol::SpatialVolume)\n\nBijective transformation from unit hypercube to vol. See fromuhc!.\n\nUse inv(fromuhc) to get the the inverse transformation.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.fromui","page":"API","title":"BAT.fromui","text":"y = fromui(x::Real, lo::Real, hi::Real)\ny = fromui(x::Real, lo_hi::ClosedInterval{<:Real})\n\nLinear bijective transformation from the unit inverval (i.e. x ∈ 0..1) to y ∈ lo..hi.\n\nUse inv(fromui) to get the the inverse transformation.\n\nUse @inbounds to disable range checking on the input value.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.issymmetric_around_origin","page":"API","title":"BAT.issymmetric_around_origin","text":"issymmetric_around_origin(d::Distribution)\n\nReturns true (resp. false) if the Distribution is symmetric (resp. non-symmetric) around the origin.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.log_volume","page":"API","title":"BAT.log_volume","text":"log_volume(vol::SpatialVolume)\n\nGet the logarithm of the volume of the space in vol.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.nparams","page":"API","title":"BAT.nparams","text":"nparams(X::Union{AbstractParamBounds,MCMCIterator,...})\n\nGet the number of parameters of X.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.nparams-Tuple{AbstractDensity}","page":"API","title":"BAT.nparams","text":"nparams(density::AbstractDensity)::Union{Int,Missing}\n\nGet the number of parameters of density. May return missing, if the density supports a variable number of parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.nparams-Tuple{DistLikeDensity}","page":"API","title":"BAT.nparams","text":"nparams(density::DistLikeDensity)::Int\n\nGet the number of parameters of prior density density. Must not be missing, prior densities must have a fixed number of parameters. By default, the number of parameters is inferred from the parameter bounds.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.param_bounds","page":"API","title":"BAT.param_bounds","text":"param_bounds(density::DistLikeDensity)::AbstractParamBounds\n\nGet the parameter bounds of density. Must not be missing.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.param_bounds-Tuple{AbstractDensity}","page":"API","title":"BAT.param_bounds","text":"param_bounds(\n    density::AbstractDensity\n)::Union{AbstractParamBounds,Missing}\n\nGet the parameter bounds of density. See density_logval for the implications and handling of the bounds. If the bounds are missing, density_logval must be prepared to handle any parameter values.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.params_shape","page":"API","title":"BAT.params_shape","text":"params_shape(\n    density::AbstractDensity\n)::Union{ValueShapes.AbstractValueShape,Missing}\n\nparams_shape(\n    density::DistLikeDensity\n)::ValueShapes.AbstractValueShape\n\nparams_shape(\n    distribution::Distributions.Distribution\n)::ValueShapes.AbstractValueShape\n\nGet the shapes of parameters of density.\n\nFor prior densities, the result must not be missing, but may be nothing if the prior only supports flat parameter vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.proposal_rand!","page":"API","title":"BAT.proposal_rand!","text":"function proposal_rand!(\n    rng::AbstractRNG,\n    pdist::GenericProposalDist,\n    params_new::Union{AbstractVector,VectorOfSimilarVectors},\n    params_old::Union{AbstractVector,VectorOfSimilarVectors}\n)\n\nGenerate one or multiple proposed parameter vectors, based on one or multiple previous parameter vectors.\n\nInput:\n\nrng: Random number generator to use\npdist: Proposal distribution to use\nparams_old: Old parameter values (vector or column vectors, if a matrix)\n\nOutput is stored in\n\nparams_new: New parameter values (vector or column vectors, if a matrix)\n\nThe caller must guarantee:\n\nsize(params_old, 1) == size(params_new, 1)\nsize(params_old, 2) == size(params_new, 2) or size(params_old, 2) == 1\nparams_new !== params_old (no aliasing)\n\nImplementations of proposal_rand! must be thread-safe.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.spatialvolume","page":"API","title":"BAT.spatialvolume","text":"spatialvolume(b::ParamVolumeBounds)::SpatialVolume\n\nReturns the spatial volume that defines the parameter bounds.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.AbstractSamplingAlgorithm","page":"API","title":"BAT.AbstractSamplingAlgorithm","text":"BAT.AbstractSamplingAlgorithm\n\nAbstract type for BAT sampling algorithms. See bat_sample.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.DataSet","page":"API","title":"BAT.DataSet","text":"DataSet{T<:AbstractFloat, I<:Integer}\n\nNote: AHMI-internal, not part of stable API.\n\nHolds the MCMC output. For construction use constructor: function DataSet{T<:Real}(data::Matrix{T}, logprob::Vector{T}, weights::Vector{T})\n\nVariables\n\n'data' : An P x N array with N data points with P parameters.\n'logprob' : The logarithmic probability for each samples stored in an array\n'weights' : How often each sample occurred. Set to an array of ones if working directly on MCMC output\n'ids' : Array which is used to assign each sample to a batch, required for the cov. weighed uncertainty estimation\n.sortids : an array of indices which stores the original ordering of the samples (the space partitioning tree reorders the samples), required to calculate an effective sample size.\n'N' : number of samples\n'P' : number of parameters\n'nsubsets' : the number of batches\n'iswhitened' : a boolean value which indicates whether the data set is iswhitened\n'isnew' : a boolean value which indicates whether the data set was swapped out with a different one (it is possible to redo the integration with a different sample set using previously generated hyper-rectangles)\n'partitioningtree' : The space partitioning tree, used to efficiently identify samples in a point cloud\n'startingIDs' : The Hyper-Rectangle Seed Samples are stored in this array\n'tolerance' : A threshold required for the hyper-rectangle creation process.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.HMISettings","page":"API","title":"BAT.HMISettings","text":"HMISettings\n\nNote: AHMI-internal, not part of stable API.\n\nholds the settings for the hm_integrate function. There are several default constructors available: HMIFastSettings() HMIStandardSettings() HMIPrecisionSettings()\n\n#Variables\n\n'whitening_method::Symbol' : which whitening method to use\n'max_startingIDs::Integer' : influences how many starting ids are allowed to be generated\n'maxstartingIDsfraction::AbstractFloat' : how many points are considered as possible starting points as a fraction of total points available\n'rect_increase::AbstractFloat' : describes the procentual rectangle volume increase/decrease during hyperrectangle creation. Low values can increase the precision if enough points are available but can cause systematically wrong results if not enough points are available.\n'useallrects::Bool' : All rectangles are used for the integration process no matter how big their overlap is. If enabled the rectangles are weighted by their overlap.\n'useMultiThreading' : activate multithreading support.\n'warning_minstartingids' : the required minimum amount of starting samples\n'dotrimming' : determines whether the integral estimates are trimmed (1σ trim) before combining them into a final result (more robust)\n'uncertaintyestimators' : A dictionary of different uncertainty estimator functions. Currently three functions are available: hmcombineresultslegacy! (outdated, overestimates uncertainty significantly in higher dimensions), hmcombineresultscovweighted! (very fast) and hmcombineresults_analyticestimation! (recommended)\n\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.IntegrationVolume","page":"API","title":"BAT.IntegrationVolume","text":"IntegrationVolume{T<:AbstractFloat, I<:Integer}\n\nNote: AHMI-internal, not part of stable API.\n\nVariables\n\n'pointcloud' : holds the point cloud of the integration volume\n'spatialvolume' : the boundaries of the integration volume\n'volume' : the volume\n\nHold the point cloud and the spatial volume for integration.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.IntegrationVolume-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T}}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.IntegrationVolume","text":"IntegrationVolume(dataset::DataSet{T, I}, spvol::HyperRectVolume{T}, searchpts::Bool = true)::IntegrationVolume{T, I}\n\nNote: AHMI-internal, not part of stable API.\n\ncreates an integration region by calculating the point cloud an the volume of the spatial volume.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.MCMCCallbackWrapper","page":"API","title":"BAT.MCMCCallbackWrapper","text":"MCMCCallbackWrapper{F} <: AbstractMCMCCallback\n\nWraps a callable object to turn it into an AbstractMCMCCallback.\n\nConstructor:\n\nMCMCCallbackWrapper(f::Any)\n\nf needs to support the call syntax of an AbstractMCMCCallback.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.PointCloud","page":"API","title":"BAT.PointCloud","text":"PointCloud{T<:AbstractFloat, I<:Integer}\n\nNote: AHMI-internal, not part of stable API.\n\nStores the information of the points of an e.g. HyperRectVolume\n\nVariables\n\n'maxLogProb' : The maximum log. probability of one of the points inside the hyper-rectangle\n'minLogProb' : The minimum log. probability of one of the points inside the hyper-rectangle\n'maxWeightProb' : the weighted max. log. probability\n'minWeightProb' : the weighted min. log. probability\n'probfactor' : The probability factor of the hyper-rectangle\n'probweightfactor' : The weighted probability factor\n'points' : The number of points inside the hyper-rectangle\n'pointIDs' : the IDs of the points inside the hyper-rectangle, might be empty because it is optional and costs performance\n'searchres' : used to boost performance\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.PointCloud-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.PointCloud","text":"PointCloud{T<:AbstractFloat, I<:Integer}(dataset::DataSet{T, I}, hyperrect::HyperRectVolume{T}, searchpts::Bool = false)::PointCloud\n\nNote: AHMI-internal, not part of stable API.\n\ncreates a point cloud by searching the data tree for points which are inside the hyper-rectangle The parameter searchpts determines if an array of the point IDs is created as well\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.RandSampling","page":"API","title":"BAT.RandSampling","text":"BAT.RandSampling\n\nConstructors:\n\nBAT.RandSampling()\n\nSample via Random.rand. Only supported for posteriors of type Distributions.MultivariateDistribution and BAT.DistLikeDensity.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.RandomResampling","page":"API","title":"BAT.RandomResampling","text":"BAT.RandomResampling\n\nConstructors:\n\nBAT.RandomResampling()\n\nResample from a given set of samples.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.SearchResult","page":"API","title":"BAT.SearchResult","text":"SearchResult{T<:AbstractFloat, I<:Integer}\n\nNote: AHMI-internal, not part of stable API.\n\nStores the results of the space partitioning tree's search function\n\nVariables\n\n'pointIDs' : the IDs of samples found, might be empty because it is optional\n'points' : The number of points found.\n'maxLogProb' : the maximum log. probability of the points found.\n'minLogProb' : the minimum log. probability of the points found.\n'maxWeightProb' : the weighted minimum log. probability found.\n'minWeightProb' : the weighted maximum log. probfactor found.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.WhiteningResult","page":"API","title":"BAT.WhiteningResult","text":"WhiteningResult{T<:AbstractFloat}\n\nNote: AHMI-internal, not part of stable API.\n\nStores the information obtained during the Whitening Process\n\nVariables\n\n'determinant' : The determinant of the whitening matrix\n'targetprobfactor' : The suggested target probability factor\n'whiteningmatrix' : The whitening matrix\n'meanvalue' : the mean vector of the input data\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.apply_bounds","page":"API","title":"BAT.apply_bounds","text":"apply_bounds(x::Real, interval::ClosedInterval, boundary_type::BoundsType)\n\nSpecify lower and upper bound via interval.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.apply_bounds!","page":"API","title":"BAT.apply_bounds!","text":"apply_bounds!(params::AbstractVector, bounds::AbstractParamBounds)\n\nApply bounds to parameters params.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.apply_bounds-Union{Tuple{H}, Tuple{L}, Tuple{X}, Tuple{X,L,H,BoundsType}, Tuple{X,L,H,BoundsType,Any}} where H<:Real where L<:Real where X<:Real","page":"API","title":"BAT.apply_bounds","text":"apply_bounds(x::<:Real, lo::<:Real, hi::<:Real, boundary_type::BoundsType)\n\nApply lower/upper bound lo/hi to value x. boundary_type may be hard_bounds, cyclic_bounds or reflective_bounds.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.autocrl-Union{Tuple{AbstractArray{T,1}}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{Int64,1}}} where T<:Real","page":"API","title":"BAT.autocrl","text":"autocrl(xv::AbstractVector{T}, kv::AbstractVector{Int} = Vector{Int}())\n\nautocorrelation := Σ Cov[xi,x(i+k)]/Var[x]\n\nComputes the autocorrelations at various leg k of the input vector (time series) xv. The vector kv is the collections of lags to take into account\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.calculate_localmode-Tuple{Any}","page":"API","title":"BAT.calculate_localmode","text":"calculate_localmode(hist)\n\nCalculates the modes of a 1d statsbase histogram. A vector containing the bin-center(s) of the heighest bin(s) is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.create_hypercube-Union{Tuple{T}, Tuple{Array{T,1},T}} where T<:AbstractFloat","page":"API","title":"BAT.create_hypercube","text":"create_hypercube{T<:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume\n\nNote: AHMI-internal, not part of stable API.\n\ncreates a hypercube shaped spatial volume\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.create_hyperrectangle-Union{Tuple{I}, Tuple{T}, Tuple{I,BAT.DataSet{T,I},T,BAT.HMISettings}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.create_hyperrectangle","text":"create_hyperrectangle(...)\n\nNote: AHMI-internal, not part of stable API.\n\nThis function creates a hyper-rectangle around each starting sample. It starts by building a hyper-cube  and subsequently adapts each face individually, thus turning the hyper-cube into a hyper-rectangle. The faces are adjusted in a way to match the shape of the distribution as best as possible.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.default_sampling_algorithm","page":"API","title":"BAT.default_sampling_algorithm","text":"BAT.default_sampling_algorithm(posterior)\n\nGet BAT's default sampling algorithm for posterior.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.drop_low_weight_samples","page":"API","title":"BAT.drop_low_weight_samples","text":"drop_low_weight_samples(\n    samples::PosteriorSampleVector,\n    fraction::Real = 10^-4\n)\n\nDrop fraction of the total probability mass from samples to filter out the samples with the lowest weight.\n\nNote: BAT-internal function, not part of stable API.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.effective_sample_size-Tuple{AbstractArray,AbstractArray{T,1} where T}","page":"API","title":"BAT.effective_sample_size","text":"effective_sample_size(params::AbstractArray, weights::AbstractVector; with_weights=true)\n\nEffective size estimation for a (multidimensional) ElasticArray. By default applies the Kish approximation with the weigths available, but can be turned off (with_weights=false).\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.effective_sample_size-Tuple{StructArrays.StructArray{PosteriorSample{P,T,W,R,PA},1,NamedTuple{(:params, :log_posterior, :log_prior, :weight, :info),Tuple{PAV,TV,TV,WV,RV}},I} where I where RV<:AbstractArray{R,1} where WV<:AbstractArray{W,1} where TV<:AbstractArray{T,1} where PAV<:(AbstractArray{#s29,1} where #s29<:AbstractArray{P,1}) where PA<:AbstractArray{P,1} where R where W<:Real where T<:AbstractFloat where P<:Real}","page":"API","title":"BAT.effective_sample_size","text":"effective_sample_size(samples::PosteriorSampleVector; with_weights=true)\n\nEffective size estimation for a (multidimensional) PosteriorSampleVector. By default applies the Kish approximation with the weigths available, but can be turned off (with_weights=false).\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.effective_sample_size-Union{Tuple{AbstractArray{T1,1}}, Tuple{T1}, Tuple{T2}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1}}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},AbstractArray{Int64,1}}} where T1<:Real where T2<:Number","page":"API","title":"BAT.effective_sample_size","text":"Effective size estimation for a vector of samples xv. If a weight vector w is provided, the Kish approximation is applied.\n\nBy default computes the autocorrelation up to the square root of the number of entries in the vector, unless an explicit list of lags is provided (kv).\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.eval_density_logval-Tuple{AbstractDensity,AbstractArray{#s28,1} where #s28<:Real,ValueShapes.AbstractValueShape}","page":"API","title":"BAT.eval_density_logval","text":"eval_density_logval(\n    density::AbstractDensity,\n    params::AbstractVector{<:Real},\n    parshapes::ValueShapes.AbstractValueShape\n)\n\nInternal function to evaluate density log-value, calls density_logval.\n\nparshapes must be compatible with params_shape(density).\n\nChecks that:\n\nThe number of parameters of density (if known) matches the length of params.\nThe return value of density_logval is not NaN.\nThe return value of density_logval is less than +Inf.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.eval_prior_posterior_logval!","page":"API","title":"BAT.eval_prior_posterior_logval!","text":"BAT.eval_prior_posterior_logval!(\n    T::Type{<:Real},\n    density::AbstractDensity,\n    params::AbstractVector{<:Real}\n)\n\nFirst apply bounds to the parameters, compute prior and posterior log values by via eval_density_logval.\n\nMay modify params.\n\nReturns a NamedTuple{(:log_prior, :log_posterior),Tuple{T,T}}\n\nGuarantees that  :\n\nIf parameters are still out of bounds after applying bounds, density_logval is not called for either prior or likelihood. \nIf density_logval for prior returns -Inf, density_logval is not called for likelihood.\n\nIn both cases, T(-Inf) is returned for both prior and posterior.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.eval_prior_posterior_logval_strict!-Tuple{AbstractPosteriorDensity,AbstractArray{#s28,1} where #s28<:Real}","page":"API","title":"BAT.eval_prior_posterior_logval_strict!","text":"BAT.eval_prior_posterior_logval_strict!(\n    density::AbstractDensity,\n    params::AbstractVector{<:Real}\n)\n\nFirst apply bounds to the parameters, compute prior and posterior log values by via eval_density_logval.\n\nMay modify params.\n\nReturns a NamedTuple{(:log_prior, :log_posterior),Tuple{T,T}}. T is inferred from value returned by eval_density_logval for the likelihood.\n\nGuarantees that  :\n\nIf parameters are still out of bounds after applying bounds, density_logval is not called for either prior or likelihood. \nIf density_logval for prior returns -Inf, density_logval is not called for likelihood.\n\nIn both cases, an exception is thrown.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.find_hypercube_centers-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},BAT.WhiteningResult{T},BAT.HMISettings}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.find_hypercube_centers","text":"find_hypercube_centers(dataset::DataSet{T, I}, whiteningresult::WhiteningResult, settings::HMISettings)::Vector{I}\n\nNote: AHMI-internal, not part of stable API.\n\nfinds possible starting points for the hyperrectangle creation\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.gr_Rsqr-Tuple{AbstractArray{#s21,1} where #s21<:MCMCBasicStats}","page":"API","title":"BAT.gr_Rsqr","text":"gr_Rsqr(stats::AbstractVector{<:MCMCBasicStats})\n\nGelman-Rubin R^2 for all parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.hm_init-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},BAT.HMISettings}} where V<:SpatialVolume where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.hm_init","text":"hm_init!(result, settings)\n\nNote: AHMI-internal, not part of stable API.\n\nSets the global multithreading setting and ensures that a minimum number of samples, dependent on the number of dimensions, are provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.hm_integrate!-Union{Tuple{HMIData{T,I,V}}, Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},Symbol}} where V<:SpatialVolume where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.hm_integrate!","text":"hm_integrate!(result, settings = HMIPrecisionSettings())\n\nNote: AHMI-internal, not part of stable API.\n\nThis function starts the adaptive harmonic mean integration. See arXiv:1808.08051 for more details. It needs a HMIData struct as input, which holds the samples, in form of a dataset, the integration volumes and other properties, required for the integration, and the final result.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.hm_whiteningtransformation!-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},BAT.HMISettings}} where V<:SpatialVolume where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.hm_whiteningtransformation!","text":"hm_whiteningtransformation!(result, settings)\n\nNote: AHMI-internal, not part of stable API.\n\nApplies a whitening transformation to the samples. A custom whitening method can be used by overriding settings.whitening_function!\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.hyperrectangle_creationproccess!-Union{Tuple{I}, Tuple{T}, Tuple{BAT.DataSet{T,I},T,BAT.HMISettings,Array{BAT.IntegrationVolume{T,I,HyperRectVolume{T}},1},Array{HyperRectVolume{T},1},Array{I,1},Base.Threads.Atomic{I},ProgressMeter.Progress}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.hyperrectangle_creationproccess!","text":"hyperrectangle_creationproccess!(...)\n\nNote: AHMI-internal, not part of stable API.\n\nThis function assigns each thread its own hyper-rectangle to build, if in multithreading-mode.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.initial_params!","page":"API","title":"BAT.initial_params!","text":"BAT.initial_params!(\n    params::Union{AbstractVector{<:Real},VectorOfSimilarVectors{<:Real}},\n    rng::AbstractRNG,\n    posterior::AbstractPosteriorDensity,\n    algorithm::MCMCAlgorithm\n)::typeof(params)\n\nFill params with random initial parameters suitable for posterior and algorithm. The default implementation will try to draw the initial parameters from the prior of the posterior.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.modify_hypercube!-Union{Tuple{T}, Tuple{HyperRectVolume{T},Array{T,1},T}} where T<:AbstractFloat","page":"API","title":"BAT.modify_hypercube!","text":"create_hypercube!{T<:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume\n\nNote: AHMI-internal, not part of stable API.\n\nresizes a hypercube shaped spatial volume\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.modify_integrationvolume!-Union{Tuple{I}, Tuple{T}, Tuple{BAT.IntegrationVolume{T,I,V} where V<:SpatialVolume,BAT.DataSet{T,I},HyperRectVolume{T}}, Tuple{BAT.IntegrationVolume{T,I,V} where V<:SpatialVolume,BAT.DataSet{T,I},HyperRectVolume{T},Bool}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.modify_integrationvolume!","text":"modify_integrationvolume!(intvol::IntegrationVolume{T, I}, dataset::DataSet{T, I}, spvol::HyperRectVolume{T}, searchpts::Bool = true)\n\nNote: AHMI-internal, not part of stable API.\n\nupdates an integration volume with new boundaries. Recalculates the pointcloud and volume.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.wgt_effective_sample_size-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T<:Real","page":"API","title":"BAT.wgt_effective_sample_size","text":"wgt_effective_sample_size(w::AbstractVector{T})\n\nKish's approximation for weighted samples effectivesamplesize estimation. Computes the weighting factor for weigthed samples, where w is the vector of weigths.\n\n\n\n\n\n","category":"method"},{"location":"developing/#Developer-Instructions-1","page":"Developer instructions","title":"Developer Instructions","text":"","category":"section"},{"location":"developing/#Documentation-Generation-1","page":"Developer instructions","title":"Documentation Generation","text":"","category":"section"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"To generate and view a local version of the documentation, run","category":"page"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"cd docs\njulia make.jl local","category":"page"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"then open \"docs/build/index.html\" in your browser.","category":"page"},{"location":"developing/#Code-Reloading-1","page":"Developer instructions","title":"Code Reloading","text":"","category":"section"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"When changing the code of BAT.jl and testing snippets and examples in the REPL, automatic code reloading comes in very handy. Try out Revise.jl.","category":"page"},{"location":"algorithms/#Algorithms-1","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/#Sampling-Algorithms-1","page":"Algorithms","title":"Sampling Algorithms","text":"","category":"section"},{"location":"algorithms/#","page":"Algorithms","title":"Algorithms","text":"TODO: List algorithms and short short descriptions.","category":"page"},{"location":"algorithms/#Integration-Algorithms-1","page":"Algorithms","title":"Integration Algorithms","text":"","category":"section"},{"location":"algorithms/#","page":"Algorithms","title":"Algorithms","text":"TODO: List algorithms and short short descriptions.","category":"page"},{"location":"algorithms/#Optimization-Algorithms-1","page":"Algorithms","title":"Optimization Algorithms","text":"","category":"section"},{"location":"algorithms/#","page":"Algorithms","title":"Algorithms","text":"TODO: List algorithms and short short descriptions.","category":"page"},{"location":"algorithms/#Other-Algorithms-1","page":"Algorithms","title":"Other Algorithms","text":"","category":"section"},{"location":"license/#License-1","page":"License","title":"License","text":"","category":"section"},{"location":"license/#","page":"License","title":"License","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Common-Models-and-Problems-1","page":"Examples","title":"Common Models and Problems","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#The-1-D-Gaussian-Model-1","page":"Examples","title":"The 1-D Gaussian Model","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#The-Poisson-Problem-(Counting-Experiments)-1","page":"Examples","title":"The Poisson Problem (Counting Experiments)","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#The-Binomial-Case-1","page":"Examples","title":"The Binomial Case","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#...-1","page":"Examples","title":"...","text":"","category":"section"},{"location":"examples/#Published-Scientific-Examples-1","page":"Examples","title":"Published Scientific Examples","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#A-Multivariate-Gaussian-Combination-Model-(Similar-to-BLUE)-1","page":"Examples","title":"A Multivariate Gaussian Combination Model (Similar to BLUE)","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"examples/#The-EFTfitter-1","page":"Examples","title":"The EFTfitter","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"... to be written ...","category":"page"},{"location":"#BAT.jl-Documentation-1","page":"Home","title":"BAT.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl stands for Bayesian Analysis Toolkit in Julia. It is a high high-performance tool box for Bayesian inference with statistical models expressed in a general-purpose programming language, instead of a domain-specific language.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Typical applications for this package are the extraction of the values of the parameters of a model, the comparison of different models in the light of a given data set and the test of the validity of a model to represent the data set at hand. BAT.jl provides access to the full Bayesian posterior distribution to enable parameter estimation, limit setting and uncertainty propagation. BAT.jl also provides supporting functionality like plotting recipes and reporting functions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl is implemented in pure Julia and allows for a flexible definition of mathematical models and applications while enabling the user to code for the performance required for computationally expensive numerical operations. BAT.jl provides implementations (internally and via other Julia packages) of algorithms for sampling, optimization and integration. A few predefined models will be  provided for standard cases such as histogram fitting and simple counting experiments (work in progress), but BAT's main focus is on the analysis of complex custom models. It is designed to enable multi-threaded and distributed (work in progress) code execution at various levels, running multiple MCMC chains in parallel is provided out-of-the-box.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"It's possible to use BAT.jl with likelihood functions implemented in languages other than Julia: Julia allows for calling code in C and Fortran, C++, Python and several other languages directly. In addition, BAT.jl provides a very lightweight binary RPC protocol that is easy to implement, to call non-Julia functions written in any language, running in separate processes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nBAT.jl requires Julia >= v1.0.5. Julia v1.3 or higher is recommended for full functionality and performance.","category":"page"},{"location":"#History-and-Status-1","page":"Home","title":"History and Status","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl is a complete rewrite of BAT, the Bayesian Analysis Toolkit in C++. BAT.jl is still a work in progress: It already provides several improvements over it's C++ predecessor, but has not yet reached feature parity.","category":"page"},{"location":"#Table-of-contents-1","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    # \"basics.md\",\n    \"installation.md\",\n    \"tutorial.md\",\n    # \"faq.md\",\n    # \"examples.md\",\n    # \"algorithms.md\",\n    # \"benchmarks.md\",\n    # \"publications.md\",\n    \"api.md\",\n    \"developing.md\",\n    \"license.md\",\n]\nDepth = 1","category":"page"},{"location":"#Citing-BAT.jl-1","page":"Home","title":"Citing BAT.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"When using BAT.jl for work that will result in a scientific publication, please cite","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Caldwell et al., BAT.jl - A Bayesian Analysis Toolkit in Julia, doi:10.5281/zenodo.2605312","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The DOI above is version-independent, you may want to use the DOI of the specific BAT.jl version used in your work.","category":"page"},{"location":"#Learning-(more-about)-Julia-1","page":"Home","title":"Learning (more about) Julia","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl is intended to supersede BAT in C++, long term. If you're considering to switch to BAT.jl but you're new to Julia and want to learn more about the the language, here are a few resources to get started:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The Julia website provides many links to introductory videos and written tutorials, e.g. \"Intro to Julia\", \"A Deep Introduction to Julia for Data Science and Scientific Computing\" and \"The Fast Track to Julia 1.0\". If you are familar with MATLAB or Python, you may also want to take a look at the \"MATLAB–Python–Julia cheatsheet\".","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note: Try to avoid tutorials and books written for older versions of Julia, as there have been quite a few changes to the language in v1.0.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"There are also a lot of interesting talks and tutorials on the Julia YouTube Channel. Have a look at the talks at JuliaCon 2018 to get an impression on the kinds of scientific applications Julia is being used for and why, e.g. \"Why Julia is the most suitable language for science\".","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The in-depth article Why Numba and Cython are not substitutes for Julia explains how Julia addresses several fundamental challenges inherent to scientific high-performance computing.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you want to get an impression of the attention to detail so typical for Julia, watch \"0.1 vs 1//10: How numbers are compared\".","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We acknowledge the contributions from all the BAT.jl users, they help us make BAT.jl a better project. Your help is most welcome!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Development of BAT.jl has been supported by funding from","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Deutsche Forschungsgemeinschaft (DFG, German Research Foundation)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/bat/BAT.jl/blob/master/docs/src/tutorial_lit.jl\"","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates a simple application of BAT.jl: A Bayesian fit of a histogram with two Gaussian peaks.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"You can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Table of contents:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Pages = [\"tutorial.md\"]\nDepth = 3","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note: This tutorial is somewhat verbose, as it aims to be easy to follow for users who are new to Julia. For the same reason, we deliberately avoid making use of Julia features like closures, anonymous functions, broadcasting syntax, performance annotations, etc.","category":"page"},{"location":"tutorial/#Input-Data-Generation-1","page":"Tutorial","title":"Input Data Generation","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"First, let's generate some synthetic data to fit. We'll need the Julia standard-library packages \"Random\", \"LinearAlgebra\" and \"Statistics\", as well as the packages \"Distributions\" and \"StatsBase\":","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Random, LinearAlgebra, Statistics, Distributions, StatsBase","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"As the underlying truth of our input data/histogram, let us choose an non-normalized probability density composed of two Gaussian peaks with a peak area of 500 and 1000, a mean of -1.0 and 2.0 and a standard error of 0.5","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"data = vcat(\n    rand(Normal(-1.0, 0.5), 500),\n    rand(Normal( 2.0, 0.5), 1000)\n)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"resulting in a vector of floating-point numbers:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"typeof(data) == Vector{Float64}","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Next, we'll create a histogram of that data, this histogram will serve as the input for the Bayesian fit:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"hist = append!(Histogram(-2:0.1:4), data)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Using the Julia \"Plots\" package","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Plots","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"we can plot the histogram:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data\"\n)\nsavefig(\"tutorial-data.pdf\")\nsavefig(\"tutorial-data.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Data)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's define our fit function - the function that we expect to describe the data histogram, at each x-Axis position x, depending on a given set p of model parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function fit_function(p::NamedTuple{(:a, :mu, :sigma)}, x::Real)\n    p.a[1] * pdf(Normal(p.mu[1], p.sigma), x) +\n    p.a[2] * pdf(Normal(p.mu[2], p.sigma), x)\nend\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The fit parameters (model parameters) a (peak areas) and mu (peak means) are vectors, parameter sigma (peak width) is a scalar, we assume it's the same for both Gaussian peaks.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The true values for the model/fit parameters are the values we used to generate the data:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"true_par_values = (a = [500, 1000], mu = (-1.0, 2.0), sigma = 0.5)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's visually compare the histogram and the fit function, using these true parameter values, to make sure everything is set up correctly:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data and True Statistical Model\"\n)\nplot!(\n    -4:0.01:4, x -> fit_function(true_par_values, x),\n    label = \"Truth\"\n)\nsavefig(\"tutorial-data-and-truth.pdf\")\nsavefig(\"tutorial-data-and-truth.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Data and True Statistical Model)","category":"page"},{"location":"tutorial/#Bayesian-Fit-1","page":"Tutorial","title":"Bayesian Fit","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now we'll perform a Bayesian fit of the generated histogram, using BAT, to infer the model parameters from the data histogram.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In addition to the Julia packages loaded above, we need BAT itself, as well as IntervalSets:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using BAT, IntervalSets","category":"page"},{"location":"tutorial/#Likelihood-Definition-1","page":"Tutorial","title":"Likelihood Definition","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"First, we need to define the likelihood (function) for our problem.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT represents densities like likelihoods and priors as subtypes of BAT.AbstractDensity. Custom likelihood can be defined by creating a new subtype of AbstractDensity and by implementing (at minimum) BAT.density_logval for that type - in complex uses cases, this may become necessary. Typically, however, it is sufficient to define a custom likelihood as a simple function that returns the log-likelihood value for a given set of parameters. BAT will automatically convert such a log-likelihood function into a subtype of AbstractDensity.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"For performance reasons, functions should not access global variables directly. So we'll use an anonymous function inside of a let-statement to capture the value of the global variable hist in a local variable h (and to shorten function name fit_function to f, purely for convenience):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"log_likelihood = let h = hist, f = fit_function\n    params -> begin\n        # Histogram counts for each bin as an array:\n        counts = h.weights\n\n        # Histogram binning, has length (length(counts) + 1):\n        binning = h.edges[1]\n\n        # sum log-likelihood value over bins:\n        ll_value::Float64 = 0.0\n        for i in eachindex(counts)\n            # Get information about current bin:\n            bin_left, bin_right = binning[i], binning[i+1]\n            bin_width = bin_right - bin_left\n            bin_center = (bin_right + bin_left) / 2\n\n            observed_counts = counts[i]\n\n            # Simple mid-point rule integration of fit function `f` over bin:\n            expected_counts = bin_width * f(params, bin_center)\n\n            # Add log of Poisson probability for bin:\n            ll_value += logpdf(Poisson(expected_counts), observed_counts)\n        end\n\n        return ll_value\n    end\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT makes use of Julia's parallel programming facilities if possible, e.g. to run multiple Markov chains in parallel. Therefore, log-likelihood (and other) code must be thread-safe. Mark non-thread-safe code with @critical (provided by Julia package ParallelProcessingTools).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT requires Julia v1.3 or newer to use multi-threading. Support for automatic parallelization across multiple (local and remote) Julia processes is planned, but not implemented yet.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note that Julia currently starts only a single thread by default. Set the the environment variable JULIA_NUM_THREADS to specify the desired number of Julia threads.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can evaluate log_likelihood, e.g. for the true parameter values:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"log_likelihood(true_par_values)","category":"page"},{"location":"tutorial/#Prior-Definition-1","page":"Tutorial","title":"Prior Definition","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Next, we need to choose a sensible prior for the fit:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"prior = NamedTupleDist(\n    a = [0.0..10.0^4, 0.0..10.0^4],\n    mu = [-2.0..0.0, 1.0..3.0],\n    sigma = Truncated(Normal(0.4, 2), 0.3, 0.7)\n)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In general, BAT allows instances of any subtype of AbstractDensity to be uses as a prior, as long as a sampler is defined for it. This way, users may implement complex application-specific priors. You can also use convert(AbstractDensity, distribution) to convert any continuous multivariate Distributions.Distribution to a BAT.AbstractDensity that can be used as a prior (or likelihood).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The prior also implies the shapes of the parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using ValueShapes\n\nparshapes = valshape(prior)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"These will come in handy later on, e.g. to access (the posterior distribution of) individual parameter values.","category":"page"},{"location":"tutorial/#Bayesian-Model-Definition-1","page":"Tutorial","title":"Bayesian Model Definition","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Given the likelihood and prior definition, a BAT.PosteriorDensity is simply defined via","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"posterior = PosteriorDensity(log_likelihood, prior)\nnothing # hide","category":"page"},{"location":"tutorial/#Parameter-Space-Exploration-via-MCMC-1","page":"Tutorial","title":"Parameter Space Exploration via MCMC","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can now use Markov chain Monte Carlo (MCMC) to explore the space of possible parameter values for the histogram fit.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To increase the verbosity level of BAT logging output, you may want to set the Julia logging level for BAT to debug via ENV[\"JULIA_DEBUG\"] = \"BAT\".","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's use 4 MCMC chains and require 10^5 unique samples from each chain (after tuning/burn-in):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"nsamples = 10^4\nnchains = 4\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now we can generate a set of MCMC samples via bat_sample:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"samples, stats = bat_sample(posterior, (nsamples, nchains), MetropolisHastings())\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's calculate some posterior statistics using the function bat_stats and print the results:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"println(\"Truth: $true_par_values\")\nprintln(\"Mode: $(stats.mode)\")\nprintln(\"Mean: $(stats.mean)\")\nprintln(\"Covariance: $(stats.cov)\")","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can also, e.g., get the Pearson auto-correlation of the parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"cor(samples.params, FrequencyWeights(samples.weight))","category":"page"},{"location":"tutorial/#Visualization-of-Results-1","page":"Tutorial","title":"Visualization of Results","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT.jl comes with an extensive set of plotting recipes for \"Plots.jl\". We can plot the marginalized distribution for a single parameter (e.g. parameter 3, i.e. μ₁):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"par_names = [\"a_1\", \"a_2\", \"mu_1\", \"mu_2\", \"sigma\"]\nplot(\n    samples, 3,\n    mean = true, std_dev = true, globalmode = true, localmode = true,\n    nbins = 50, xlabel = par_names[3], ylabel = \"P($(par_names[3]))\",\n    title = \"Marginalized Distribution for mu_1\"\n)\nsavefig(\"tutorial-single-par.pdf\")\nsavefig(\"tutorial-single-par.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Marginalized Distribution for mu_1)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"or plot the marginalized distribution for a pair of parameters (e.g. parameters 3 and 5, i.e. μ₁ and σ), including information from the parameter stats:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples, (3, 5),\n    mean = true, std_dev = true, globalmode = true, localmode = true,\n    nbins = 50, xlabel = par_names[3], ylabel = par_names[5],\n    title = \"Marginalized Distribution for mu_1 and sigma\"\n)\nplot!(MCMCBasicStats(samples), (3, 5))\nsavefig(\"tutorial-param-pair.pdf\")\nsavefig(\"tutorial-param-pair.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Marginalized Distribution for mu_1 and sigma)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can also create an overview plot of the marginalized distribution for all pairs of parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples,\n    mean = false, std_dev = false, globalmode = true, localmode = false,\n    nbins = 50\n)\nsavefig(\"tutorial-all-params.pdf\")\nsavefig(\"tutorial-all-params.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Pairwise Correlation between Parameters)","category":"page"},{"location":"tutorial/#Integration-with-Tables.jl-1","page":"Tutorial","title":"Integration with Tables.jl","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT.jl supports the Tables.jl interface. So we can also convert the vector of MCMC samples vecto a table, e.g. using TypedTables.jl](http://blog.roames.com/TypedTables.jl/stable/):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using TypedTables\n\ntbl = Table(samples)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Using the parameter shapes, we can generate a table with named parameters, instead of flat real-valued parameter vectors:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"tbl_named = parshapes.(samples)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can now, e.g., find the sample with the maximum posterior value (i.e. the mode):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"mode_log_posterior, mode_idx = findmax(tbl_named.log_posterior)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"And get row mode_idx of the table, with all information about the sample at the mode:","category":"page"},{"location":"tutorial/#Comparison-of-Truth-and-Best-Fit-1","page":"Tutorial","title":"Comparison of Truth and Best Fit","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"As a final step, we retrieve the parameter values at the mode, representing the best-fit parameters","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"fit_par_values = tbl_named[mode_idx].params","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"And plot the truth, data, and best fit:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data, True Model and Best Fit\"\n)\nplot!(-4:0.01:4, x -> fit_function(true_par_values, x), label = \"Truth\")\nplot!(-4:0.01:4, x -> fit_function(fit_par_values, x), label = \"Best fit\")\nsavefig(\"tutorial-data-truth-bestfit.pdf\")\nsavefig(\"tutorial-data-truth-bestfit.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Data, True Model and Best Fit)","category":"page"},{"location":"tutorial/#Fine-grained-control-1","page":"Tutorial","title":"Fine-grained control","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT provides fine-grained control over the MCMC algorithm options, the MCMC chain initialization, tuning/burn-in strategy and convergence testing. All option value used in the following are the default values, any or all may be omitted.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We'll sample using the The Metropolis-Hastings MCMC algorithm. By default, BAT uses a multivariate t-distribution (ν = 1) as the proposal function:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"algorithm = MetropolisHastings(MvTDistProposal(1.0))\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT requires a counter-based random number generator (RNG), since it partitions the RNG space over the MCMC chains. This way, a single RNG seed is sufficient for all chains and results are reproducible even under parallel execution. By default, BAT uses a Philox4x RNG initialized with a random seed drawn from the system entropy pool:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Random123\nrng = Philox4x()\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Other default parameters are:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"tuning = AdaptiveMetropolisTuning(\n    λ = 0.5,\n    α = 0.15..0.35,\n    β = 1.5,\n    c = 1e-4..1e2\n)\n\nconvergence = BrooksGelmanConvergence(\n    threshold = 1.1,\n    corrected = false\n)\n\ninit = MCMCInitStrategy(\n    ninit_tries_per_chain = 8..128,\n    max_nsamples_pretune = 25,\n    max_nsteps_pretune = 250,\n    max_time_pretune = Inf\n)\n\nburnin = MCMCBurninStrategy(\n    max_nsamples_per_cycle = 1000,\n    max_nsteps_per_cycle = 10000,\n    max_time_per_cycle = Inf,\n    max_ncycles = 30\n)\n\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To generate MCMC samples with explicit control over all options, use","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"samples, stats = bat_sample(\n    rng, posterior, (nsamples, nchains), algorithm,\n    max_nsteps = 10 * nsamples,\n    max_time = Inf,\n    tuning = tuning,\n    init = init,\n    burnin = burnin,\n    convergence = convergence,\n    strict = false,\n    filter = true\n)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"However, in many use cases, simply using the default options via","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"samples, stats = bat_sample(posterior, (nsamples, nchains), MetropolisHastings())","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"will often be sufficient.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
