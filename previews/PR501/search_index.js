var documenterSearchIndex = {"docs":
[{"location":"list_of_algorithms/#List-of-BAT-algorithms","page":"List of algorithms","title":"List of BAT algorithms","text":"BAT offers multiple algorithms for sampling, integration and optimization:","category":"section"},{"location":"list_of_algorithms/#Sampling-algorithms","page":"List of algorithms","title":"Sampling algorithms","text":"BAT function: bat_sample","category":"section"},{"location":"list_of_algorithms/#IIDSampling","page":"List of algorithms","title":"IIDSampling","text":"BAT sampling algorithm type: IIDSampling\n\nbat_sample(target.prior, IIDSampling(nsamples=10^5))","category":"section"},{"location":"list_of_algorithms/#Metropolis-Hastings","page":"List of algorithms","title":"Metropolis-Hastings","text":"BAT sampling algorithm type: TransformedMCMC, MCMC algorithm subtype: RandomWalk\n\nbat_sample(target, TransformedMCMC(mcalg = RandomWalk(), nsteps = 10^5, nchains = 4))","category":"section"},{"location":"list_of_algorithms/#Hamiltonian-MC","page":"List of algorithms","title":"Hamiltonian MC","text":"BAT sampling algorithm type: TransformedMCMC, MCMC algorithm subtype: HamiltonianMC\n\nimport AdvancedHMC, ForwardDiff\nset_batcontext(ad = ForwardDiff)\nbat_sample(target, TransformedMCMC(mcalg = HamiltonianMC()))\n\nRequires the AdvancedHMC Julia package to be loaded explicitly.","category":"section"},{"location":"list_of_algorithms/#Reactive-Nested-Sampling-(experimental)","page":"List of algorithms","title":"Reactive Nested Sampling (experimental)","text":"BAT sampling algorithm type: ReactiveNestedSampling\n\nimport UltraNest\nbat_sample(target, ReactiveNestedSampling())\n\nRequires the UltraNest Julia package to be loaded explicitly.","category":"section"},{"location":"list_of_algorithms/#Ellipsoidal-Nested-Sampling-(experimental)","page":"List of algorithms","title":"Ellipsoidal Nested Sampling (experimental)","text":"BAT sampling algorithm type: EllipsoidalNestedSampling\n\nimport NestedSamplers\nbat_sample(target, EllipsoidalNestedSampling())\n\nRequires the NestedSamplers Julia package to be loaded explicitly.","category":"section"},{"location":"list_of_algorithms/#Sobol-Sampler","page":"List of algorithms","title":"Sobol Sampler","text":"BAT sampling algorithm type: SobolSampler\n\nbat_sample(target, SobolSampler(nsamples=10^5))","category":"section"},{"location":"list_of_algorithms/#Grid-Sampler","page":"List of algorithms","title":"Grid Sampler","text":"BAT sampling algorithm type: GridSampler\n\nbat_sample(target, GridSampler(ppa=100))","category":"section"},{"location":"list_of_algorithms/#Prior-Importance-Sampler","page":"List of algorithms","title":"Prior Importance Sampler","text":"BAT sampling algorithm type: PriorImportanceSampler\n\nbat_sample(target, PriorImportanceSampler(nsamples=10^5))","category":"section"},{"location":"list_of_algorithms/#Integration-algorithms","page":"List of algorithms","title":"Integration algorithms","text":"BAT function: bat_integrate","category":"section"},{"location":"list_of_algorithms/#Vegas-Integration","page":"List of algorithms","title":"Vegas Integration","text":"BAT integration algorithm type: VEGASIntegration\n\nimport Cuba\nbat_integrate(target, VEGASIntegration())\n\nRequires the Cuba Julia package to be loaded explicitly.","category":"section"},{"location":"list_of_algorithms/#Suave-Integration","page":"List of algorithms","title":"Suave Integration","text":"BAT integration algorithm type: SuaveIntegration\n\nimport Cuba\nbat_integrate(target, SuaveIntegration())\n\nRequires the Cuba Julia package to be loaded explicitly.","category":"section"},{"location":"list_of_algorithms/#Cuhre-Integration","page":"List of algorithms","title":"Cuhre Integration","text":"BAT integration algorithm type: CuhreIntegration\n\nimport Cuba\nbat_integrate(target, CuhreIntegration())\n\nRequires the Cuba Julia package to be loaded explicitly.","category":"section"},{"location":"list_of_algorithms/#Divonne-Integration","page":"List of algorithms","title":"Divonne Integration","text":"BAT integration algorithm type: DivonneIntegration \n\nimport Cuba\nbat_integrate(target, DivonneIntegration())\n\nRequires the Cuba Julia package to be loaded explicitly.","category":"section"},{"location":"list_of_algorithms/#Integration-via-Bridge-Sampling-(experimental)","page":"List of algorithms","title":"Integration via Bridge Sampling (experimental)","text":"BAT integration algorithm type: BridgeSampling \n\nbat_integrate(EvaluatedMeasure(target, smpls), BridgeSampling())","category":"section"},{"location":"list_of_algorithms/#Mode-finding-algorithms","page":"List of algorithms","title":"Mode finding algorithms","text":"BAT function: bat_findmode","category":"section"},{"location":"list_of_algorithms/#Optim.jl-Optimization-Algorithms","page":"List of algorithms","title":"Optim.jl Optimization Algorithms","text":"BAT mode finding algorithm type: OptimAlg.\n\nusing Optim\nbat_findmode(target, OptimAlg(optalg = Optim.NelderMead()))\n\nimport ForwardDiff\nset_batcontext(ad = ForwardDiff)\nbat_findmode(target, OptimAlg(optalg = Optim.LBFGS()))\n\nRequires the Optim Julia package to be loaded explicitly.","category":"section"},{"location":"list_of_algorithms/#OptimizationBase.jl-Optimization-Algorithms","page":"List of algorithms","title":"OptimizationBase.jl Optimization Algorithms","text":"BAT mode finding algorithm type: OptimizationAlg.\n\nusing OptimizationOptimJL\n\nalg = OptimizationAlg(; \n    optalg = OptimizationOptimJL.ParticleSwarm(n_particles=10), \n    maxiters=200, \n    kwargs=(f_calls_limit=50,)\n)\nbat_findmode(target, alg)\n\nRequires the desired package that implements the OptimizationBase.jl interface to be loaded (e.g. via import OptimizationOptimJL).","category":"section"},{"location":"list_of_algorithms/#Maximum-Sample-Estimator","page":"List of algorithms","title":"Maximum Sample Estimator","text":"BAT mode finding algorithm type: MaxDensitySearch \n\nbat_findmode(smpls, MaxDensitySearch())","category":"section"},{"location":"list_of_algorithms/#File-I/O","page":"List of algorithms","title":"File-I/O","text":"","category":"section"},{"location":"list_of_algorithms/#Plain-HDF5","page":"List of algorithms","title":"Plain HDF5","text":"BAT I/O algorithm type: BATHDF5IO \n\nimport HDF5\nbat_write(\"results.h5\", smpls)\n\n# ... later ...\n\nsmpls = bat_read(\"results.h5\").result","category":"section"},{"location":"list_of_algorithms/#JLD2","page":"List of algorithms","title":"JLD2","text":"Not BAT-specific, JLD2 is able to handle complex Julia data structures in general.\n\nusing FileIO\nimport JLD2\nFileIO.save(\"results.jld2\", Dict(\"smpls\" => smpls))\n\n# ... later ...\n\nsmpls = FileIO.load(\"results.jld2\", \"smpls\")","category":"section"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"BAT.jl is written in the Julia programming language. To use BAT.jl, you will need to install Julia itself, the BAT.jl Julia package, and some additional Julia packages. Depending on your use case, you may also want to need a Python installation with certain Python packages (optional).\n\nTable of contents:\n\nPages = [\"installation.md\"]\nDepth = 3","category":"section"},{"location":"installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"Julia is available for Linux, OS-X and Windows, and easy to install:\n\nDownload Julia.\nExtract the archive (Linux), resp. drag Julia into Applications (OS-X) or run the installer (Windows).\nYou may want to add the Julia bin directory to your $PATH. To get the location of the Julia bin directory on OS-X or Windows, start a Julia session (via applications menu) and run the Julia command Sys.BINDIR.\n\nnote: Note\nBAT.jl requires Julia >= v1.10, we recommend to use the latest stable Julia version for optimal performance.","category":"section"},{"location":"installation/#Installing-BAT.jl-and-related-Julia-packages","page":"Installation","title":"Installing BAT.jl and related Julia packages","text":"BAT.jl is provided as a registered Julia package. To install it, simply run\n\njulia> using Pkg\njulia> pkg\"add BAT\"\n\nHowever, you will likely need other Julia packages too. We recommend that you install certain statistics, plotting, I/O and array packages as well:\n\njulia> using Pkg\njulia> pkg\"add BAT ArraysOfArrays Distributions ElasticArrays IntervalSets Parameters Plots StatsBase Tables TypedTables\"\n\nIn addition, these packages will need to be installed and loaded (using PackageName or import PackageName) to enable some optional BAT algorithms/functionalities:\n\njulia> pkg\"add AutoDiffOperators AdvancedHMC Cuba Folds HDF5 NestedSamplers Optim\"\n\nTo install the latest development version of BAT (main branch) instead of the latest stable release, use\n\njulia> pkg\"add BAT#main\"","category":"section"},{"location":"installation/#Installing-Visual-Studio-Code-and-Jupyter-(Optional)","page":"Installation","title":"Installing Visual Studio Code and Jupyter (Optional)","text":"Please download and install the lastest Julia release.\n\nYou may also want to install Visual Studio Code with the VS-Code Julia extension and/or a have a working Jupyter installation. JupyterLab Desktop is easy to install (but a full Anaconda or custom Python installation with Jupyter will work too, of course). For details regarding Julia and Jupyter, see the IJulia.jl documentation.","category":"section"},{"location":"installation/#IJulia-(Jupyter-Julia-kernel)","page":"Installation","title":"IJulia (Jupyter Julia kernel)","text":"To use the the Julia Jupyter kernel, you need to add the package \"IJulia.jl\":\n\nOn Linux, simply use\n\npkg\"add IJulia\"\n\nOn OS-X, if you have an existing Jupyter installation (e.g. via Anaconda) and would like Julia to use it (instead of an internal Conda installation, see above), use (e.g.)\n\nENV[\"JUPYTER\"] = \"$(homedir())/opt/anaconda3/bin/jupyter\"; pkg\"add IJulia\"\n\nOn Windows, if would like Julia to use an existing Jupyter installation (see above), use something like\n\nENV[\"JUPYTER\"] = \"DRIVE:/path/to/your/anaconda/.../jupyter.exe\"; pkg\"add IJulia\"\n\nJulia will remember the chosen Jupyter installation permanently, ENV[\"JUPYTER\"] only needs to be set the first time you run pkg\"add IJulia\".","category":"section"},{"location":"installation/#Environment-variables","page":"Installation","title":"Environment variables","text":"You may want/need to set the following environment variables:\n\n$PATH: Include the Julia bin-directory in your binary search path, see above. On OS-X and Windows, Visual Studio Code should detect the path your Julia binary automatically, if installed in the default location.\n$JULIA_NUM_THREADS: Number of threads to use for Julia multi-threading\n$JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR: If you want Julia to install packages in another location than $HOME/.julia.\n\nSee the Julia manual for a description of other Julia-specific environment variables.","category":"section"},{"location":"installation/#Additional-customization-options","page":"Installation","title":"Additional customization options","text":"Note: If you want Julia to install packages in another location than $HOME/.julia, set the environment variables JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR (see above).","category":"section"},{"location":"stable_api/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"This is the stable public API of BAT. Forward/backward compatibility follows Julia's semantic versioning rules.","category":"section"},{"location":"stable_api/#Types","page":"API Documentation","title":"Types","text":"Pages = [\"stable_api.md\"]\nOrder = [:type]","category":"section"},{"location":"stable_api/#Functions-and-macros","page":"API Documentation","title":"Functions and macros","text":"Pages = [\"stable_api.md\"]\nOrder = [:macro, :function]","category":"section"},{"location":"stable_api/#Documentation","page":"API Documentation","title":"Documentation","text":"","category":"section"},{"location":"stable_api/#BAT.bat_convergence","page":"API Documentation","title":"BAT.bat_convergence","text":"bat_convergence(\n    algoutput,\n    [algorithm::ConvergenceTest],\n    [context::BATContext]\n)\n\nCheck if an algorithm has converged, based on it's output algoutput\n\nReturns a NamedTuple of the shape\n\n(result, ...)\n\nresult indicates whether algoutput and must either be a Bool or support convert(Bool, result). It should typically contains measures of algorithm convergence, like a convergence value and it's threshold, etc.\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_convergence, add methods to bat_convergence_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_default","page":"API Documentation","title":"BAT.bat_default","text":"bat_default(f::Base.Callable, argname::Symbol, objectives...)\nbat_default(f::Base.Callable, argname::Val, objectives...)\n\nGet the default value for argument argname of function f to use for objective(s).\n\nobjective(s) are mandatory arguments of function f that semantically constitute it's main objective(s), and that that a good default choice of optional arguments (e.g. choice of algorithm(s), etc.) may depend on. Which arguments are considered to be objectives is function-specific.\n\nFor example:\n\nbat_default(bat_sample, :algorithm, density::PosteriorMeasure) == RandomWalk()\nbat_default(bat_sample, Val(:algorithm), samples::DensitySampleVector) == OrderedResampling()\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_eff_sample_size","page":"API Documentation","title":"BAT.bat_eff_sample_size","text":"bat_eff_sample_size(\n    v::Union{AbstractVector{<:Real},AbstractVectorOfSimilarVectors{<:Real}},\n    [algorithm::EffSampleSizeAlgorithm],\n    [context::BATContext]\n)\n\nbat_eff_sample_size(\n    smpls::DensitySampleVector,\n    [algorithm::EffSampleSizeAlgorithm],\n    [context::BATContext]\n)\n\nEstimate effective sample size estimation for variate series v, resp. density samples smpls, separately for each degree of freedom.\n\nReturns a NamedTuple of the shape\n\n(result = eff_sample_size, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_eff_sample_size, add methods to bat_eff_sample_size_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_findmedian","page":"API Documentation","title":"BAT.bat_findmedian","text":"bat_findmedian(\n    samples::DensitySampleVector\n)\n\nThe function computes the median of marginalized samples.\n\nReturns a NamedTuple of the shape\n\n(result = v, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_findmedian, add methods to bat_findmedian_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_findmode","page":"API Documentation","title":"BAT.bat_findmode","text":"bat_findmode(\n    target::BAT.AnySampleable,\n    [algorithm::BAT.AbstractModeEstimator],\n    [context::BATContext]\n)::DensitySampleVector\n\nEstimate the global mode of target.\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, evaluated::EvaluatedMeasure, ...)\n\n(The field evaluated is only present if target is a measure.)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_findmode, add methods to bat_findmode_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_initval","page":"API Documentation","title":"BAT.bat_initval","text":"bat_initval(\n    target::BAT.MeasureLike,\n    [algorithm::BAT.InitvalAlgorithm],\n    [context::BATContext]\n)::V\n\nbat_initval(\n    target::BAT.MeasureLike,\n    n::Integer,\n    [algorithm::BAT.InitvalAlgorithm],\n    [context::BATContext]\n)::AbstractVector{<:V}\n\nGenerate one or n random initial/starting value(s) suitable for target.\n\nAssuming the variates of target are of type T, returns a NamedTuple of the shape\n\n(result = X::AbstractVector{T}, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_initval, add methods likebat_initval_impl(target::MeasureLike, algorithm::InitvalAlgorithm, context::BATContext)\nbat_initval_impl(target::MeasureLike, n::Integer, algorithm::InitvalAlgorithm, context::BATContext)to bat_initval_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_integrate","page":"API Documentation","title":"BAT.bat_integrate","text":"bat_integrate(\n    target::AnySampleable,\n    [algorithm::IntegrationAlgorithm],\n    [context::BATContext]\n)::DensitySampleVector\n\nCalculate the integral (evidence) of target.\n\nReturns a NamedTuple of the shape\n\n(result = X::Measurements.Measurement, evaluated::EvaluatedMeasure, ...)\n\n(The field evaluated is only present if target is a measure.)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_integrate, add methods to bat_integrate_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_read","page":"API Documentation","title":"BAT.bat_read","text":"bat_read(\n    filename::AbstractString,\n    [key,]\n    [algorithm::BATIOAlgorithm]\n)\n\nRead data (optionally selected by key) from filename using algorithm.\n\nExample:\n\nsmpls = bat_read(\"samples.hdf5\", smpls).result\n\nReturns (result = content, ...)\n\nResult properties not listed here are specific to the output algorithm and are not part of the stable public API.\n\nSee bat_write.\n\nCurrently supported file formats are:\n\nHDF5 with file extension \".h5\" or \".hdf5\"\n\nnote: Note\nHDF5 I/O functionality is only available when the HDF5 package is loaded (e.g. via import HDF5).\n\nnote: Note\nDo not add add algorithms to bat_read, add algorithms to bat_read_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_sample","page":"API Documentation","title":"BAT.bat_sample","text":"bat_sample(\n    target::BAT.AnySampleable,\n    [algorithm::BAT.AbstractSamplingAlgorithm],\n    [context::BATContext]\n)::DensitySampleVector\n\nDraw samples from target using algorithm.\n\nDepending on sampling algorithm, the samples may be independent or correlated (e.g. when using MCMC).\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, evaluated::EvaluatedMeasure, ...)\n\n(The field evaluated is only present if target is a measure.)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_sample, add methods to bat_sample_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_write","page":"API Documentation","title":"BAT.bat_write","text":"bat_write(\n    filename::AbstractString,\n    content,\n    [algorithm::BATIOAlgorithm]\n)\n\nWrite content to file filename using algorithm.\n\nExample:\n\nsmpls = bat_sample(posterior, ...).result\nbat_write(\"samples.hdf5\", smpls)\n\nReturns (result = filename, ...)\n\nResult properties not listed here are specific to the output algorithm and are not part of the stable public API.\n\nSee bat_read.\n\nCurrently supported file formats are:\n\nHDF5 with file extension \".h5\" or \".hdf5\"\n\nnote: Note\nHDF5 I/O functionality is only available when the HDF5 package is loaded (e.g. via import HDF5).\n\nnote: Note\nDo not add add algorithms to bat_write, add algorithms to bat_write_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_transform","page":"API Documentation","title":"BAT.bat_transform","text":"bat_transform(\n    how::AbstractTransformTarget,\n    object,\n    [algorithm::TransformAlgorithm]\n)\n\nbat_transform(\n    f,\n    object,\n    [algorithm::TransformAlgorithm]\n)\n\nTransform object to another variate space defined/implied by target, res. using the transformation function f.\n\nReturns a NamedTuple of the shape\n\n(result = newdensity, f_transform = vartrafo::Function, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nAs a convenience,flat_smpls, f_flatten = bat_transform(Vector, measure)\nflat_smpls, f_flatten = bat_transform(Vector, samples)can be used to flatten a the variate type of a measure (res. samples of a measure) to something like Vector{<:Real}.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.get_batcontext","page":"API Documentation","title":"BAT.get_batcontext","text":"get_batcontext()::BATContext\nget_batcontext(obj)::BATContext\n\nGets resp. sets the default computational context for BAT.\n\nWill create and set a new default context if none exists.\n\nNote: get_batcontext() does not have a stable return type. Code that needs type stability should pass a context to algorithms explicitly. BAT algorithms that call other algorithms must forward their context automatically, so context is always type stable within nested BAT algorithms.\n\nSee BATContext and set_batcontext.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.set_batcontext","page":"API Documentation","title":"BAT.set_batcontext","text":"set_batcontext(new_context::BATContext)\n\nset_batcontext(;\n    precision = ...,\n    rng = ...,\n    ad = ...\n)\n\nSets the default computational context for BAT.\n\nSee BATContext and get_batcontext.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.log_batdebug","page":"API Documentation","title":"BAT.log_batdebug","text":"log_batdebug(enable::Bool = true)\n\nEnable/disable debug-level logging for BAT and all BAT package extensions.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.distbind","page":"API Documentation","title":"BAT.distbind","text":"distbind(f_k, dist, ::typeof(merge))\n\nPerforms a generalized monadic bind, in the functional programming sense, with a transition kernel f_k, a distribution dist, using merge to control the type of \"flattening\".\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.distprod","page":"API Documentation","title":"BAT.distprod","text":"distprod(;a = some_dist, b = some_other_dist, ...)\ndistprod(();a = some_dist, b = some_other_dist, ...))\ndistprod([dist1, dist2, dist2, ...])\n\nGenerate a product of distributions, returning either a distribution that has NamedTuples as variates, or arrays as variates.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.lbqintegral","page":"API Documentation","title":"BAT.lbqintegral","text":"lbqintegral(integrand, measure)\nlbqintegral(likelihood, prior)\n\nReturns an object that represents the Lebesgue integral over a function in respect to s reference measure. It is also the non-normalized posterior measure that results from integrating the likelihood of a given observation in respect to a prior measure.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.AbstractMCMCWeightingScheme","page":"API Documentation","title":"BAT.AbstractMCMCWeightingScheme","text":"abstract type AbstractMCMCWeightingScheme{T<:Real}\n\nAbstract class for weighting schemes for MCMC samples.\n\nWeight values will have type T.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractPosteriorMeasure","page":"API Documentation","title":"BAT.AbstractPosteriorMeasure","text":"abstract type AbstractPosteriorMeasure <: BATMeasure end\n\nAbstract type for posterior probability densities.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractTransformTarget","page":"API Documentation","title":"BAT.AbstractTransformTarget","text":"abstract type AbstractTransformTarget\n\nAbstract type for probability density transformation targets.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AdaptiveAffineTuning","page":"API Documentation","title":"BAT.AdaptiveAffineTuning","text":"struct AdaptiveAffineTuning <: MCMCTransformTuning\n\nAdaptive cycle-based MCMC tuning strategy.\n\nAdapts an affine space transformation based on the acceptance ratio and covariance of the previous samples.\n\nConstructors:\n\nAdaptiveAffineTuning(; fields...)\n\nFields:\n\nλ::Float64: Controls the weight given to new covariance information in adapting the     affine transform. Default: 0.5\nβ::Float64: Controls how much the scale of the affine transform is     widened/narrowed depending on the current MH acceptance ratio. Default: 1.5\nc::IntervalSets.ClosedInterval{Float64}: Interval for allowed scale of the affine transform distribution. Default: ClosedInterval(0.0001, 100.0)\nr::Real: Reweighting factor. Take accumulated sample statistics of previous     tuning cycles into account with a relative weight of r. Set to     0 to completely reset sample statistics between each tuning cycle. Default: 0.5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AdaptiveMultiPropTuning","page":"API Documentation","title":"BAT.AdaptiveMultiPropTuning","text":"struct AdaptiveMultiPropTuning <: MCMCProposalTuning\n\nTuning Algorithm for multiple MCMC Proposals. Works by adjusting the picking rule for the proposals to match the individual desired target acceptance rates based on the respective observed acceptance rates.\n\nConstructors:\n\nAdaptiveMultiPropTuning(; fields...)\n\nFields:\n\nalpha::Float64: Default: 0.1\nbeta::Float64: Default: 0.5\npicking_socket::Float64: Default: 0.8\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AssumeConvergence","page":"API Documentation","title":"BAT.AssumeConvergence","text":"struct AssumeConvergence <: ConvergenceTest\n\nNo-op convergence algorithm for bat_convergence, will always declare convergence.\n\nConstructors:\n\nAssumeConvergence(converged::Bool = true)\n\nFields:\n\nconverged::Bool: Default: true\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AutocorLenAlgorithm","page":"API Documentation","title":"BAT.AutocorLenAlgorithm","text":"abstract type AutocorLenAlgorithm\n\nAbstract type for integrated autocorrelation length estimation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.BATContext","page":"API Documentation","title":"BAT.BATContext","text":"struct BATContext{T}\n\nExperimental feature, not yet part of stable public API.\n\nSet the default computational context for BAT.\n\nConstructors:\n\nBATContext{T}(rng::AbstractRNG, cunit::AbstractComputeUnit, ADSelector::AD)\n\nBATContext(;\n    precision::Type{<:AbstractFloat} = ...,\n    rng::AbstractRNG = ...,\n    cunit::HeterogeneousComputing.AbstractComputeUnit = ...,\n    ad::Union{AutoDiffOperators.ADSelector, Module, Symbol, Val} = ...,\n)\n\nSee get_batcontext and set_batcontext.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.BATHDF5IO","page":"API Documentation","title":"BAT.BATHDF5IO","text":"struct BATHDF5IO <: BATIOAlgorithm\n\nSelects the BAT HDF5 format as the output format.\n\nSee bat_write and bat_read.\n\nConstructors:\n\nBATHDF5IO()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.BATIOAlgorithm","page":"API Documentation","title":"BAT.BATIOAlgorithm","text":"abstract type BATIOAlgorithm\n\nAbstract type for density transformation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.BinningAlgorithm","page":"API Documentation","title":"BAT.BinningAlgorithm","text":"abstract type BinningAlgorithm\n\nAbstract type for binning algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.BrooksGelmanConvergence","page":"API Documentation","title":"BAT.BrooksGelmanConvergence","text":"struct BrooksGelmanConvergence <: ConvergenceTest\n\nBrooks-Gelman maximum R^2 convergence test.\n\nConstructors:\n\nBrooksGelmanConvergence(; fields...)\n\nFields:\n\nthreshold::Float64: Default: 1.1\ncorrected::Bool: Default: false\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.CuhreIntegration","page":"API Documentation","title":"BAT.CuhreIntegration","text":"struct CuhreIntegration <: IntegrationAlgorithm\n\nCuhreIntegration integration algorithm.\n\nConstructors:\n\nCuhreIntegration(; fields...)\n\nFields:\n\npretransform::AbstractTransformTarget: Default: PriorToUniform()\nrtol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:RTOL))\natol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:ATOL))\nminevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MINEVALS))\nmaxevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXEVALS))\nkey::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:KEY))\nnthreads::Int64: Default: Base.Threads.nthreads()\nstrict::Bool: Default: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DensitySample","page":"API Documentation","title":"BAT.DensitySample","text":"struct DensitySample\n\nA weighted sample drawn according to an statistical density, e.g. a BAT.MeasureLike.\n\nConstructors:\n\nDensitySampleVector(v::Any, logd::Real, weight::Real, info::Any, aux::Any)\n\nFields:\n\nv::Any: variate value\nlogd::Real: log(density) value at v\nweight::Real: Weight of the sample\ninfo::Any: Additional info on the provenance of the sample. Content depends     on the sampling algorithm.\naux::Any: Custom user-defined information attached to the sample.\n\nUse DensitySampleVector to store vectors of multiple samples with an efficient column-based memory layout.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DensitySampleVector","page":"API Documentation","title":"BAT.DensitySampleVector","text":"struct DensitySampleVector <: AbstractVector{<:DensitySample}\n\nA vector of DensitySample elements.\n\nDensitySampleVector is currently a type alias for StructArrays.StructArray{<:DensitySample,...}, though this is subject to change without deprecation.\n\nConstructors:\n\n    DensitySampleVector(\n        (\n            v::AbstractVector{<:AbstractVector{<:Real}},\n            logd::AbstractVector{<:Real},\n            weight::AbstractVector{<:Real},\n            info::AbstractVector{<:Any},\n            aux::AbstractVector{<:Any}\n        )\n    )\n\n    DensitySampleVector(\n            v::AbstractVector,\n            logval::AbstractVector{<:Real};\n            weight::Union{AbstractVector{<:Real}, Symbol} = fill(1, length(eachindex(v))),\n            info::AbstractVector = fill(nothing, length(eachindex(v))),\n            aux::AbstractVector = fill(nothing, length(eachindex(v)))\n        )\n\nWith weight = :multiplicity repeated samples will be replaced by a single sample, with a weight equal to the number of repetitions.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DivonneIntegration","page":"API Documentation","title":"BAT.DivonneIntegration","text":"struct DivonneIntegration <: IntegrationAlgorithm\n\nDivonneIntegration integration algorithm.\n\nConstructors:\n\nDivonneIntegration(; fields...)\n\nFields:\n\npretransform::AbstractTransformTarget: Default: PriorToUniform()\nrtol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:RTOL))\natol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:ATOL))\nminevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MINEVALS))\nmaxevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXEVALS))\nkey1::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:KEY1))\nkey2::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:KEY2))\nkey3::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:KEY3))\nmaxpass::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXPASS))\nborder::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:BORDER))\nmaxchisq::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXCHISQ))\nmindeviation::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MINDEVIATION))\nngiven::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NGIVEN))\nldxgiven::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:LDXGIVEN))\nnextra::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NEXTRA))\nnthreads::Int64: Default: Base.Threads.nthreads()\nstrict::Bool: Default: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DoNotTransform","page":"API Documentation","title":"BAT.DoNotTransform","text":"struct DoNotTransform <: AbstractTransformTarget\n\nThe identity density transformation target, specifies that densities should not be transformed.\n\nConstructors:\n\nDoNotTransform()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.EffSampleSizeAlgorithm","page":"API Documentation","title":"BAT.EffSampleSizeAlgorithm","text":"abstract type EffSampleSizeAlgorithm\n\nAbstract type for integrated autocorrelation length estimation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.EffSampleSizeFromAC","page":"API Documentation","title":"BAT.EffSampleSizeFromAC","text":"struct EffSampleSizeFromAC <: EffSampleSizeAlgorithm\n\nEffective sample size estimation based on the integrated autocorrelation length of the samples.\n\nConstructors:\n\nEffSampleSizeFromAC(; fields...)\n\nFields:\n\nacalg::AutocorLenAlgorithm: Default: GeyerAutocorLen()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.EvaluatedMeasure","page":"API Documentation","title":"BAT.EvaluatedMeasure","text":"struct EvaluatedMeasure <: BATMeasure\n\nCombined a measure with samples, and other information on it.\n\nConstructors:\n\nem = EvaluatedMeasure(\n    measure;\n    samples = ..., approx = ..., mass = ..., mode = ...,\n    _generator = ...\n)\n\nBAT.unevaluated(em) === measure\n\nnote: Note\nField _generator does not form part of the stable public API and is subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ExplicitInit","page":"API Documentation","title":"BAT.ExplicitInit","text":"struct ExplicitInit <: InitvalAlgorithm\n\nUses initial values from a given vector of one or more values/variates. The values are used in the order they appear in the vector, not randomly.\n\nConstructors:\n\nExplicitInit(; fields...)\n\nFields:\n\nxs::AbstractVector\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.FixedMGVISchedule","page":"API Documentation","title":"BAT.FixedMGVISchedule","text":"abstract type FixedMGVISchedule <: BAT.MGVISchedule\n\nAbstract supertype for MGVI sampling schedules.\n\nConstructors:\n\nFixedMGVISchedule(; fields...)\n\nFields:\n\nnsamples::AbstractVector{<:Real}: Default: range(12, 1000, length = 10)\n\nConstructors:\n\nFixedMGVISchedule(nsamples::AbstractVector{<:Real}): The number of samples to draw at each MGVI step. The length of nsamples implies the total number of steps. The number of samples will be rounded to integer values if necessary, to allow for constructions like FixedMGVISchedule(range(12, 1000, length = 10)).\n\nFields:\n\nnsamples::AbstractVector{<:Real}: See constructor above.\n\nSee MGVISampling.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.FixedNBins","page":"API Documentation","title":"BAT.FixedNBins","text":"FixedNBins(nbins::Int)\n\nSelects a fixed number of bins.\n\nConstructor: FixedNBins(; fields...)\n\nFields:\n\nnbins::Int64: Default: 200\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.FreedmanDiaconisBinning","page":"API Documentation","title":"BAT.FreedmanDiaconisBinning","text":"struct FreedmanDiaconisBinning <: BinningAlgorithm\n\nSelects automatic binning based on the Freedman–Diaconis rule.\n\nConstructor: FreedmanDiaconisBinning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.GelmanRubinConvergence","page":"API Documentation","title":"BAT.GelmanRubinConvergence","text":"struct GelmanRubinConvergence <: ConvergenceTest\n\nGelman-Rubin maximum R^2 convergence test.\n\nConstructors:\n\nGelmanRubinConvergence(; fields...)\n\nFields:\n\nthreshold::Float64: Default: 1.1\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.GeyerAutocorLen","page":"API Documentation","title":"BAT.GeyerAutocorLen","text":"struct GeyerAutocorLen <: AutocorLenAlgorithm\n\nIntegrated autocorrelation length estimation based on Geyer’s initial monotone sequence criterion\n\nSee C. J. Geyer, \"Practical Markov Chain Monte Carlo\" (1992) and C. J. Geyer, \"Introduction to Markov Chain Monte Carlo\" (2011).\n\nConstructors:\n\nGeyerAutocorLen()\n\nThe same algorithm is used by STAN (v2.21) and MCMCChains.jl (v3.0, function ess_rhat).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.HamiltonianMC","page":"API Documentation","title":"BAT.HamiltonianMC","text":"struct HamiltonianMC <: MCMCAlgorithm\n\nThe Hamiltonian Monte Carlo (HMC) sampling algorithm.\n\nUses the HMC implementation provided by the package AdvancedHMC.\n\nHMC uses gradients of the target measure's density, so your BATContext needs to include an ADSelector to specify which automatic differentiation backend should be used.\n\nNote: The fields of HamiltonianMC are still subject to change, and not\n\nyet part of stable public BAT API!*\n\nConstructors:\n\nHamiltonianMC(; fields...)\n\nFields:\n\ntarget_acceptance::Real: Default: 0.8\ntarget_acceptance_int::Tuple{Vararg{Real}}: Default: (0.9target_acceptance, one(Float64))\nmetric::BAT.HMCMetric: Default: UnitEuclideanMetric()\nintegrator::Any: Default: extdefault(pkgext(Val(:AdvancedHMC)), Val(:DEFAULTINTEGRATOR))\ntermination::Any: Default: extdefault(pkgext(Val(:AdvancedHMC)), Val(:DEFAULTTERMINATION_CRITERION))\n\nnote: Note\nHamiltonianMC is only available if the AdvancedHMC package is loaded (e.g. via import AdvancedHMC). \n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.IdentityTransformAlgorithm","page":"API Documentation","title":"BAT.IdentityTransformAlgorithm","text":"struct IdentityTransformAlgorithm <: TransformAlgorithm\n\nA no-op density transform algorithm that leaves any density unchanged.\n\nConstructors:\n\nIdentityTransformAlgorithm()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCGlobalProposal","page":"API Documentation","title":"BAT.MCMCGlobalProposal","text":"struct MCMCGlobalProposal <: MCMCProposal\n\nMCMC proposal algorithm for drawing samples from a global proposal distribution - independent from the current position of the MCMC walker.\n\nIf no distribution is passed by the user, the target is checked for the  best known approximation for the posterior, e.g. the prior.\n\nConstructors:\n\nMCMCGlobalProposal(; fields...)\n\nFields:\n\ntarget_acceptance::Real: Default: 1.0\ntarget_acceptance_int::Tuple{Vararg{Real}}: Default: (0.01, 1.0)\nglobal_proposal::Union{Nothing, MeasureBase.AbstractMeasure, Distributions.ContinuousDistribution{<:Union{Distributions.Univariate, Distributions.Multivariate}}}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.IIDSampling","page":"API Documentation","title":"BAT.IIDSampling","text":"struct IIDSampling <: AbstractSamplingAlgorithm\n\nSample via Random.rand.\n\nConstructors:\n\nIIDSampling(; fields...)\n\nFields:\n\nnsamples::Int64: Default: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitFromIID","page":"API Documentation","title":"BAT.InitFromIID","text":"struct InitFromIID <: InitvalAlgorithm\n\nGenerates initial values for sampling, optimization, etc. by random resampling from a given set of samples.\n\nConstructors:\n\nInitFromIID()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitFromSamples","page":"API Documentation","title":"BAT.InitFromSamples","text":"struct InitFromSamples <: InitvalAlgorithm\n\nGenerates initial values for sampling, optimization, etc. by direct sampling from a given i.i.d. sampleable source.\n\nConstructors:\n\nInitFromSamples()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitFromTarget","page":"API Documentation","title":"BAT.InitFromTarget","text":"struct InitFromTarget <: InitvalAlgorithm\n\nGenerates initial values for sampling, optimization, etc. by direct i.i.d. sampling a suitable component of that target density (e.g. it's prior) that supports it.\n\nIf the target supports direct i.i.d. sampling, e.g. because it is a distribution, initial values are sampled directly from the target.\nIf the target is a posterior density, initial values are sampled from the prior (or the prior's prior if the prior is a posterior itself, etc.).\nIf the target is a sampled density, initial values are (re-)sampled from the available samples.\n\nConstructors:\n\nInitFromTarget()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitvalAlgorithm","page":"API Documentation","title":"BAT.InitvalAlgorithm","text":"abstract type BAT.InitvalAlgorithm\n\nAbstract type for BAT initial/starting value generation algorithms.\n\nMany algorithms in BAT, like MCMC and optimization, need initial/starting values.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.IntegrationAlgorithm","page":"API Documentation","title":"BAT.IntegrationAlgorithm","text":"abstract type IntegrationAlgorithm\n\nAbstract type for integration algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.KishESS","page":"API Documentation","title":"BAT.KishESS","text":"struct KishESS <: EffSampleSizeAlgorithm\n\nKish's effective sample size estimator, uses only the sample weights.\n\nConstructors:\n\nKishESS()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MALAProposal","page":"API Documentation","title":"BAT.MALAProposal","text":"struct MALAProposal <: MCMCProposal\n\nMetropolis adjusted Langevin sampling algorithm.\n\nConstructors:\n\nMALAProposal(; fields...)\n\nFields:\n\ntarget_acceptance::Real: Default: 0.574\ntarget_acceptance_int::Tuple{Vararg{Real}}: Default: (0.5, 0.65)\nproposaldist::Union{MeasureBase.AbstractMeasure, Distributions.ContinuousDistribution{<:Union{Distributions.Univariate, Distributions.Multivariate}}}: Default: TDist(1.0)\nτ_base::Real: Default: 1.65 ^ 2\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MaxDensitySearch","page":"API Documentation","title":"BAT.MaxDensitySearch","text":"MaxDensitySearch <: AbstractModeEstimator\n\nConstructors:\n\nMaxDensitySearch()\n\nEstimate the mode as the variate with the highest posterior density value within a given set of samples.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCAlgorithm","page":"API Documentation","title":"BAT.MCMCAlgorithm","text":"abstract type MCMCAlgorithm\n\nAbstract type for Markov chain Monte Carlo algorithms.\n\nTo implement a new MCMC algorithm, subtypes of both MCMCAlgorithm and MCMCChainState are required.\n\nnote: Note\nThe details of the MCMCIterator and MCMCAlgorithm API required to implement a new MCMC algorithm currently do not (yet) form part of the stable API and are subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCBurninAlgorithm","page":"API Documentation","title":"BAT.MCMCBurninAlgorithm","text":"abstract type MCMCBurninAlgorithm\n\nAbstract type for MCMC burn-in algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCChainPoolInit","page":"API Documentation","title":"BAT.MCMCChainPoolInit","text":"struct MCMCChainPoolInit <: MCMCInitAlgorithm\n\nMCMC chain pool initialization strategy.\n\nConstructors:\n\nMCMCChainPoolInit(; fields...)\n\nFields:\n\ninit_tries_per_chain::IntervalSets.ClosedInterval{Int64}: Default: ClosedInterval(8, 128)\nnsteps_init::Int64: Default: 1000\ninitval_alg::InitvalAlgorithm: Default: InitFromTarget()\nstrict::Bool: Default: true\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCRetryInit","page":"API Documentation","title":"BAT.MCMCRetryInit","text":"struct MCMCRetryInit <: MCMCInitAlgorithm\n\nTODO\n\nConstructors:\n\nMCMCRetryInit(; fields...)\n\nFields:\n\nmax_init_tries::Int64: Default: 20\nnsteps_init::Int64: Default: 250\ninitval_alg::InitvalAlgorithm: Default: InitFromTarget()\nstrict::Bool: Default: true\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCInitAlgorithm","page":"API Documentation","title":"BAT.MCMCInitAlgorithm","text":"abstract type MCMCInitAlgorithm\n\nAbstract type for MCMC initialization algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCMultiCycleBurnin","page":"API Documentation","title":"BAT.MCMCMultiCycleBurnin","text":"struct MCMCMultiCycleBurnin <: MCMCBurninAlgorithm\n\nA multi-cycle MCMC burn-in algorithm.\n\nConstructors:\n\nMCMCMultiCycleBurnin(; fields...)\n\nFields:\n\nnsteps_per_cycle::Int64: Default: 10000\nmax_ncycles::Int64: Default: 30\nnsteps_final::Int64: Default: div(nstepspercycle, 10)\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCMultiProposal","page":"API Documentation","title":"BAT.MCMCMultiProposal","text":"struct MCMCMultiProposal<: MCMCProposal\n\nMCMC sampling algorithm that allows for using multiple different proposal algorithms during sampling.\n\nConstructors:\n\nMCMCMultiProposal(; fields...)\n\nFields:\n\nproposals::Vector{<:BAT.MCMCProposal}: Default: (RandomWalk(), HamiltonianMC())\npicking_rule::Union{Vector{<:Integer}, Distributions.Categorical{P} where P<:Real}: Default: Categorical((1 / length(proposals)) .* ones(length(proposals)))\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCProposalTuning","page":"API Documentation","title":"BAT.MCMCProposalTuning","text":"abstract type MCMCProposalTuning\n\nAbstract type for MCMC tuning algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCTransformTuning","page":"API Documentation","title":"BAT.MCMCTransformTuning","text":"abstract type MCMCTransformTuning\n\nAbstract type for MCMC tuning algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MGVISampling","page":"API Documentation","title":"BAT.MGVISampling","text":"struct MGVISampling <: AbstractUltraNestAlgorithmReactiv\n\nSamples via Metric Gaussian Variational Inference, using the MGVI.jl Julia implementation of the algorithm.\n\nConstructors:\n\nMGVISampling(; fields...)\n\nFields:\n\npretransform::AbstractTransformTarget: Pre-transformation to apply to the target measure before sampling.\nnsamples::Int: Number is independent samples to draw. MGVI will generate symmetical samples, so it will generate 2*nsamplessamples in total, but onlynsamples` independent samples.\nschedule::MGVISchedule: MGVI schedule, by default a FixedMGVISchedule.\nconfig::MGVI.MGVIConfig: MGVI configuration.\n\nnote: Note\nThis functionality is only available when the package MGVI is loaded (e.g. via import MGVI).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ModeAsDefined","page":"API Documentation","title":"BAT.ModeAsDefined","text":"struct ModeAsDefined <: AbstractModeEstimator\n\nGet the mode as defined by the density, resp. the underlying distribution (if available), via StatsBase.mode.\n\nConstructors:\n\nModeAsDefined()        \n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MultiProposalTuning","page":"API Documentation","title":"BAT.MultiProposalTuning","text":"struct MultiProposalTuning <: MCMCProposalTuning\n\nTuning algorithm for MCMCMultiProposals.\n\nConstructors:\n\nMultiProposalTuning(; fields...)\n\nFields:\n\nproposal_tunings::Vector{<:MCMCProposalTuning}\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MultiTrafoTuning","page":"API Documentation","title":"BAT.MultiTrafoTuning","text":"struct MultiTrafoTuning <: MCMCTransformTuning\n\nTuning algorithm for chains of adaptive transformations.\n\nConstructors:\n\nMultiTrafoTuning(; fields...)\n\nFields:\n\ntrafo_tunings::Tuple{Vararg{MCMCTransformTuning}}\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.NoMCMCProposalTuning","page":"API Documentation","title":"BAT.NoMCMCProposalTuning","text":"NoMCMCProposalTuning <: MCMCProposalTuning\n\nDo not perform any MCMC proposal tuning.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.NoMCMCTransformTuning","page":"API Documentation","title":"BAT.NoMCMCTransformTuning","text":"NoMCMCTransformTuning <: MCMCTransformTuning\n\nDo not perform any MCMC transform tuning.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.OptimAlg","page":"API Documentation","title":"BAT.OptimAlg","text":"OptimAlg\n\nSelects an optimization algorithm from the Optim.jl package.\n\nNote that when using first order algorithms like Optim.LBFGS, your BATContext needs to include an ADSelector that specifies which automatic differentiation backend should be used.\n\nConstructors:\n\nOptimAlg(; fields...)\n\noptimalg must be an Optim.AbstractOptimizer.\n\nFields:\n\noptalg::Any: Default: extdefault(pkgext(Val(:Optim)), Val(:DEFAULTOPTALG))\npretransform::AbstractTransformTarget: Default: PriorToNormal()\ninit::InitvalAlgorithm: Default: InitFromTarget()\nmaxiters::Int64: Default: 1000\nmaxtime::Float64: Default: NaN\nabstol::Float64: Default: NaN\nreltol::Float64: Default: 0.0\nkwargs::NamedTuple: Default: (;)\n\nnote: Note\nThis algorithm is only available if the Optim package is loaded (e.g. via     import Optim.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.OptimizationAlg","page":"API Documentation","title":"BAT.OptimizationAlg","text":"struct OptimizationAlg\n\nSelects an optimization algorithm from the OptimizationBase.jl package. Note that when using first order algorithms like OptimizationOptimJL.LBFGS, your BATContext needs to have ad set to an automatic differentiation backend.\n\nConstructors:\n\nOptimizationAlg(; fields...)\n\noptalg must be an OptimizationBase.AbstractOptimizer. The field kwargs can be used to pass additional keywords to the optimizers See the OptimizationBase.jl documentation for the available keyword arguments. Fields:\n\noptalg::Any: Default: extdefault(pkgext(Val(:OptimizationBase)), Val(:DEFAULTOPTALG))\npretransform::AbstractTransformTarget: Default: PriorToNormal()\ninit::InitvalAlgorithm: Default: InitFromTarget()\nmaxiters::Int64: Default: 1000\nmaxtime::Float64: Default: NaN\nabstol::Float64: Default: NaN\nreltol::Float64: Default: 0.0\nkwargs::NamedTuple: Default: (;)\n\nnote: Note\nThis algorithm is only available if the OptimizationBase package or any of its submodules, like OptimizationOptimJL, is loaded (e.g. via     import OptimizationOptimJL).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.OrderedResampling","page":"API Documentation","title":"BAT.OrderedResampling","text":"struct OrderedResampling <: AbstractSamplingAlgorithm\n\nEfficiently resamples from a given series of samples, keeping the order of samples.\n\nCan be used to efficiently convert weighted samples into samples with unity weights.\n\nConstructors:\n\nOrderedResampling(; fields...)\n\nFields:\n\nnsamples::Int64: Default: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PosteriorMeasure","page":"API Documentation","title":"BAT.PosteriorMeasure","text":"struct PosteriorMeasure{Li,Pr<:AbstractMeasure} <: AbstractPosteriorMeasure\n\nA representation of a PosteriorMeasure, based a likelihood and prior. Likelihood and prior be accessed via\n\ngetlikelihood(posterior::PosteriorMeasure)::Li\ngetprior(posterior::PosteriorMeasure)::Pr\n\nConstructors:\n\nPosteriorMeasure(likelihood, prior)\nPosteriorMeasure{T<:Real}(likelihood, prior)\n\nFields:\n\nlikelihood::Any\nprior::MeasureBase.AbstractMeasure\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PriorSubstitution","page":"API Documentation","title":"BAT.PriorSubstitution","text":"struct PriorSubstitution <: TransformAlgorithm\n\nSubstitute the prior by a given distribution and transform the likelihood accordingly. The log(abs(jacobian)) of the transformation does not need to be auto-differentiable even for operations that use the gradient of the posterior.\n\nConstructors:\n\nPriorSubstitution()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PriorToNormal","page":"API Documentation","title":"BAT.PriorToNormal","text":"struct PriorToNormal <: AbstractTransformTarget\n\nSpecifies that posterior densities should be transformed in a way that makes their pior equivalent to a standard multivariate normal distribution with an identity covariance matrix.\n\nConstructors:\n\nPriorToNormal()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PriorToUniform","page":"API Documentation","title":"BAT.PriorToUniform","text":"struct PriorToUniform <: AbstractTransformTarget\n\nSpecifies that posterior densities should be transformed in a way that makes their pior equivalent to a uniform distribution over the unit hypercube.\n\nConstructors:\n\nPriorToUniform()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RAMTuning","page":"API Documentation","title":"BAT.RAMTuning","text":"struct RAMTuning <: MCMCTransformTuning\n\nTunes MCMC spaces transformations based on the Robust adaptive Metropolis algorithm.\n\nIn constrast to the original RAM algorithm, RAMTuning does not use the covariance estimate to change a proposal distribution, but instead uses it as the bases for an affine transformation. The sampling process is mathematically equivalent, though.\n\nConstructors:\n\nRAMTuning(; fields...)\n\nFields:\n\ngamma::Float64: Negative adaption rate exponent. Default: 2 / 3\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RandomWalk","page":"API Documentation","title":"BAT.RandomWalk","text":"struct RandomWalk <: MCMCProposal\n\nMetropolis-Hastings MCMC sampling algorithm.\n\nConstructors:\n\nRandomWalk(; fields...)\n\nFields:\n\ntarget_acceptance::Real: Default: 0.234\ntarget_acceptance_int::Tuple{Vararg{Real}}: Default: (0.15, 0.35)\nproposaldist::Union{MeasureBase.AbstractMeasure, Distributions.ContinuousDistribution{<:Union{Distributions.Univariate, Distributions.Multivariate}}}: Default: TDist(1.0)\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RandResampling","page":"API Documentation","title":"BAT.RandResampling","text":"struct RandResampling <: AbstractSamplingAlgorithm\n\nResamples from a given set of samples.\n\nConstructors:\n\nRandResampling(; fields...)\n\nFields:\n\nnsamples::Int64: Default: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RepetitionWeighting","page":"API Documentation","title":"BAT.RepetitionWeighting","text":"struct RepetitionWeighting{T<:AbstractFloat} <: AbstractMCMCWeightingScheme{T}\n\nSample weighting scheme suitable for sampling algorithms which may repeated samples multiple times in direct succession (e.g. RandomWalk). The repeated sample is stored only once, with a weight equal to the number of times it has been repeated (e.g. because a Markov chain has not moved during a sampling step).\n\nConstructors:\n\nRepetitionWeighting()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RiceBinning","page":"API Documentation","title":"BAT.RiceBinning","text":"struct RiceBinning <: BinningAlgorithm\n\nSelects automatic binning based on the Rice rule.\n\nConstructor: RiceBinning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SampleMedianEstimator","page":"API Documentation","title":"BAT.SampleMedianEstimator","text":"struct SampleMedianEstimator <: AbstractMedianEstimator\n\nGet median values from samples using standard Julia statistics functions.\n\nConstructors:\n\nSampleMedianEstimator()        \n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ScottBinning","page":"API Documentation","title":"BAT.ScottBinning","text":"struct ScottBinning <: BinningAlgorithm\n\nSelects automatic binning based on Scott's normal reference rule.\n\nConstructor: ScottBinning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SokalAutocorLen","page":"API Documentation","title":"BAT.SokalAutocorLen","text":"struct SokalAutocorLen <: AutocorLenAlgorithm\n\nIntegrated autocorrelation length estimation based on the automated windowing procedure descibed in A. D. Sokal, \"Monte Carlo Methods in Statistical Mechanics\" (1996)\n\nSame procedure is used by the emcee Python package (v3.0).\n\nConstructors:\n\nSokalAutocorLen(; fields...)\n\nFields:\n\nc::Int64: Step size for window search Default: 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SquareRootBinning","page":"API Documentation","title":"BAT.SquareRootBinning","text":"struct SquareRootBinning <: BinningAlgorithm\n\nSelects automatic binning based on the Square-root choice.\n\nConstructor: SquareRootBinning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SturgesBinning","page":"API Documentation","title":"BAT.SturgesBinning","text":"struct SturgesBinning <: BinningAlgorithm\n\nSelects automatic binning based on Sturges' formula.\n\nConstructor: SturgesBinning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SuaveIntegration","page":"API Documentation","title":"BAT.SuaveIntegration","text":"struct SuaveIntegration <: IntegrationAlgorithm\n\nSuaveIntegration integration algorithm.\n\nConstructors:\n\nSuaveIntegration(; fields...)\n\nFields:\n\npretransform::AbstractTransformTarget: Default: PriorToUniform()\nrtol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:RTOL))\natol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:ATOL))\nminevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MINEVALS))\nmaxevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXEVALS))\nnnew::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NNEW))\nnmin::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NMIN))\nflatness::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:FLATNESS))\nnthreads::Int64: Default: Base.Threads.nthreads()\nstrict::Bool: Default: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ToRealVector","page":"API Documentation","title":"BAT.ToRealVector","text":"struct ToRealVector <: AbstractTransformTarget\n\nSpecifies that the input should be transformed into a measure over the space of real-valued flat vectors.\n\nConstructors:\n\nToRealVector()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.TransformAlgorithm","page":"API Documentation","title":"BAT.TransformAlgorithm","text":"abstract type TransformAlgorithm\n\nAbstract type for density transformation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.TransformedMCMC","page":"API Documentation","title":"BAT.TransformedMCMC","text":"struct TransformedMCMC <: AbstractSamplingAlgorithm\n\nSamples a probability density using Markov chain Monte Carlo.\n\nConstructors:\n\nTransformedMCMC(; fields...)\n\nFields:\n\nproposal::BAT.MCMCProposal: Default: RandomWalk(proposaldist = TDist(1.0))\nproposal_tuning::MCMCProposalTuning: Default: batdefault(TransformedMCMC, Val(:proposaltuning), proposal)\npretransform::AbstractTransformTarget: Default: bat_default(TransformedMCMC, Val(:pretransform), proposal)\nadaptive_transform::BAT.AbstractAdaptiveTransform: Default: batdefault(TransformedMCMC, Val(:adaptivetransform), proposal)\ntransform_tuning::MCMCTransformTuning: Default: batdefault(TransformedMCMC, Val(:transformtuning), adaptive_transform)\ntempering::MCMCTempering: Default: bat_default(TransformedMCMC, Val(:tempering), proposal)\nnchains::Int64: Default: 4\nnwalkers::Int64: Default: batdefault(TransformedMCMC, Val(:nwalkers), proposal, pretransform, transformtuning, nchains)\nnsteps::Int64: Default: batdefault(TransformedMCMC, Val(:nsteps), proposal, pretransform, transformtuning, nchains, nwalkers)\ninit::MCMCInitAlgorithm: Default: batdefault(TransformedMCMC, Val(:init), proposal, pretransform, transformtuning, nchains, nwalkers, nsteps)\nburnin::MCMCBurninAlgorithm: Default: batdefault(TransformedMCMC, Val(:burnin), proposal, pretransform, transformtuning, nchains, nwalkers, nsteps)\nconvergence::BAT.ConvergenceTest: Default: BrooksGelmanConvergence()\nstrict::Bool: Default: true\nstore_burnin::Bool: Default: false\nnonzero_weights::Bool: Default: true\nsample_weighting::AbstractMCMCWeightingScheme: Default: RepetitionWeighting()\ncallback::Function: Default: nop_func\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.VEGASIntegration","page":"API Documentation","title":"BAT.VEGASIntegration","text":"struct VEGASIntegration <: IntegrationAlgorithm\n\nVEGASIntegration integration algorithm.\n\nConstructors:\n\nVEGASIntegration(; fields...)\n\nFields:\n\npretransform::AbstractTransformTarget: Default: PriorToUniform()\nrtol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:RTOL))\natol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:ATOL))\nminevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MINEVALS))\nmaxevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXEVALS))\nnstart::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NSTART))\nnincrease::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NINCREASE))\nnbatch::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NBATCH))\nnthreads::Int64: Default: Base.Threads.nthreads()\nstrict::Bool: Default: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.unevaluated","page":"API Documentation","title":"BAT.unevaluated","text":"BAT.unevaluated(obj)\n\nIf obj is an evaluated object, like a EvaluatedMeasure, return the original (unevaluated) object. Otherwise, return obj.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.AbstractMedianEstimator","page":"API Documentation","title":"BAT.AbstractMedianEstimator","text":"abstract type BAT.AbstractMedianEstimator\n\nAbstract type for BAT optimization algorithms.\n\nA typical application for optimization in BAT is mode estimation (see bat_findmode),\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractModeEstimator","page":"API Documentation","title":"BAT.AbstractModeEstimator","text":"abstract type BAT.AbstractModeEstimator\n\nAbstract type for BAT optimization algorithms.\n\nA typical application for optimization in BAT is mode estimation (see bat_findmode),\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractSamplingAlgorithm","page":"API Documentation","title":"BAT.AbstractSamplingAlgorithm","text":"abstract type BAT.AbstractSamplingAlgorithm\n\nAbstract type for BAT sampling algorithms. See bat_sample.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ConvergenceTest","page":"API Documentation","title":"BAT.ConvergenceTest","text":"abstract type ConvergenceTest\n\nAbstract type for integrated autocorrelation length estimation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MGVISchedule","page":"API Documentation","title":"BAT.MGVISchedule","text":"abstract type BAT.MGVISchedule\n\nAbstract supertype for MGVI sampling schedules.\n\nSee MGVISampling.\n\n\n\n\n\n","category":"type"},{"location":"faq/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"... to be written ...","category":"section"},{"location":"developing/#Developer-Instructions","page":"Developer instructions","title":"Developer Instructions","text":"","category":"section"},{"location":"developing/#Documentation-Generation","page":"Developer instructions","title":"Documentation Generation","text":"To generate and view a local version of the documentation, run\n\ncd docs\njulia make.jl\n\nthen open \"docs/build/index.html\" in your browser.","category":"section"},{"location":"developing/#Code-Reloading","page":"Developer instructions","title":"Code Reloading","text":"When changing the code of BAT.jl and testing snippets and examples in the REPL, automatic code reloading comes in very handy. Try out Revise.jl.","category":"section"},{"location":"internal_api/#Internal-API","page":"Internal API","title":"Internal API","text":"note: Note\nThis is the documentation of BAT's internal API. The internal API is fully accessible to users, but all aspects of it are subject to change without deprecation. Functionalities of the internal API that, over time, turn out to require user access (e.g. to support advanced use cases) will be evolved to gain a stable interface and then promoted to the public API.","category":"section"},{"location":"internal_api/#Types","page":"Internal API","title":"Types","text":"Pages = [\"internal_api.md\"]\nOrder = [:type]","category":"section"},{"location":"internal_api/#Functions-and-macros","page":"Internal API","title":"Functions and macros","text":"Pages = [\"internal_api.md\"]\nOrder = [:macro, :function]","category":"section"},{"location":"internal_api/#Documentation","page":"Internal API","title":"Documentation","text":"","category":"section"},{"location":"internal_api/#BAT.AbstractSampleGenerator","page":"Internal API","title":"BAT.AbstractSampleGenerator","text":"abstract type AbstractSampleGenerator\n\nBAT-internal, not part of stable public API.\n\nAbstract super type for sample generators.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.AnySampleable","page":"Internal API","title":"BAT.AnySampleable","text":"BAT.AnySampleable = Union{...}\n\nUnion of all types that BAT can sample from:\n\nBAT.MeasureLike\nBAT.DensitySampleVector\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BasicMvStatistics","page":"Internal API","title":"BAT.BasicMvStatistics","text":"BasicMvStatistics{T<:Real,W}\n\nBAT-internal, not part of stable public API.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BATMeasure","page":"Internal API","title":"BAT.BATMeasure","text":"abstract type BATMeasure <:AbstractMeasure\n\nBAT-internal, not part of stable public API.\n\nSubtypes must implement DensityInterface.logdensityof and ValueShapes.varshape.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BATPushFwdMeasure","page":"Internal API","title":"BAT.BATPushFwdMeasure","text":"BATPushFwdMeasure\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BATPwrMeasure","page":"Internal API","title":"BAT.BATPwrMeasure","text":"BATPwrMeasure\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BATWeightedMeasure","page":"Internal API","title":"BAT.BATWeightedMeasure","text":"struct BATWeightedMeasure <: BATMeasure\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.CholeskyPartialWhitening","page":"Internal API","title":"BAT.CholeskyPartialWhitening","text":"struct CholeskyPartialWhitening <: WhiteningAlgorithm\n\nBAT-internal, not part of stable public API.\n\nWhitening transformation based on a Cholesky transformation of the empirical sample covariance matrix.\n\nOnly transforms dimensions (degrees of freedom) for which the marginalized distribution asymptotically approaches zero in the positive and negative direction.\n\nConstructors:\n\nCholeskyPartialWhitening()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.CholeskyWhitening","page":"Internal API","title":"BAT.CholeskyWhitening","text":"struct CholeskyWhitening <: WhiteningAlgorithm\n\nBAT-internal, not part of stable public API.\n\nWhitening transformation based on a Cholesky transformation of the empirical sample covariance matrix.\n\nConstructors:\n\nCholeskyWhitening()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.DensitySampleMeasure","page":"Internal API","title":"BAT.DensitySampleMeasure","text":"DensitySampleMeasure\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSAutoProposal","page":"Internal API","title":"BAT.ENSAutoProposal","text":"struct BAT.ENSAutoProposal <: ENSProposal\n\nExperimental feature, not part of stable public API.\n\nChoose the proposal depending from the number of dimensions:      ndims < 10: Proposals.Uniform,       10 ≤ ndims ≤ 20: Proposals.RWalk,       ndims > 20: Proposals.Slice\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSBound","page":"Internal API","title":"BAT.ENSBound","text":"abstract type ENSBound\n\nExperimental feature, not part of stable public API.\n\nAbstract type for the bounds of the sampling region used by EllipsoidalNestedSampling.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSEllipsoidBound","page":"Internal API","title":"BAT.ENSEllipsoidBound","text":"struct BAT.ENSEllipsoidBound <: ENSBound\n\nExperimental feature, not part of stable public API.\n\nEllipsoid bound means that a n-dimensional ellipsoid limits the sampling volume.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSMultiEllipsoidBound","page":"Internal API","title":"BAT.ENSMultiEllipsoidBound","text":"struct BAT.ENSMultiEllipsoidBound <: ENSBound\n\nExperimental feature, not part of stable public API.\n\nMulti ellipsoid bound means that there are multiple elliposid in an optimal clustering are used to limit the sampling volume.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSNoBounds","page":"Internal API","title":"BAT.ENSNoBounds","text":"struct BAT.ENSNoBounds <: ENSBound\n\nExperimental feature, not part of stable public API.\n\nNo bounds means that the whole volume from the unit Cube is used to find new points.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSProposal","page":"Internal API","title":"BAT.ENSProposal","text":"abstract type ENSProposal\n\nExperimental feature, not part of stable public API.\n\nAbstract type for the algorithms to propose new live points used used by EllipsoidalNestedSampling.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSRandomWalk","page":"Internal API","title":"BAT.ENSRandomWalk","text":"struct BAT.ENSRandomWalk <: ENSProposal\n\nExperimental feature, not part of stable public API.\n\nNew live point is proposed by using a random walk away from an existing live point.\n\nConstructors:\n\nENSRandomWalk(; fields...)\n\nFields:\n\nratio::Float64: Acceptance ratio for the random walk. Default: 0.5\nwalks::Int64: Minimum number of random walk steps. Default: 25\nscale::Float64: Scale of the proposal distribution. Default: 1.0\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSSlice","page":"Internal API","title":"BAT.ENSSlice","text":"struct BAT.ENSSlice <: ENSProposal\n\nExperimental feature, not part of stable public API.\n\nNew live point is proposed by a serie of random slices from an existing live-point.\n\nConstructors:\n\nENSSlice(; fields...)\n\nFields:\n\nslices::Int64: Minimum number of slices Default: 5\nscale::Float64: Scale of the proposal distribution. Default: 1.0\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSUniformly","page":"Internal API","title":"BAT.ENSUniformly","text":"struct BAT.ENSUniformly <: ENSProposal\n\nExperimental feature, not part of stable public API.\n\nEach point in the bounding volume has an uniform chance to be proposed as a new live point.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.FullMeasureTransform","page":"Internal API","title":"BAT.FullMeasureTransform","text":"struct FullMeasureTransform <: TransformAlgorithm\n\nBAT-internal, not part of stable public API.\n\nTransform the density as a whole a given specified target space. Operations that use the gradient of the density will require to the log(abs(jacobian)) of the transformation to be auto-differentiable.\n\nConstructors:\n\nFullMeasureTransform()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.LFDensity","page":"Internal API","title":"BAT.LFDensity","text":"struct BAT.LFDensity{F}\n\nBAT-internal, not part of stable public API.\n\nWraps a log-density function log_f.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.LFDensityWithGrad","page":"Internal API","title":"BAT.LFDensityWithGrad","text":"BAT.LFDensityWithGrad{F,G} <: BATDensity\n\nBAT-internal, not part of stable public API.\n\nConstructors:\n\nLFDensityWithGrad(logf, valgradlogf)\n\nA density defined by a function that computes it's logarithmic value at given points, as well as a function that computes both the value and the gradient.\n\nIt must be safe to execute both functions in parallel on multiple threads and processes.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.LogDVal","page":"Internal API","title":"BAT.LogDVal","text":"struct LogDVal{T<:Real}\n\nLogDVal is deprecated and will be removed in future major or even minor BAT versions.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.MCMCSampleGenerator","page":"Internal API","title":"BAT.MCMCSampleGenerator","text":"BAT.MCMCSampleGenerator\n\nBAT-internal, not part of stable public API.\n\nMCMC sample generator.\n\nConstructors:\n\nMCMCSampleGenerator(mc_state::AbstractVector{<:MCMCIterator})\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.MeasureLike","page":"Internal API","title":"BAT.MeasureLike","text":"BAT.MeasureLike = Union{...}\n\nBAT-internal, not part of stable public API.\n\nUnion of all types that BAT will accept as a measures or convert to measures.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.NoWhitening","page":"Internal API","title":"BAT.NoWhitening","text":"struct NoWhitening <: WhiteningAlgorithm\n\nBAT-internal, not part of stable public API.\n\nNo-op whitening transformation, leaves samples unchanged.\n\nConstructors:\n\nNoWhitening()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineMvCov","page":"Internal API","title":"BAT.OnlineMvCov","text":"OnlineMvCov{T<:AbstractFloat,W} <: AbstractMatrix{T}\n\nBAT-internal, not part of stable public API.\n\nImplementation based on variance calculation Algorithms of Welford and West.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineMvMean","page":"Internal API","title":"BAT.OnlineMvMean","text":"OnlineMvMean{T<:AbstractFloat} <: AbstractVector{T}\n\nBAT-internal, not part of stable public API.\n\nMultivariate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineUvMean","page":"Internal API","title":"BAT.OnlineUvMean","text":"OnlineUvMean{T<:AbstractFloat}\n\nBAT-internal, not part of stable public API.\n\nUnivariate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineUvVar","page":"Internal API","title":"BAT.OnlineUvVar","text":"OnlineUvVar{T<:AbstractFloat,W}\n\nBAT-internal, not part of stable public API.\n\nImplementation based on variance calculation Algorithms of Welford and West.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.SampleTransformation","page":"Internal API","title":"BAT.SampleTransformation","text":"struct SampleTransformation <: TransformAlgorithm\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardMvNormal","page":"Internal API","title":"BAT.StandardMvNormal","text":"StandardMvNormal{T<:Real} <: Distributions.AbstractMvNormal\n\nA standard n-dimensional multivariate normal distribution with it's mean at the origin and an identity covariance matrix.\n\nConstructor:\n\n    StandardMvNormal(n::Integer)\n    StandardMvNormal{T<:Real}(n::Integer)\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardMvUniform","page":"Internal API","title":"BAT.StandardMvUniform","text":"StandardMvUniform{T<:Real} <: Distributions.Distribution{Multivariate,Continuous}\n\nA standard n-dimensional multivariate uniform distribution, from zero to one in each dimension.\n\nConstructor:\n\n    StandardMvUniform(n::Integer)\n    StandardMvUniform{T<:Real}(n::Integer)\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardUvNormal","page":"Internal API","title":"BAT.StandardUvNormal","text":"StandardUvNormal{T<:Real} <: Distributions.Distribution{Univariate,Continuous}\n\nA standard normal distribution with a mean of zero and a variance of one.\n\nConstructor:\n\n    StandardUvNormal()\n    StandardUvNormal{T<:Real}()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardUvUniform","page":"Internal API","title":"BAT.StandardUvUniform","text":"StandardUvUniform{T<:Real} <: Distributions.Distribution{Univariate,Continuous}\n\nA standard uniform distribution between zero and one.\n\nConstructor:\n\n    StandardUvUniform()\n    StandardUvUniform{T<:Real}()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StatisticalWhitening","page":"Internal API","title":"BAT.StatisticalWhitening","text":"struct StatisticalWhitening <: WhiteningAlgorithm\n\nBAT-internal, not part of stable public API.\n\nWhitening transformation based statistical whitening. CholeskyPartialWhitening\n\nConstructors:\n\nStatisticalWhitening()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.UnshapeTransformation","page":"Internal API","title":"BAT.UnshapeTransformation","text":"struct UnshapeTransformation <: TransformAlgorithm\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.WhiteningAlgorithm","page":"Internal API","title":"BAT.WhiteningAlgorithm","text":"abstract type WhiteningAlgorithm\n\nBAT-internal, not part of stable public API.\n\nAbstract type for sample whitening algorithms.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.logvalof","page":"Internal API","title":"BAT.logvalof","text":"logvalof(r::NamedTuple{(...,:log,...)})::Real\nlogvalof(r::LogDVal)::Real\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.fft_autocor","page":"Internal API","title":"BAT.fft_autocor","text":"fft_autocor(v::AbstractVector{<:Real})\nfft_autocor(v::AbstractVectorOfSimilarVectors{<:Real})\n\nBAT-internal, not part of stable public API.\n\nCompute the autocorrelation function (ACF) of variate series v, separately for each degree of freedom.\n\nUses FFT, in contract to StatsBase.autocor.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.fft_autocov","page":"Internal API","title":"BAT.fft_autocov","text":"fft_autocov(v::AbstractVector{<:Real})\nfft_autocov(v::AbstractVectorOfSimilarVectors{<:Real})\n\nBAT-internal, not part of stable public API.\n\nCompute the autocovariance of of variate series v, separately for each degree of freedom.\n\nUses FFT, in contract to StatsBase.autocov.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.argchoice_msg","page":"Internal API","title":"BAT.argchoice_msg","text":"argchoice_msg(f::Base.Callable, argname::Val, x)\n\nBAT-internal, not part of stable public API.\n\nGenerates an information message regarding the choice of value x for argument argname of function f.\n\nThe value x will often be the result of bat_default.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.bg_R_2sqr","page":"Internal API","title":"BAT.bg_R_2sqr","text":"bg_R_2sqr(stats::AbstractVector{<:MCMCBasicStats}; corrected::Bool = false)\nbg_R_2sqr(samples::AbstractVector{<:DensitySampleVector}; corrected::Bool = false)\n\nBAT-internal, not part of stable public API.\n\nBrooks-Gelman R_2^2 for all DOF. If normality is assumed, 'corrected' should be set to true to account for the sampling variability.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.checked_logdensityof","page":"Internal API","title":"BAT.checked_logdensityof","text":"checked_logdensityof(measure::AbstractMeasure, v::Any, T::Type{<:Real})\n\nBAT-internal, not part of stable public API.\n\nEvaluates the measure's log-density value via DensityInterface.logdensityof and performs additional checks.\n\nThrows a BAT.EvalException on any of these conditions:\n\nThe variate shape of measure (if known) does not match the shape of v.\nThe return value of DensityInterface.logdensityof is NaN.\nThe return value of DensityInterface.logdensityof is an equivalent of positive infinity.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.drop_low_weight_samples","page":"Internal API","title":"BAT.drop_low_weight_samples","text":"drop_low_weight_samples(\n    samples::DensitySampleVector,\n    fraction::Real = 10^-4\n)\n\nBAT-internal, not part of stable public API.\n\nDrop fraction of the total probability mass from samples to filter out the samples with the lowest weight.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.find_marginalmodes","page":"Internal API","title":"BAT.find_marginalmodes","text":"find_marginalmodes(marg::MarginalDist)\n\nBAT-internal, not part of stable public API.\n\nFind the modes of a MarginalDist. Returns a vector of the bin-centers of the bin(s) with the heighest weight.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.get_bin_centers","page":"Internal API","title":"BAT.get_bin_centers","text":"get_bin_centers(marg::MarginalDist)\n\nBAT-internal, not part of stable public API.\n\nReturns a vector of the bin-centers.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.get_iid_sampleable_approx","page":"Internal API","title":"BAT.get_iid_sampleable_approx","text":"get_iid_sampleable_approx()\n\nBAT-internal, not part of stable public API.\n\nObtain a measure from the target that can be sampled to obtain iid samples for a MCMCGlobalProposal.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.getlikelihood","page":"Internal API","title":"BAT.getlikelihood","text":"getlikelihood(posterior::AbstractPosteriorMeasure)::BATDenstiy\n\nBAT-internal, not part of stable public API.\n\nThe likelihood density of posterior. The likelihood may or may not be normalized.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.getprior","page":"Internal API","title":"BAT.getprior","text":"getprior(posterior::AbstractPosteriorMeasure)::BATMeasure\n\nBAT-internal, not part of stable public API.\n\nThe prior density of posterior. The prior may or may not be normalized.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.gr_Rsqr","page":"Internal API","title":"BAT.gr_Rsqr","text":"gr_Rsqr(stats::AbstractVector{<:MCMCBasicStats})\ngr_Rsqr(samples::AbstractVector{<:DensitySampleVector})\n\nBAT-internal, not part of stable public API.\n\nGelman-Rubin R^2 for all DOF.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.is_log_zero","page":"Internal API","title":"BAT.is_log_zero","text":"BAT.is_log_zero(x::Real, T::Type = typeof(x)}\n\nBAT-internal, not part of stable public API.\n\nCheck if x is an equivalent of log of zero, resp. negative infinity, in respect to type T.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.issymmetric_around_origin","page":"Internal API","title":"BAT.issymmetric_around_origin","text":"issymmetric_around_origin(d::Distribution)\n\nBAT-internal, not part of stable public API.\n\nReturns true (resp. false) if the Distribution is symmetric (resp. non-symmetric) around the origin.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.log_zero_density","page":"Internal API","title":"BAT.log_zero_density","text":"BAT.log_zero_density(T::Type{<:Real})\n\nlog-density value to assume for regions of implicit zero density, e.g. outside of variate/parameter bounds/support.\n\nReturns an equivalent of negative infinity.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.repetition_to_weights","page":"Internal API","title":"BAT.repetition_to_weights","text":"repetition_to_weights(v::AbstractVector)\n\nBAT-internal, not part of stable public API.\n\nDrop (subsequently) repeated samples by adding weights.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.smallest_credible_intervals","page":"Internal API","title":"BAT.smallest_credible_intervals","text":"smallest_credible_intervals(\n    X::AbstractVector{<:Real}, W::AbstractWeights = UnitWeights(...);\n    nsigma_equivalent::Integer = 1\n)\n\nBAT-internal, not part of stable public API.\n\nFind smalles credible intervals with nsigma_equivalent of 1, 2 or 3 (containing 68.27%, 90.00%, 95.45% or 99.73% of the total probability mass).\n\n\n\n\n\nsmallest_credible_intervals(smpl::DensitySampleVector{<:AbstractVector{<:Real}}; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.sum_first_dim","page":"Internal API","title":"BAT.sum_first_dim","text":"@propagate_inbounds sum_first_dim(A::AbstractArray, j::Integer, ks::Integer...)\n\nBAT-internal, not part of stable public API.\n\nCalculate the equivalent of sum(A[:, j, ks...]).\n\n\n\n\n\n@propagate_inbounds sum_first_dim(A::AbstractArray)\n\nBAT-internal, not part of stable public API.\n\nIf A is a vector, return sum(A), else sum(A, 1)[:].\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.supports_rand","page":"Internal API","title":"BAT.supports_rand","text":"supports_rand(m)\n\nBAT-internal, not part of stable public API.\n\nConvert a measure-like object m supports rand.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.trunc_logpdf_ratio","page":"Internal API","title":"BAT.trunc_logpdf_ratio","text":"BAT.trunc_logpdf_ratio(orig_dist::Distribution{TP}, trunc_dist::Distribution{TP})::AbstractFloat\n\nBAT-internal, not part of stable public API.\n\nComputes the log-ratio between the amplitude of the PDF of a truncated distribution and the original (untruncted) distribution, within the support of the truncated one.\n\nThe PDF of both distributions must have the same shape within the support of trunc_dist and may only differ in amplitude.\n\nMainly used to implement BAT.truncate_batmeasure, in conjunction with BAT.truncate_dist_hard.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.truncate_dist_hard","page":"Internal API","title":"BAT.truncate_dist_hard","text":"BAT.truncate_dist_hard(dist::Distribution{Univariate}, bounds::Interval)::Distribution{Univariate}\nBAT.truncate_dist_hard(dist::Distribution{Multivariate}, bounds::AbstractArray{<:Interval})::Distribution{Multivariate}\n\nBAT-internal, not part of stable public API.\n\nGeneralized variant of Distributions.truncated - also handles multivariate distributions and operates on a best-effort basis: If distributions cannot be truncated, may return the original distribution.\n\nReturns a NamedTuple\n\n    (dist = trunc_dist, logweight = logweight)\n\nwith the truncated distribution and the log-PDF amplitude difference to the original (see BAT.trunc_logpdf_ratio).\n\nMainly used to implement BAT.truncate_batmeasure.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.measure_support","page":"Internal API","title":"BAT.measure_support","text":"measure_support(measure::AbstractMeasure)\n\nBAT-internal, not part of stable public API.\n\nGet the parameter bounds of measure. May return a IntervalsSets.Domain or BAT.UnknownDomain\n\n\n\n\n\n","category":"function"},{"location":"license/#License","page":"License","title":"License","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"section"},{"location":"plotting/#Plot-Recipes","page":"Plotting","title":"Plot Recipes","text":"The plot recipes described below apply for plotting samples. Only the plotting of estimators (mean, standard deviation, global mode and local mode) is currently only supported for samples.\n\nAlso see the plotting tutorial for examples and further information on the plotting options.","category":"section"},{"location":"plotting/#1D-plots","page":"Plotting","title":"1D plots","text":"plot(\n    samples::DensitySampleVector,\n    vsel::Union{Integer, Symbol, Expr};\n    intervals = BAT.default_credibilities,\n    bins = 200,\n    colors = BAT.default_colors,\n    interval_labels = [],\n    mean = false,\n    std = false,\n    globalmode = false,\n    marginalmode = true,\n    filter = false,\n    closed = :left\n)\n\nRequired inputs:\n\nsamples::DensitySampleVector: samples to be plotted\nvsel::Union{Integer, Symbol, Expr}: index or name of the parameter to be plotted\n\nKeyword arguments:\n\nseriestype::Symbol = :smallest_intervals: plot style        \n\navailable seriestypes:\n* `:smallest_intervals` (default for samples), alias `:HDR`\n* `:central_intervals`\n* `:histogram`, alias `:steppost`\n* `:stephist`\n\nbins::Union{Integer, AbstractRange} = 200: number of histogram bins or bin edges.\nintervals::Array{<:Real, 1} = [0.683, 0.955, 0.997]: probability to be enclosed in the smallest/central intervals when using the corresponding seriestypes\ncolors::Array{Symbol, 1} = [:chartreuse2, :yellow, :red]: colors of the smallest/central interval regions, in same order as the values in intervals\nmean::Union{Dict, Bool} = true: indicate mean value (currently only for samples), calculated via bat_stats().mean.\n\nThe plot style of the mean can be customized using a Dict.  For mean = true, the default style is:   Dict(\"linestyle\" => :solid, \"linewidth\" => 1, \"linecolor\" => :dimgrey, \"alpha\" => 1, \"label\" => \"mean\")\n\nstd::Union{Dict, Bool} = true: indicate the standard deviation of the mean (currently only for samples), calculated from bat_stats().cov. The style of the standard deviation can be customized using a Dict.  For std = true, the default style is:   \n\nDict(\"fillcolor\" => :grey, \"fillalpha\" => 0.5, \"label\" => \"std. dev.\")\n\nglobalmode::Union{Dict, Bool} = true: indicate global mode (currently only for samples), calculated via bat_stats().mode.  The style of the global mode can be passed as a Dict.  For globalmode = true, the default style is:  \n\nDict(\"linestyle\" => :dash, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"global mode\")\n\nmarginalmode::Union{Dict, Bool} = true: indicate the marginal mode(s), i.e. the center of the highest histogram bin(s) (currently only for samples). The style can be passed as a Dict. If marginalmode = true, the default style is:  \n\nDict(\"linestyle\" => :dot, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"marginal mode\")\n\n(only for samples) filter::Bool = false: if true, BAT.drop_low_weight_samples() is applied before plotting\nclosed = :left: see StatsBase.Histogram\n\nKeyword arguments for attributes supported by Plots.jl can also be passed to the function.","category":"section"},{"location":"plotting/#2D-plots","page":"Plotting","title":"2D plots","text":"plot(\n    samples::DensitySampleVector,\n    vsel::Union{NTuple{2, Integer}, NTuple{2, Union{Symbol, Expr}}};\n    intervals = BAT.default_credibilities,\n\tinterval_labels = [],\n    colors = BAT.default_colors,\n\tbins = 200,\n    mean = false,\n    std = false,\n    globalmode = false,\n    marginalmode = true,\n\tsmoothing = 0,\n    diagonal = Dict(),\n    upper = Dict(),\n    right = Dict(),\n    filter = false,\n    closed = :left\n)\n\nRequired inputs:\n\nsamples::DensitySampleVector: samples to be plotted\nvsel::Union{NTuple{2, Integer}, NTuple{2, Union{Symbol, Expr}}}: indices or names of the two parameters to be plotted\n\nKeyword arguments:\n\nseriestype::Symbol = :smallest_intervals: plot style  \n\navailable seriestypes:\n* `:smallest_intervals` (default for samples)\n* `:smallest_intervals_contour`\n* `:smallest_intervals_contourf`: filled contours)\n* `:histogram`, alias `:hist`, alias `:histogram2d`\n* `:scatter`\n\nbins::Union{Integer, NTuple{2, Integer}, NTuple{2, AbstractRange}} = 200: number of histogram bins or bin edges. Use a NTuple{2, Union{Integer, AbstractRange}} to specify bins/edges of x and y axes separately.\nintervals::Array{<:Real, 1} = [0.683, 0.955, 0.997]  probability to be enclosed in the smallest intervals when using the corresponding seriestypes\ninterval_labels = []  label of the intervals as strings, LatexStrings are possible.\ncolors::Array{Symbol, 1} = [:chartreuse2, :yellow, :red] colors of the smallest interval regions, in same order as the values in intervals\nmean::Union{Dict, Bool} = true: indicate mean value (currently only for samples) , calculated via bat_stats().mean.\n\nThe plot style of the mean can be customized using a Dict.  For mean = true, the default style is: Dict(\"markercolor\" => :black, \"markersize\" => 4, \"markeralpha\" => 1, \"markershape\" => :circle, \"markerstrokealpha\" => 1, \"markerstrokecolor\" => :black, \"markerstrokestyle\" => :solid, \"markerstrokewidth\" => 1, \"label\" => \"mean\")\n\nstd::Union{Bool} = true: indicate the standard deviation of the mean as errorbars (currently only for samples), calculated from bat_stats().cov. The style of the errorbars can be customized using the markerstroke... options in mean.\nglobalmode::Union{Dict, Bool} = true: indicate global mode (currently only for samples), calculated via bat_stats().mode.  The style of the global mode can be passed as a Dict.  For globalmode = true, the default style is:\n\nDict(\"linestyle\" => :dash, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"global mode\")\n\nmarginalmode::Union{Dict, Bool} = true: indicate the marginalmode(s), i.e. the center of the highest histogram bin(s) (currently only for samples). The style can be passed as a Dict. If marginalmode = true, the default style is:\n\nDict(\"linestyle\" => :dot, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"marginal mode\")\n\nsmoothing = 0: When plotting contours, a Gaussian filtering can be applied for smoothing the contour lines. The keyword smoothing accepts  positive real number (or a tuple of two positive real numbers), specifying the standard deviation of the Gaussian kernel (for each dimension) of the filtering.\ndiagonal = Dict(): Used only for the seriestype :marginal. The dictionary can contain the seriestypes and plot options for 2D distributions explained above to modify the 2D plot of the marginal plot. Nested Dictionaries are possible to modify the styles of the estimators as described above\nupper = Dict() and right = Dict():  Used only for the seriestype :marginal. The dictionaries can contain the seriestypes and plot options for 1D distributions explained above to modify the upper and right plots of the 1D marginal distributions. Nested Dictionaries are possible to modify the styles of the estimators as described above\nfilter::Bool = false: if true, BAT.drop_low_weight_samples() is applied before plotting\nclosed = :left: see StatsBase.Histogram\n\nKeyword arguments for attributes supported by Plots.jl can also be passed to the function.","category":"section"},{"location":"plotting/#1D-and-2D-overview-plots","page":"Plotting","title":"1D & 2D overview plots","text":"plot(\n\tsamples::DensitySampleVector;\n    vsel=collect(1:5),\n\tbins = 200,\n    mean=false,\n    std=false,\n    globalmode=false,\n    marginalmode=false,\n    diagonal = Dict(),\n    upper = Dict(),\n    lower = Dict(),\n    vsel_label = []\n)\n\nPlot a grid with the 1D marginalized distributions on the diagonal and all combinations of the 2D marginalized distributions in the lower and upper triangle.\n\nRequired inputs:\n\nsamples::DensitySampleVector: samples to be plotted\n\nKeyword arguments:\n\nvsel = collect(1:5): indices or parameter names of the parameters to be plotted. By default (up to) the first five parameters are plotted.\nbins::Union{Integer, Tuple{Union{Integer, AbstractRange}}, NamedTuple} = 200: Number of bins or bin edges\nmean::Bool = false: Indicate mean value, calculated via  bat_stats().mean, in all plots (currently only for samples)\nstd::Bool = false: Indicate the standard deviation of the mean calculated from bat_stats().cov in all plots (currently only for samples)\nglobalmode::Bool = false: Indicate global mode, calculated via bat_stats().mode, in all plots (currently only for samples)\nmarginalmode::Bool = false: Indicate local mode(s), i.e. the center of the highest histogram bin(s), in all plots (currently only for samples)\ndiagonal = Dict(): The dictionary can contain the seriestypes and plot options for 1D distributions explained above to modify the plots of the 1D marginal distributions on the diagonal of the grid. Nested Dictionaries are possible to modify the styles of the estimators as described above\nlower = Dict() and upper = Dict():  The dictionaries can contain the seriestypes and plot options for 2D distributions explained above to modify the 2D plots in the lower and upper triangles of the grid. Nested Dictionaries are possible to modify the styles of the estimators as described above\nvsel_label = []: parameter label as strings, LatexStrings are possible","category":"section"},{"location":"experimental_api/#Experimental-features","page":"Experimental Features","title":"Experimental features","text":"These are experimental features. Forward/backward compatibility does not follow Julia's semantic versioning rules. Instead, compatibility is only guaranteed across changes in patch version, but not across changes of minor (or major) version.\n\nThe features listed here are likely to transition to the stable API in future versions, but may still evolve in a API-breaking fashion during that process.","category":"section"},{"location":"experimental_api/#BAT.ARPWeighting","page":"Experimental Features","title":"BAT.ARPWeighting","text":"ARPWeighting{T<:AbstractFloat} <: AbstractMCMCWeightingScheme{T}\n\nExperimental feature, not part of stable public API.\n\nSample weighting scheme suitable for accept/reject-based sampling algorithms (e.g. RandomWalk). Both accepted and rejected samples become part of the output, with a weight proportional to their original acceptance probability.\n\nConstructors:\n\nARPWeighting()\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.bat_compare","page":"Experimental Features","title":"BAT.bat_compare","text":"bat_compare(\n    samples_1::DensitySampleVector,\n    samples_2::DensitySampleVector;\n    nsamples::Symbol=:effective\n)\n\nCompares two DensitySampleVectors given by samples_1 and samples_2 applying the Kolmogorov-Smirnov test for all marginals.\n\nnsamples specifies how to define a number of samples in the Kolmogorov-Smirnov distribution. The default value is nsamples=:effective, which uses the effective number of samples estimated by bat_eff_sample_size. The optimal keywords:\n\n:length  — length of the DensitySamplesVector is used\n:weights — the sum of the weights is used\n\nReturns a NamedTuple of the shape\n\n(result = X::TypedTables.Table, ...)\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.bat_integrated_autocorr_len","page":"Experimental Features","title":"BAT.bat_integrated_autocorr_len","text":"bat_integrated_autocorr_len(\n    v::_ACLenTarget,\n    algorithm::AutocorLenAlgorithm = GeyerAutocorLen(),\n    [context::BATContext]\n)\n\nExperimental feature, not yet part of stable public API.\n\nEstimate the integrated autocorrelation length of variate series v, separately for each degree of freedom.\n\nReturns a NamedTuple of the shape\n\n(result = integrated_autocorr_len, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_integrated_autocorr_len, add methods to bat_integrated_autocorr_len_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.bat_marginalmode","page":"Experimental Features","title":"BAT.bat_marginalmode","text":"bat_marginalmode(\n    target::DensitySampleVector,\n    algorithm::AbstractModeEstimator,\n    [context::BATContext]\n)::DensitySampleVector\n\nExperimental feature, not part of stable public API.\n\nEstimates a marginal mode of target by finding the maximum of marginalized posterior for each dimension.\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\nnote: Note\nDo not add add methods to bat_marginalmode, add methods to bat_marginalmode_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.auto_renormalize","page":"Experimental Features","title":"BAT.auto_renormalize","text":"BAT.auto_renormalize(measure::MeasureBase.AbstractMeasure)\n\nExperimental feature, not part of stable public API.\n\nReturns (result = new_measure, logweight = logweight).\n\nTries to automatically renormalize measure if a maxium log-m value is available, returns measure unchanged otherwise.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.batsampleable","page":"Experimental Features","title":"BAT.batsampleable","text":"batsampleable(obj)\n\nExperimental feature, not part of stable public API.\n\nConvert obj into something that BAT can sample from.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.BinnedModeEstimator","page":"Experimental Features","title":"BAT.BinnedModeEstimator","text":"struct BinnedMarginalModes <: AbstractModeEstimator\n\nExperimental feature, not part of stable public API.\n\nBin data to estimate modes.\n\nConstructor: BinnedModeEstimator(; fields...)\n\nFields:\n\nbinning::Any: Default: FreedmanDiaconisBinning()\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.DistributionTransform","page":"Experimental Features","title":"BAT.DistributionTransform","text":"abstract type DistributionTransform <: Function\n\nExperimental feature, not part of stable public API.\n\nTransform variate values between distributions\n\nConstructors:\n\nDistributionTransform(target_dist, source_dist)\nDistributionTransform(Uniform, source_dist)\nDistributionTransform(Normal, source_dist)\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.enable_error_log","page":"Experimental Features","title":"BAT.enable_error_log","text":"BAT.enable_error_log(enable::Bool = true)\n\nExperimental feature, not part of stable public API.\n\nEnable/disable BAT's error (exception) log.\n\nThe error log is disabled by default.\n\nSee BAT.error_log.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.error_log","page":"Experimental Features","title":"BAT.error_log","text":"BAT.error_log()\n\nExperimental feature, not part of stable public API.\n\nGet a log of certain exceptions throws by BAT, e.g. density evaluation errors.\n\nThe error log is disabled by default, use BAT.enable_error_log to enable it.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.EvalException","page":"Experimental Features","title":"BAT.EvalException","text":"struct EvalException <: Exception\n\nConstructors:\n\nEvalException(func::Function, measure::AbstractMeasure, v::Any, ret::Any)\n\nFields:\n\nfunc::Function: Density evaluation function that failed.\nmeasure::MeasureBase.AbstractMeasure: Density being evaluated.\nv::Any: Variate at which the evaluation of measure (applying f to d at v) failed.\nret::Any: Cause of failure, either the invalid return value of f on d at v, or another expection (on rethrow).\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.ext_default","page":"Experimental Features","title":"BAT.ext_default","text":"BAT.ext_default(::PackageExtension{SomePackage}, ::Val{:SomeLabel}, args; kwargs...)\n\nExperimental feature, not part of stable public API.\n\nReturns the default value selected by :SomeLabel within the context of the package extension that depends on SomePackage.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.get_adselector","page":"Experimental Features","title":"BAT.get_adselector","text":"BAT.get_adselector(context::BATContext)\n\nExperimental feature, not yet part of stable public API.\n\nReturns the automatic differentiation selector specified in context.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.get_valid_adselector","page":"Experimental Features","title":"BAT.get_valid_adselector","text":"BAT.get_valid_adselector(context::BATContext, algorithm)\n\nExperimental feature, not yet part of stable public API.\n\nReturns the automatic differentiation selector specified in context, to be used for algorithm.\n\nThrows an exception if context specifies AutoDiffOperators.NoAutoDiff.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.PackageExtension","page":"Experimental Features","title":"BAT.PackageExtension","text":"abstract type PackageExtension{pkgname}\n\nExperimental feature, not part of stable public API.\n\nRepresents a package extension that requires the package pkgname to be loaded.\n\nDo not construct instances of PackageExtension directly, use pkgext(:pkgname) instead which will check that the required extension is active.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.pkgext","page":"Experimental Features","title":"BAT.pkgext","text":"BAT.pkgext(:SomePackage)::PackageExtension\nBAT.pkgext(Val(:SomePackage))::PackageExtension\n\nExperimental feature, not part of stable public API.\n\nReturns the PackageExtension instance that depends on the package SomePackage. Will throw an error if the extension is not active (because SomePackage` hasn't been loaded).\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.set_rng","page":"Experimental Features","title":"BAT.set_rng","text":"BAT.set_rng(context::BATContext, rng::AbstractRNG)::BATContext\n\nExperimental feature, not yet part of stable public API.\n\nReturns a copy of context with the random number generator set to rng.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.batmeasure","page":"Experimental Features","title":"BAT.batmeasure","text":"batmeasure(obj)\n\nExperimental feature, not part of stable public API.\n\nConvert a measure-like obj to a measure that is compatible with BAT.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.BridgeSampling","page":"Experimental Features","title":"BAT.BridgeSampling","text":"struct BridgeSampling <: IntegrationAlgorithm\n\nExperimental feature, not part of stable public API.\n\nBridgeSampling integration algorithm.\n\nConstructors:\n\nBridgeSampling(; fields...)\n\nFields:\n\npretransform::AbstractTransformTarget: Default: PriorToNormal()\nessalg::EffSampleSizeAlgorithm: Default: EffSampleSizeFromAC()\nstrict::Bool: Default: true\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.EllipsoidalNestedSampling","page":"Experimental Features","title":"BAT.EllipsoidalNestedSampling","text":"struct EllipsoidalNestedSampling <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nUses the julia package NestedSamplers.jl to use nested sampling algorithm.\n\nConstructors:\n\nEllipsoidalNestedSampling(; fields...)\n\nFields:\n\npretransform::AbstractTransformTarget: Default: begin     pkgext(Val(:NestedSamplers))     #= /home/runner/work/BAT.jl/BAT.jl/src/extdefs/nestedsamplers_defs.jl:149 =#     PriorToUniform() end\nnum_live_points::Int64: Number of live-points. Default: 1000\nbound::BAT.ENSBound: Volume around the live-points. Default: ENSEllipsoidBound()\nproposal::BAT.ENSProposal: Algorithm used to choose new live-points. Default: ENSAutoProposal()\nenlarge::Float64: Scale factor for the volume. Default: 1.25\nmin_ncall::Int64: Number of iterations before the first bound will be fit. Default: 2numlivepoints\nmin_eff::Float64: Efficiency before fitting the first bound. Default: 0.1\ndlogz::Float64: Default: 0.01\nmax_iters::Any: Default: Inf\nmax_ncalls::Any: Default: 10 ^ 7\nmaxlogl::Any: Default: Inf\n\nnote: Note\nThis functionality is only available when the NestedSamplers.jl package  is loaded (e.g. via import).\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.GridSampler","page":"Experimental Features","title":"BAT.GridSampler","text":"struct GridSampler <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nSample from equidistantly distributed points in each dimension.\n\nConstructors:\n\nGridSampler(; fields...)\n\nFields:\n\npretransform::AbstractTransformTarget: Default: PriorToUniform()\nppa::Int64: Default: 100\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.HierarchicalDistribution","page":"Experimental Features","title":"BAT.HierarchicalDistribution","text":"struct HierarchicalDistribution <: ContinuousDistribution\n\nExperimental feature, not part of stable public API.\n\nA hierarchical distribution, useful for hierarchical models/priors.\n\nConstructors:\n\nHierarchicalDistribution(f::Function, primary_dist::NamedTupleDist)\n\nwith a functon f that returns a ContinuousDistribution for any variate v drawn from primary_dist.\n\nExample:\n\nhd = HierarchicalDistribution(\n    v -> NamedTupleDist(\n        baz = fill(Normal(v.bar, v.foo), 3)\n    ),\n    NamedTupleDist(\n        foo = Exponential(3.5),\n        bar = Normal(2.0, 1.0)\n    )\n)\n\nvarshape(hd) == NamedTupleShape(\n    foo = ScalarShape{Real}(),\n    bar = ScalarShape{Real}(),\n    baz = ArrayShape{Real}(3)\n)\n\nv = rand(hd)\n\nnote: Note\nAll fields of HierarchicalDistribution are considered internal and subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.PriorImportanceSampler","page":"Experimental Features","title":"BAT.PriorImportanceSampler","text":"struct PriorImportanceSampler <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nImportance sampler using IID samples from the prior.\n\nConstructors:\n\nPriorImportanceSampler(; fields...)\n\nFields:\n\nnsamples::Int64: Default: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.ReactiveNestedSampling","page":"Experimental Features","title":"BAT.ReactiveNestedSampling","text":"struct ReactiveNestedSampling <: AbstractUltraNestAlgorithmReactiv\n\nExperimental feature, not part of stable public API.\n\nUltraNest reactive nested sampling algorithm with.\n\nUses the UltraNest Python package, via UltraNest.jl (and PyCall).\n\nConstructors:\n\nReactiveNestedSampling(; fields...)\n\nFields:\n\npretransform::AbstractTransformTarget: Default: begin     pkgext(Val(:UltraNest))     #= /home/runner/work/BAT.jl/BAT.jl/src/extdefs/ultranest_defs.jl:34 =#     PriorToUniform() end\nnum_test_samples::Int64: Test transform and likelihood with this number of random points for errors first. Useful to catch bugs. Default: 2\ndraw_multiple::Bool: If efficiency goes down, dynamically draw more points from the region between ndrawmin and ndrawmax. If set to False, few points are sampled at once. Default: true\nnum_bootstraps::Int64: Number of logZ estimators and MLFriends region bootstrap rounds. Default: 30\nndraw_min::Int64: Minimum number of points to simultaneously propose. Increase this if your likelihood makes vectorization very cheap. Default: 128\nndraw_max::Int64: Maximum number of points to simultaneously propose. Increase this if your likelihood makes vectorization very cheap. Memory allocation may be slow for extremely high values. Default: 65536\nupdate_interval_volume_fraction::Float64: Update region when the volume shrunk by this amount. Default: 0.8\nlog_interval::Int64: Update stdout status line every log_interval iterations. Default: -1\nshow_status::Bool: Show integration progress as a status line. Default: true\nviz_callback::Union{Nothing, Function}: Callback function when region was rebuilt. Allows to show current state of the live points. Default: nothing\ndlogz::Float64: Target evidence uncertainty. This is the std between bootstrapped logz integrators. Default: 0.5\ndKL::Float64: Target posterior uncertainty. This is the Kullback-Leibler divergence in nat between bootstrapped integrators. Default: 0.5\nfrac_remain::Float64: Integrate until this fraction of the integral is left in the remainder. Set to a low number (1e-2 … 1e-5) to make sure peaks are discovered. Set to a higher number (0.5) if you know the posterior is simple. Default: 0.01\nLepsilon::Float64: Terminate when live point likelihoods are all the same, within Lepsilon tolerance. Increase this when your likelihood function is inaccurate, to avoid unnecessary search. Default: 0.001\nmin_ess::Int64: Target number of effective posterior samples. Default: 400\nmax_iters::Int64: maximum number of integration iterations. Default: -1\nmax_ncalls::Int64: Stop after this many likelihood evaluations. Default: -1\nmax_num_improvement_loops::Int64: The algorithm tries to assess iteratively where more samples are needed. This number limits the number of improvement loops. Default: -1\nmin_num_live_points::Int64: Minimum number of live points throughout the run. Default: 400\ncluster_num_live_points::Int64: Require at least this many live points per detected cluster. Default: 40\ninsertion_test_window::Float64: z-score used as a threshold for the insertion order test. Set to infinity to disable. Default: 10.0\ninsertion_test_zscore_threshold::Float64: Number of iterations after which the insertion order test is reset. Default: 2.0\nexecutor::Any: Executor for posterior evaluation. Default: SequentialExec()\n\nnote: Note\nThis functionality is only available when the UltraNest package is loaded (e.g. via import UltraNest).\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.SobolSampler","page":"Experimental Features","title":"BAT.SobolSampler","text":"struct SobolSampler <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nSample from Sobol sequence. Also see Sobol.jl.\n\nConstructors:\n\nSobolSampler(; fields...)\n\nFields:\n\npretransform::AbstractTransformTarget: Default: PriorToUniform()\nnsamples::Int64: Default: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.truncate_batmeasure","page":"Experimental Features","title":"BAT.truncate_batmeasure","text":"BAT.truncate_batmeasure(density::BATMeasure, bounds::AbstractArray{<:Interval})::BATMeasure\n\nExperimental feature, not part of stable public API.\n\nTruncate density to bounds, the resulting density will be effectively zero outside of those bounds. In contrast Distributions.truncated, truncate_batmeasure does not renormalize the density.\n\nRequires varshape(density) isa ArrayShape.\n\nOnly supports densities that are essentially products of univariate distributions, as well as posterior densities with such densities as priors.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.ValueAndThreshold","page":"Experimental Features","title":"BAT.ValueAndThreshold","text":"struct ValueAndThreshold{name}\n\nExperimental feature, not part of stable public API.\n\nHolds a (target) value, a comparison function and a threshold.\n\nConstructor: ValueAndThreshold{name}(value, cmp_function, threshold)\n\nConverts to a Bool accoring to cmp_function(value, threshold)\n\nExample:\n\nconvert(Bool, ValueAndThreshold{:max_error}(3.4, <, 5.2)) == true\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.MCMCChainState","page":"Experimental Features","title":"BAT.MCMCChainState","text":"MCMCChainState\n\nState of a MCMC chain.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.MCMCChainStateInfo","page":"Experimental Features","title":"BAT.MCMCChainStateInfo","text":"MCMCChainStateInfo\n\nInformation about the state of an MCMC chain.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.MCMCIterator","page":"Experimental Features","title":"BAT.MCMCIterator","text":"abstract type MCMCIterator end\n\nBAT-internal, not part of stable public API.\n\nRepresents the current state of an MCMC chain.\n\nnote: Note\nThe details of the MCMCIterator and MCMCAlgorithm API (see below) currently do not form part of the stable API and are subject to change without deprecation.\n\nTo implement a new MCMC algorithm, subtypes of both MCMCAlgorithm and MCMCIterator are required.\n\nThe following methods must be defined for subtypes of MCMCIterator (e.g. SomeMCMCIter<:MCMCIterator):\n\nBAT.getproposal(chain::SomeMCMCIter)::MCMCAlgorithm\n\nBAT.mcmc_target(chain::SomeMCMCIter)::BATMeasure\n\nBAT.get_context(chain::SomeMCMCIter)::BATContext\n\nBAT.mcmc_info(chain::SomeMCMCIter)::MCMCIteratorInfo\n\nBAT.nsteps(chain::SomeMCMCIter)::Int\n\nBAT.nsamples(chain::SomeMCMCIter)::Int\n\nBAT.current_sample(chain::SomeMCMCIter)::DensitySample\n\nBAT.sample_type(chain::SomeMCMCIter)::Type{<:DensitySample}\n\nBAT.get_samples!(samples::DensitySampleVector, chain::SomeMCMCIter, nonzero_weights::Bool)::typeof(samples)\n\nBAT.next_cycle!(chain::SomeMCMCIter)::SomeMCMCIter\n\nBAT.mcmc_step!!(\n    chain::SomeMCMCIter\n    callback::Function,\n)::nothing\n\nThe following methods are implemented by default:\n\ngetproposal(chain::MCMCIterator)\nmcmc_target(chain::MCMCIterator)\nDensitySampleVector(chain::MCMCIterator)\nmcmc_iterate!!(chain::MCMCIterator, ...)\nmcmc_iterate!!(chains::AbstractVector{<:MCMCIterator}, ...)\nisvalidchain(chain::MCMCIterator)\nisviablechain(chain::MCMCIterator)\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.MCMCProposal","page":"Experimental Features","title":"BAT.MCMCProposal","text":"abstract type MCMCProposal\n\nAbstract type for MCMC proposal algorithms.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.MCMCProposalState","page":"Experimental Features","title":"BAT.MCMCProposalState","text":"abstract type MCMCProposalState\n\nAbstract type for MCMC proposal algorithm states.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.MCMCProposalTunerState","page":"Experimental Features","title":"BAT.MCMCProposalTunerState","text":"abstract type MCMCProposalTunerState\n\nAbstract type for MCMC tuning algorithm states.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.MCMCState","page":"Experimental Features","title":"BAT.MCMCState","text":"MCMCState\n\nCarrier type for the states of an MCMC chain, and the states  of the tuning and tempering algorithms used for sampling.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.MCMCTempering","page":"Experimental Features","title":"BAT.MCMCTempering","text":"abstract type MCMCTempering\n\nAbstract type for MCMC tempering algorithms.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.MCMCTransformTunerState","page":"Experimental Features","title":"BAT.MCMCTransformTunerState","text":"abstract type MCMCTransformTunerState\n\nAbstract type for MCMC tuning algorithm states.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.PolarShellDistribution","page":"Experimental Features","title":"BAT.PolarShellDistribution","text":"BAT.PolarShellDistribution{T<:Real} <: Distributions.Distribution{Multivariate,Continuous}\n\nExperimental feature, not yet part of stable public API.\n\nA doughnut-like distribution in two dimensions, in [r, phi] polar coordinates.\n\nThe distribution results from transforming the radial component of a base distribution the transport from a standard normal to a given radial distribution.\n\nConstructor:\n\n    PolarShellDistribution(\n        base_dist = MvNormal(Diagonal([1,1])),\n        radial_dist = LogNormal(0, 1)\n    )\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.SimpleMCMCProposalState","page":"Experimental Features","title":"BAT.SimpleMCMCProposalState","text":"abstract type SimpleMCMCProposalState\n\nAbstract type for the states of simple MCMC proposal algorithms, that are implemented in BAT.jl. This is used to treat more complicated algorithms -that may depend on external packages- differently.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.TemperingState","page":"Experimental Features","title":"BAT.TemperingState","text":"abstract type TemperingState\n\nAbstract type for MCMC tempering algorithm states.\n\n\n\n\n\n","category":"type"},{"location":"#BAT.jl-Documentation","page":"Home","title":"BAT.jl Documentation","text":"BAT.jl is a Bayesian Analysis Toolkit in Julia. It is a high-performance tool box for Bayesian inference with statistical models expressed in a general-purpose programming language instead of a domain-specific language.\n\nTypical applications for this package are parameter inference given a model (in the form of a likelihood function and prior), the comparison of different models in the light of a given data set, and the test of the validity of a model to represent the data set at hand. BAT.jl provides access to the full Bayesian posterior distribution to enable parameter estimation, limit setting and uncertainty propagation. BAT.jl also provides supporting functionality like plotting recipes and reporting functions.\n\nBAT.jl is implemented in pure Julia and allows for a flexible definition of mathematical models and applications while enabling the user to code for the performance required for computationally expensive numerical operations. BAT.jl provides implementations (internally and via other Julia packages) of algorithms for sampling, optimization and integration. BAT's main focus is on the analysis of complex custom models. It is designed to enable parallel code execution at various levels (running multiple MCMC chains in parallel is provided out-of-the-box).\n\nIt's possible to use BAT.jl with likelihood functions implemented in languages other than Julia: Julia allows for calling code in C and Fortran, C++, Python and several other languages directly.\n\nBAT.jl originated as a rewrite/redesign of BAT, the Bayesian Analysis Toolkit in C++. BAT.jl now offer a different set of functionality and a wider variety of algorithms than it's C++ predecessor.\n\nnote: Note\nBAT.jl requires Julia >= v1.10, we recommend to use the latest stable Julia version for optimal performance.","category":"section"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"Pages = [\n    # \"basics.md\",\n    \"installation.md\",\n    \"tutorial.md\",\n    # \"faq.md\",\n    # \"examples.md\",\n    # \"algorithms.md\",\n    # \"benchmarks.md\",\n    # \"publications.md\",\n    \"api.md\",\n    \"developing.md\",\n    \"license.md\",\n]\nDepth = 1","category":"section"},{"location":"#Citing-BAT.jl","page":"Home","title":"Citing BAT.jl","text":"When using BAT.jl for research, teaching or similar, please cite Schulz et al. \"BAT.jl: A Julia-Based Tool for Bayesian Inference\", SNCS (2021).\n\n@article{Schulz:2021BAT,\n  author  = {Schulz, Oliver and Beaujean, Frederik and Caldwell, Allen and Grunwald, Cornelius and Hafych, Vasyl and Kr{\\\"o}ninger, Kevin and Cagnina, Salvatore La and R{\\\"o}hrig, Lars and Shtembari, Lolian},\n  journal = {SN Computer Science},\n  title   = {BAT.jl: A Julia-Based Tool for Bayesian Inference},\n  year    = {2021},\n  issn    = {2661-8907},\n  month   = {Apr},\n  number  = {3},\n  pages   = {210},\n  volume  = {2},\n  day     = {12},\n  doi     = {10.1007/s42979-021-00626-4},\n  url     = {https://doi.org/10.1007/s42979-021-00626-4},\n}","category":"section"},{"location":"#Learning-(more-about)-Julia","page":"Home","title":"Learning (more about) Julia","text":"BAT.jl supersedes BAT in C++. If you're considering to switch to BAT.jl, but you're new to Julia and want to learn more about the the language, here are a few resources to get started:\n\nThe Julia website provides many links to introductory videos and written tutorials, e.g. \"Intro to Julia\", Think Julia: How to Think Like a Computer Scientist and \"The Fast Track to Julia\". If you are familiar with MATLAB or Python, you may also want to take a look at the \"MATLAB–Python–Julia cheatsheet\".\n\nThe in-depth article Why Numba and Cython are not substitutes for Julia explains how Julia addresses several fundamental challenges inherent to scientific high-performance computing.","category":"section"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"We acknowledge the contributions from all the BAT.jl users, they help us make BAT.jl a better project. Your help is most welcome!\n\nDevelopment of BAT.jl has been supported by funding from\n\nDeutsche Forschungsgemeinschaft (DFG, German Research Foundation)\nEuropean Union Framework Programme for Research and Innovation Horizon 2020 (2014-2020) under the Marie Sklodowska-Curie Grant Agreement No.765710","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates a simple application of BAT.jl: A Bayesian fit of a histogram with two Gaussian peaks.\n\nYou can also download this tutorial as a Jupyter notebook and a plain Julia source file.\n\nTable of contents:\n\nPages = [\"tutorial.md\"]\nDepth = 3\n\nNote: This tutorial is somewhat verbose, as it aims to be easy to follow for users who are new to Julia. For the same reason, we deliberately avoid making use of Julia features like closures, anonymous functions, broadcasting syntax, performance annotations, etc.","category":"section"},{"location":"tutorial/#Input-Data-Generation","page":"Tutorial","title":"Input Data Generation","text":"First, let's generate some synthetic data to fit. We'll need the Julia standard-library packages \"Random\", \"LinearAlgebra\" and \"Statistics\", as well as the packages \"Distributions\" and \"StatsBase\":\n\nusing Random, LinearAlgebra, Statistics, Distributions, StatsBase\n\nAs the underlying truth of our input data/histogram, let us choose the expected count to follow the sum of two Gaussian peaks with peak areas of 500 and 1000, a mean of -1.0 and 2.0 and a standard error of 0.5. Then\n\ndata = vcat(\n    rand(Normal(-1.0, 0.5), 500),\n    rand(Normal( 2.0, 0.5), 1000)\n)\n\nresulting in a vector of floating-point numbers:\n\ntypeof(data) == Vector{Float64}\n\nNext, we'll create a histogram of that data, this histogram will serve as the input for the Bayesian fit:\n\nhist = append!(Histogram(-2:0.1:4), data)\n\nUsing the Julia \"Plots\" package\n\nusing Plots\n\nwe can plot the histogram:\n\nplot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data\"\n)\nsavefig(\"tutorial-data.pdf\")\nsavefig(\"tutorial-data.svg\"); nothing # hide\n\n(Image: Data)\n\nLet's define our fit function - the function that we expect to describe the data histogram, at each x-Axis position x, depending on a given set p of model parameters:\n\nfunction fit_function(p::NamedTuple{(:a, :mu, :sigma)}, x::Real)\n    p.a[1] * pdf(Normal(p.mu[1], p.sigma), x) +\n    p.a[2] * pdf(Normal(p.mu[2], p.sigma), x)\nend\nnothing # hide\n\nThe fit parameters (model parameters) a (peak areas) and mu (peak means) are vectors, parameter sigma (peak width) is a scalar, we assume it's the same for both Gaussian peaks.\n\nThe true values for the model/fit parameters are the values we used to generate the data:\n\ntrue_par_values = (a = [500, 1000], mu = [-1.0, 2.0], sigma = 0.5)\nnothing # hide\n\nLet's visually compare the histogram and the fit function, using these true parameter values, to make sure everything is set up correctly:\n\nplot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data and True Statistical Model\"\n)\nplot!(\n    -4:0.01:4, x -> fit_function(true_par_values, x),\n    label = \"Truth\"\n)\nsavefig(\"tutorial-data-and-truth.pdf\")\nsavefig(\"tutorial-data-and-truth.svg\"); nothing # hide\n\n(Image: Data and True Statistical Model)","category":"section"},{"location":"tutorial/#Bayesian-Fit","page":"Tutorial","title":"Bayesian Fit","text":"Now we'll perform a Bayesian fit of the generated histogram, using BAT, to infer the model parameters from the data histogram.\n\nIn addition to the Julia packages loaded above, we need BAT itself, as well as IntervalSets:\n\nusing BAT, DensityInterface, IntervalSets","category":"section"},{"location":"tutorial/#Likelihood-Definition","page":"Tutorial","title":"Likelihood Definition","text":"First, we need to define the likelihood for our problem.\n\nBAT expects likelihoods to implements the DensityInterface API. We can simply wrap a log-likelihood function with DensityInterface.logfuncdensity to make it compatible.\n\nFor performance reasons, functions should [not access global variables directly] (https://docs.julialang.org/en/v1/manual/performance-tips/index.html#Avoid-global-variables-1). So we'll use an anonymous function inside of a let-statement to capture the value of the global variable hist in a local variable h (and to shorten function name fit_function to f, purely for convenience). DensityInterface.logfuncdensity then turns the log-likelihood function into a DensityInterface density object.\n\nlikelihood = let h = hist, f = fit_function\n    # Histogram counts for each bin as an array:\n    observed_counts = h.weights\n\n    # Histogram binning:\n    bin_edges = h.edges[1]\n    bin_edges_left = bin_edges[1:end-1]\n    bin_edges_right = bin_edges[2:end]\n    bin_widths = bin_edges_right - bin_edges_left\n    bin_centers = (bin_edges_right + bin_edges_left) / 2\n\n    logfuncdensity(function (params)\n        # Log-likelihood for a single bin:\n        function bin_log_likelihood(i)\n            # Simple mid-point rule integration of fit function `f` over bin:\n            expected_counts = bin_widths[i] * f(params, bin_centers[i])\n            # Avoid zero expected counts for numerical stability:\n            logpdf(Poisson(expected_counts + eps(expected_counts)), observed_counts[i])\n        end\n\n        # Sum log-likelihood over bins:\n        idxs = eachindex(observed_counts)\n        ll_value = bin_log_likelihood(idxs[1])\n        for i in idxs[2:end]\n            ll_value += bin_log_likelihood(i)\n        end\n\n        return ll_value\n    end)\nend\n\nBAT makes use of Julia's parallel programming facilities if possible, e.g. to run multiple Markov chains in parallel. Therefore, log-likelihood (and other) code must be thread-safe. Mark non-thread-safe code with @critical (provided by Julia package ParallelProcessingTools).\n\nSupport for automatic parallelization across multiple (local and remote) Julia processes is planned, but not implemented yet.\n\nNote that Julia currently starts only a single thread by default. Set the the environment variable JULIA_NUM_THREADS to specify the desired number of Julia threads.\n\nWe can evaluate likelihood, e.g. at the true parameter values:\n\nlogdensityof(likelihood, true_par_values)","category":"section"},{"location":"tutorial/#Prior-Definition","page":"Tutorial","title":"Prior Definition","text":"Next, we need to choose a sensible prior for the fit:\n\nprior = distprod(\n    a = [Weibull(1.1, 5000), Weibull(1.1, 5000)],\n    mu = [-2.0..0.0, 1.0..3.0],\n    sigma = Weibull(1.2, 2)\n)\n\nnothing # hide\n\nBAT supports most Distributions.Distribution types, and combinations of them, as priors.","category":"section"},{"location":"tutorial/#Bayesian-Model-Definition","page":"Tutorial","title":"Bayesian Model Definition","text":"Given the likelihood and prior definition, a BAT.PosteriorMeasure is simply defined via\n\nposterior = PosteriorMeasure(likelihood, prior)\nnothing # hide","category":"section"},{"location":"tutorial/#Parameter-Space-Exploration-via-MCMC","page":"Tutorial","title":"Parameter Space Exploration via MCMC","text":"We can now use Markov chain Monte Carlo (MCMC) to explore the space of possible parameter values for the histogram fit.\n\nTo increase the verbosity level of BAT logging output, you may want to set the Julia logging level for BAT to debug via bat_logdebug().\n\nNow we can generate a set of MCMC samples via bat_sample. We'll use 4 MCMC chains with 10^5 MC steps in each chain (after tuning/burn-in):\n\nsamples = bat_sample(posterior, TransformedMCMC(proposal = RandomWalk(), nsteps = 10^5, nchains = 4)).result\nnothing # hide\n\nLet's calculate some statistics on the posterior samples:\n\nprintln(\"Truth: $true_par_values\")\nprintln(\"Mode: $(mode(samples))\")\nprintln(\"Mean: $(mean(samples))\")\nprintln(\"Stddev: $(std(samples))\")\n\nInternally, BAT often needs to represent variates as flat real-valued vectors:\n\nunshaped_samples, f_flatten = bat_transform(Vector, samples)\n\nThe statisics above (mode, mean and std-dev) are presented in shaped form. However, it's not possible to represent statistics with matrix shape, e.g. the parameter covariance matrix, this way. So the covariance has to be accessed in unshaped form:\n\npar_cov = cov(unshaped_samples)\nprintln(\"Covariance: $par_cov\")\n\nUse LazyReports.lazyreport to generate an overview of the sampling result and parameter estimates (based on the marginal distributions):\n\nusing LazyReports\nlazyreport(samples)","category":"section"},{"location":"tutorial/#Visualization-of-Results","page":"Tutorial","title":"Visualization of Results","text":"BAT.jl comes with an extensive set of plotting recipes for [\"Plots.jl\"] (http://docs.juliaplots.org/latest/). We can plot the marginalized distribution for a single parameter (e.g. parameter 3, i.e. μ[1]):\n\nplot(\n    samples, :(mu[1]),\n    mean = true, std = true, globalmode = true, marginalmode = true,\n    nbins = 50, title = \"Marginalized Distribution for mu[1]\"\n)\nsavefig(\"tutorial-single-par.pdf\")\nsavefig(\"tutorial-single-par.svg\"); nothing # hide\n\n(Image: Marginalized Distribution for mu_1)\n\nor plot the marginalized distribution for a pair of parameters (e.g. parameters 3 and 5, i.e. μ[1] and σ), including information from the parameter stats:\n\nplot(\n    samples, (:(mu[1]), :sigma),\n    mean = true, std = true, globalmode = true, marginalmode = true,\n    nbins = 50, title = \"Marginalized Distribution for mu[1] and sigma\"\n)\nplot!(BAT.MCMCBasicStats(samples), (3, 5))\nsavefig(\"tutorial-param-pair.png\")\nsavefig(\"tutorial-param-pair.svg\"); nothing # hide\n\n(Image: Marginalized Distribution for mu_1 and sigma)\n\nWe can also create an overview plot of the marginalized distribution for all pairs of parameters:\n\nplot(\n    samples,\n    mean = false, std = false, globalmode = true, marginalmode = false,\n    nbins = 50\n)\nsavefig(\"tutorial-all-params.png\")\nsavefig(\"tutorial-all-params.svg\"); nothing # hide\n\n(Image: Pairwise Correlation between Parameters)","category":"section"},{"location":"tutorial/#Integration-with-Tables.jl","page":"Tutorial","title":"Integration with Tables.jl","text":"DensitySamplesVector supports the Tables.jl interface, so it is a table itself. We can also convert it to other table types, e.g. a TypedTables.Table:\n\nusing TypedTables\n\ntbl = Table(samples)\n\nor a DataFrames.DataFrame, etc.","category":"section"},{"location":"tutorial/#Comparison-of-Truth-and-Best-Fit","page":"Tutorial","title":"Comparison of Truth and Best Fit","text":"As a final step, we retrieve the parameter values at the mode, representing the best-fit parameters\n\nsamples_mode = mode(samples)\n\nLike the samples themselves, the result can be viewed in both shaped and unshaped form. samples_mode is presented as a 0-dimensional array that contains a NamedTuple, this representation preserves the shape information:\n\nsamples_mode isa NamedTuple\n\nsamples_mode is only an estimate of the mode of the posterior distribution. It can be further refined using bat_findmode:\n\nusing Optim\n\nfindmode_result = bat_findmode(\n    posterior,\n    OptimAlg(optalg = Optim.NelderMead(), init = ExplicitInit([samples_mode]))\n)\n\nfit_par_values = findmode_result.result\n\nLet's plot the data and fit function given the true parameters and MCMC samples\n\nplot(-4:0.01:4, fit_function, samples)\n\nplot!(\n    normalize(hist, mode=:density),\n    color=1, linewidth=2, fillalpha=0.0,\n    st = :steps, fill=false, label = \"Data\",\n    title = \"Data, True Model and Best Fit\"\n)\n\nplot!(-4:0.01:4, x -> fit_function(true_par_values, x), color=4, label = \"Truth\")\nsavefig(\"tutorial-data-truth-bestfit.pdf\")\nsavefig(\"tutorial-data-truth-bestfit.svg\"); nothing # hide\n\n(Image: Data, True Model and Best Fit)","category":"section"},{"location":"tutorial/#Fine-grained-control","page":"Tutorial","title":"Fine-grained control","text":"BAT provides fine-grained control over the MCMC algorithm options, the MCMC chain initialization, tuning/burn-in strategy and convergence testing. All option value used in the following are the default values, any or all may be omitted.\n\nWe'll sample using the random-walk Metropolis-Hastings MCMC algorithm:\n\nmcmcalgo = RandomWalk()\n\nBAT requires a counter-based random number generator (RNG), since it partitions the RNG space over the MCMC chains. This way, a single RNG seed is sufficient for all chains and results are reproducible even under parallel execution. By default, BAT uses a Philox4x RNG initialized with a random seed drawn from the system entropy pool:\n\nusing Random123\nrng = Philox4x()\ncontext = BATContext(rng = Philox4x())\nnothing # hide\n\nBy default, RandomWalk() uses the following options.\n\nFor Markov chain initialization:\n\ninit = MCMCChainPoolInit()\n\nFor the MCMC burn-in procedure:\n\nburnin = MCMCMultiCycleBurnin()\n\nFor convergence testing:\n\nconvergence = BrooksGelmanConvergence()\n\nTo generate MCMC samples with explicit control over all options, use something like\n\nsamples = bat_sample(\n    posterior,\n    TransformedMCMC(\n        proposal = mcmcalgo,\n        nchains = 4,\n        nsteps = 10^5,\n        init = init,\n        burnin = burnin,\n        convergence = convergence,\n        strict = true,\n        store_burnin = false,\n        nonzero_weights = true,\n        callback = (x...) -> nothing\n    ),\n    context\n).result\nnothing # hide","category":"section"},{"location":"tutorial/#Saving-result-data-to-files","page":"Tutorial","title":"Saving result data to files","text":"The package FileIO.jl(in conjunction with JLD2.jl) offers a convenient way to store results like posterior samples to file:\n\nusing FileIO\nimport JLD2\nFileIO.save(\"results.jld2\", Dict(\"samples\" => samples))\n\nJLD2 persists the full information (including value shapes), so you can reload exactly the same data into memory in a new Julia session via\n\nusing FileIO\nimport JLD2\nsamples = FileIO.load(\"results.jld2\", \"samples\")\n\nprovided you use compatible versions of BAT and it's dependencies. Note that JLD2 is not a long-term stable file format. Also note that this functionality is provided by FileIO.jl and JLD2.jl and not part of the BAT API itself.\n\nBAT.jl itself can write samples to standard HDF5 files in a form suitable for long-term storage (via HDF5.jl):\n\nimport HDF5\nbat_write(\"results.h5\", samples)\n\nThe resulting files have an intuitive HDF5 layout and can be read with the standard HDF5 libraries, so they are easily accessible from other programming languages as well. Not all value shape information can be preserved, though. To read BAT.jl HDF5 sample data, use\n\nusing BAT\nimport HDF5\nsamples = bat_read(\"results.h5\").result\n\nBAT.jl's HDF5 file format may evolve over time, but future versions of BAT.jl will be able to read HDF5 sample data written by this version of BAT.jl.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
