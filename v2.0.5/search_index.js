var documenterSearchIndex = {"docs":
[{"location":"developing/#Developer-Instructions","page":"Developer instructions","title":"Developer Instructions","text":"","category":"section"},{"location":"developing/#Documentation-Generation","page":"Developer instructions","title":"Documentation Generation","text":"","category":"section"},{"location":"developing/","page":"Developer instructions","title":"Developer instructions","text":"To generate and view a local version of the documentation, run","category":"page"},{"location":"developing/","page":"Developer instructions","title":"Developer instructions","text":"cd docs\njulia make.jl local","category":"page"},{"location":"developing/","page":"Developer instructions","title":"Developer instructions","text":"then open \"docs/build/index.html\" in your browser.","category":"page"},{"location":"developing/#Code-Reloading","page":"Developer instructions","title":"Code Reloading","text":"","category":"section"},{"location":"developing/","page":"Developer instructions","title":"Developer instructions","text":"When changing the code of BAT.jl and testing snippets and examples in the REPL, automatic code reloading comes in very handy. Try out Revise.jl.","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"stable_api/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"stable_api/","page":"API Documentation","title":"API Documentation","text":"This is the stable public API of BAT. Forward/backward compatibility follows Julia's semantic versioning rules.","category":"page"},{"location":"stable_api/","page":"API Documentation","title":"API Documentation","text":"DocTestSetup  = quote\n    using BAT\nend","category":"page"},{"location":"stable_api/#Types","page":"API Documentation","title":"Types","text":"","category":"section"},{"location":"stable_api/","page":"API Documentation","title":"API Documentation","text":"Pages = [\"stable_api.md\"]\nOrder = [:type]","category":"page"},{"location":"stable_api/#Functions-and-macros","page":"API Documentation","title":"Functions and macros","text":"","category":"section"},{"location":"stable_api/","page":"API Documentation","title":"API Documentation","text":"Pages = [\"stable_api.md\"]\nOrder = [:macro, :function]","category":"page"},{"location":"stable_api/#Documentation","page":"API Documentation","title":"Documentation","text":"","category":"section"},{"location":"stable_api/","page":"API Documentation","title":"API Documentation","text":"logvalof\n\nbat_default\nbat_eff_sample_size\nbat_findmedian\nbat_findmode\nbat_initval\nbat_integrate\nbat_integrated_autocorr_len\nbat_read\nbat_sample\nbat_write\nladjof\ntrafoof\n\nBAT.fft_autocor\nBAT.fft_autocov\nBAT.eval_logval_unchecked\n\nAbstractDensity\nAbstractDensityTransformTarget\nAbstractMCMCWeightingScheme\nAbstractPosteriorDensity\nAbstractTransformedDensity\nAbstractTransformToInfinite\nAbstractTransformToUnitspace\nAbstractVariateTransform\nAdaptiveMHTuning\nAHMIntegration\nAnyDensityLike\nAnyIIDSampleable\nAnySampleable\nARPWeighting\nAutocorLenAlgorithm\nbat_transform\nBrooksGelmanConvergence\nCholeskyPartialWhitening\nCholeskyWhitening\nDensityIdentityTransform\nDensitySample\nDensitySampleVector\nDistLikeDensity\nEffSampleSizeAlgorithm\nEffSampleSizeFromAC\nExplicitInit\nFullDensityTransform\nGelmanRubinConvergence\nGeyerAutocorLen\nHamiltonianMC\nIIDSampling\nInitFromIID\nInitFromSamples\nInitFromTarget\nInitvalAlgorithm\nIntegrationAlgorithm\nLogDVal\nMaxDensityLBFGS\nMaxDensityNelderMead\nMaxDensitySampleSearch\nMCMCAlgorithm\nMCMCBurninAlgorithm\nMCMCChainPoolInit\nMCMCConvergenceTest\nMCMCInitAlgorithm\nMCMCIterator\nMCMCMultiCycleBurnin\nMCMCNoOpTuning\nMCMCSampling\nMCMCTuningAlgorithm\nMetropolisHastings\nMHProposalDistTuning\nModeAsDefined\nNoDensityTransform\nNoWhitening\nOrderedResampling\nPosteriorDensity\nPriorSubstitution\nPriorToGaussian\nPriorToUniform\nRandResampling\nRepetitionWeighting\nSampledDensity\nSokalAutocorLen\nStatisticalWhitening\nTransformAlgorithm\nWhiteningAlgorithm\n\nBAT.AbstractModeEstimator\nBAT.AbstractSamplingAlgorithm\nBAT.GenericDensity\n\nValueShapes.totalndof\nValueShapes.varshape","category":"page"},{"location":"stable_api/#BAT.logvalof","page":"API Documentation","title":"BAT.logvalof","text":"logvalof(r::NamedTuple{(...,:log,...)})::Real\nlogvalof(r::LogDVal)::Real\n\nExtract the log-density value from a result r.\n\nExamples:\n\nlogvalof((..., log = log_value, ...)) == log_value\nlogvalof(LogDVal(log_value)) == log_value\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_default","page":"API Documentation","title":"BAT.bat_default","text":"bat_default(f::Base.Callable, argname::Symbol, objective...)\nbat_default(f::Base.Callable, argname::Val, objective...)\n\nGet the default value for argument argname of function f to use for objective(s).\n\nobjective(s) are mandatory arguments of function f that semantically constitute it's main objective(s), and that that a good default choice of optional arguments (e.g. choice of algorithm(s), etc.) may depend on. Which arguments are considered to be objectives is function-specific.\n\nFor example:\n\nbat_default(bat_sample, :algorithm, density::PosteriorDensity) == MetropolisHastings()\nbat_default(bat_sample, Val(:algorithm), samples::DensitySampleVector) == OrderedResampling()\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_eff_sample_size","page":"API Documentation","title":"BAT.bat_eff_sample_size","text":"bat_eff_sample_size(\n    v::Union{AbstractVector{<:Real},AbstractVectorOfSimilarVectors{<:Real}},\n    [algorithm::EffSampleSizeAlgorithm]\n)\n\nbat_eff_sample_size(\n    smpls::DensitySampleVector,\n    [algorithm::EffSampleSizeAlgorithm]\n)\n\nEstimate effective sample size estimation for variate series v, resp. density samples smpls, separately for each degree of freedom.\n\nReturns a NamedTuple of the shape\n\n(result = eff_sample_size, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_eff_sample_size, add methods to bat_eff_sample_size_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_findmedian","page":"API Documentation","title":"BAT.bat_findmedian","text":"bat_findmedian(\n    samples::DensitySampleVector\n)\n\nThe function computes the median of marginalized samples.\n\nReturns a NamedTuple of the shape\n\n(result = v, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_findmedian, add methods to bat_findmedian_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_findmode","page":"API Documentation","title":"BAT.bat_findmode","text":"bat_findmode(\n    target::BAT.AnySampleable,\n    [algorithm::BAT.AbstractModeEstimator]\n)::DensitySampleVector\n\nEstimate the global mode of target.\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_findmode, add methods to bat_findmode_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_initval","page":"API Documentation","title":"BAT.bat_initval","text":"bat_initval(\n    [rng::AbstractRNG,]\n    target::BAT.AnyDensityLike,\n    [algorithm::BAT.InitvalAlgorithm],\n)::V\n\nbat_initval(\n    [rng::AbstractRNG,]\n    target::BAT.AnyDensityLike,\n    n::Integer,\n    [algorithm::BAT.InitvalAlgorithm],\n)::AbstractVector{<:V}\n\nGenerate one or n random initial/starting value(s) suitable for target.\n\nAssuming the variates of target are of type T, returns a NamedTuple of the shape\n\n(result = X::AbstractVector{T}, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_initval, add methods likebat_initval_impl(rng::AbstractRNG, target::AnyDensityLike, algorithm::InitvalAlgorithm; kwargs...)\nbat_initval_impl(rng::AbstractRNG, target::AnyDensityLike, n::Integer, algorithm::InitvalAlgorithm; kwargs...)to bat_initval_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_integrate","page":"API Documentation","title":"BAT.bat_integrate","text":"bat_integrate(\n    target::AnySampleable,\n    [algorithm::IntegrationAlgorithm]\n)::DensitySampleVector\n\nCalculate the integral (evidence) of target.\n\nReturns a NamedTuple of the shape\n\n(result = X::Measurements.Measurement, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_integrate, add methods to bat_integrate_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_integrated_autocorr_len","page":"API Documentation","title":"BAT.bat_integrated_autocorr_len","text":"bat_integrated_autocorr_len(\n    v::Union{AbstractVector{<:Real},AbstractVectorOfSimilarVectors{<:Real}},\n    algorithm::AutocorLenAlgorithm = GeyerAutocorLen()\n)\n\nEstimate the integrated autocorrelation length of variate series v, separately for each degree of freedom.\n\nReturns a NamedTuple of the shape\n\n(result = integrated_autocorr_len, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_integrated_autocorr_len, add methods to bat_integrated_autocorr_len_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_read","page":"API Documentation","title":"BAT.bat_read","text":"bat_read(filename::AbstractString, data)\nbat_read(fn_with_subpath::Tuple{AbstractString, AbstractString}, data)\n\nRead data from a file filename, resp. from an internal sub-path of the file (if supported by the file format), e.g. an HDF5 group.\n\nCurrently supported file formats are:\n\nHDF5 with file extension \".h5\" or \".hdf5\"\n\nnote: Note\nHDF5 I/O functionality is only available when the HDF5 package is loaded (e.g. via import HDF5).\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_sample","page":"API Documentation","title":"BAT.bat_sample","text":"bat_sample(\n    [rng::AbstractRNG],\n    target::BAT.AnySampleable,\n    [algorithm::BAT.AbstractSamplingAlgorithm]\n)::DensitySampleVector\n\nDraw samples from target using algorithm.\n\nDepending on sampling algorithm, the samples may be independent or correlated (e.g. when using MCMC).\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_sample, add methods to bat_sample_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_write","page":"API Documentation","title":"BAT.bat_write","text":"bat_write(filename::AbstractString, data)\nbat_write(fn_with_subpath::Tuple{AbstractString, AbstractString}, data)\n\nWrite data to a file filename, resp. to an internal sub-path of the file (if supported by the file format), e.g. an HDF5 group.\n\nCurrently supported file formats are:\n\nHDF5 with file extension \".h5\" or \".hdf5\"\n\nnote: Note\nHDF5 I/O functionality is only available when the HDF5 package is loaded (e.g. via import HDF5).\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.ladjof","page":"API Documentation","title":"BAT.ladjof","text":"ladjof(r::NamedTuple{(...,:ladj,...)})::Real\n\nExtract the log(abs(det(jacobian))) value that is part of a result r.\n\nExamples:\n\nladjof((..., ladj = some_ladj, ...)) == some_ladj\nladjof(trafo)(v) = trafo(v, )\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.trafoof","page":"API Documentation","title":"BAT.trafoof","text":"trafoof(d::AbstractTransformedDensity)::AbstractDensity\n\nGet the transform from parent(d) to d, so that\n\ntrafoof(d)(parent(d)) == d\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.fft_autocor","page":"API Documentation","title":"BAT.fft_autocor","text":"fft_autocor(v::AbstractVector{<:Real})\nfft_autocor(v::AbstractVectorOfSimilarVectors{<:Real})\n\nCompute the autocorrelation function (ACF) of variate series v, separately for each degree of freedom.\n\nUses FFT, in contract to StatsBase.autocor.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.fft_autocov","page":"API Documentation","title":"BAT.fft_autocov","text":"fft_autocov(v::AbstractVector{<:Real})\nfft_autocov(v::AbstractVectorOfSimilarVectors{<:Real})\n\nCompute the autocovariance of of variate series v, separately for each degree of freedom.\n\nUses FFT, in contract to StatsBase.autocov.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.eval_logval_unchecked","page":"API Documentation","title":"BAT.eval_logval_unchecked","text":"BAT.eval_logval_unchecked(density::AbstractDensity, v::Any)\n\nCompute log of the value of a multivariate density function for the given variate/parameter-values.\n\nInput:\n\ndensity: density function\nv: argument, i.e. variate / parameter-values\n\nNote: If eval_logval_unchecked is called with an argument that is out of bounds, the behavior is undefined. The result for arguments that are not within bounds is implicitly -Inf, but it is the caller's responsibility to handle these cases.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.AbstractDensity","page":"API Documentation","title":"BAT.AbstractDensity","text":"abstract type AbstractDensity\n\nSubtypes of AbstractDensity must implement the function\n\nBAT.eval_logval_unchecked\n\nFor likelihood densities this is typically sufficient, since shape, and variate bounds will be inferred from the prior.\n\nDensities with a known variate shape may also implement\n\nValueShapes.varshape\n\nDensities with known variate bounds may also implement\n\nBAT.var_bounds\n\nnote: Note\nThe function BAT.var_bounds is not part of the stable public BAT-API, it's name and arguments may change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractDensityTransformTarget","page":"API Documentation","title":"BAT.AbstractDensityTransformTarget","text":"abstract type AbstractDensityTransformTarget\n\nAbstract type for probability density transformation targets.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractMCMCWeightingScheme","page":"API Documentation","title":"BAT.AbstractMCMCWeightingScheme","text":"abstract type AbstractMCMCWeightingScheme{T<:Real}\n\nAbstract class for weighting schemes for MCMC samples.\n\nWeight values will have type T.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractPosteriorDensity","page":"API Documentation","title":"BAT.AbstractPosteriorDensity","text":"abstract type AbstractPosteriorDensity <: AbstractDensity end\n\nAbstract type for posterior probability densities.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractTransformedDensity","page":"API Documentation","title":"BAT.AbstractTransformedDensity","text":"TransformedDensity <: AbstractDensity\n\nAbstract type for transformed densities.\n\nIn addition to the AbstractDensity interface, subtypes must support the functions Base.parent and trafoof:\n\nparent(d::SomeTransformedDensity)::AbstractDensity\ntrafoof(d::SomeTransformedDensity)::AbstractVariateTransform\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractTransformToInfinite","page":"API Documentation","title":"BAT.AbstractTransformToInfinite","text":"abstract type AbstractTransformToInfinite <: AbstractDensityTransformTarget\n\nAbstract type for density transformation targets that specify are transformation into unbounded space.\n\nThe density that results from such a transformation must be unbounded in all dimensions and that should taper off to zero somewhat smoothly in any direction.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractTransformToUnitspace","page":"API Documentation","title":"BAT.AbstractTransformToUnitspace","text":"abstract type AbstractTransformToUnitspace <: AbstractDensityTransformTarget\n\nAbstract type for density transformation targets that specify a transformation into the unit hypercube.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractVariateTransform","page":"API Documentation","title":"BAT.AbstractVariateTransform","text":"abstract type AbstractVariateTransform <: Function\n\nAbstract type for change-of-variables transformations.\n\nSubtypes (e.g. SomeTrafo <: AbstractVariateTransform) must support (with trafo::SomeTrafo):\n\n    (trafo)(v_prev::SomeVariate) == v_new\n    (trafo)(v_prev::SomeVariate, ladj_prev::Real)) == (v = v_new, ladj = ladj_new)\n    (trafo)(s_prev::DensitySample)::DensitySample\n    ((trafo2 ∘ trafo1)(v)::AbstractVariateTransform)(v) == trafo2(trafo1(v))\n    inv(trafo)(trafo(v)) == v\n    inv(inv(trafo)) == trafo\n\n    ValueShapes.varshape(trafo)::ValueShapes.AbstractValueShape\n\nwith varshape(v_prev) == varshape(trafo).\n\nladj must be logabsdet(jacobian(trafo, v)).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AdaptiveMHTuning","page":"API Documentation","title":"BAT.AdaptiveMHTuning","text":"struct AdaptiveMHTuning <: MHProposalDistTuning\n\nAdaptive MCMC tuning strategy for Metropolis-Hastings samplers.\n\nAdapts the proposal function based on the acceptance ratio and covariance of the previous samples.\n\nConstructors:\n\nAdaptiveMHTuning(; fields...)\n\nFields:\n\nλ::Float64\nControls the weight given to new covariance information in adapting the     proposal distribution. Default: 0.5\nα::IntervalSets.ClosedInterval{Float64}\nMetropolis-Hastings acceptance ratio target, tuning will try to adapt     the proposal distribution to bring the acceptance ratio inside this interval. Default: ClosedInterval(0.15, 0.35)\nβ::Float64\nControls how much the spread of the proposal distribution is     widened/narrowed depending on the current MH acceptance ratio. Default: 1.5\nc::IntervalSets.ClosedInterval{Float64}\nInterval for allowed scale/spread of the proposal distribution. Default: ClosedInterval(0.0001, 100.0)\nr::Real\nReweighting factor. Take accumulated sample statistics of previous     tuning cycles into account with a relative weight of r. Set to     0 to completely reset sample statistics between each tuning cycle. Default: 0.5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AHMIntegration","page":"API Documentation","title":"BAT.AHMIntegration","text":"struct AHMIntegration <: IntegrationAlgorithm\n\nAdaptive Harmonic Mean Integration algorithm (Caldwell et al.).\n\nConstructors:\n\nAHMIntegration(; fields...)\n\nFields:\n\nwhitening::WhiteningAlgorithm\nDefault: CholeskyPartialWhitening()\nautocorlen::AutocorLenAlgorithm\nDefault: GeyerAutocorLen()\nvolumetype::Symbol\nDefault: :HyperRectangle\nmax_startingIDs::Int64\nDefault: 10000\nmax_startingIDs_fraction::Float64\nDefault: 2.5\nrect_increase::Float64\nDefault: 0.1\nwarning_minstartingids::Int64\nDefault: 16\ndotrimming::Bool\nDefault: true\nuncertainty::Vector{Symbol}\nList of uncertainty estimation methods to use, first entry will be used for primary result. Valid values:\n:cov: Integral uncertainty for integration regions is estimated based on covariance of integrals of subsets of samples in the regions\n:ess: Integral uncertainty for integration regions is estimated based on estimated effective number of samples in each region.\nDefault: [:cov]\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AnyDensityLike","page":"API Documentation","title":"BAT.AnyDensityLike","text":"BAT.AnyDensityLike = Union{...}\n\nUnion of all types that BAT will accept as a probability density, resp. that convert(AbstractDenstiy, d) supports:\n\nAbstractDensity\nDistributions.Distribution\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AnyIIDSampleable","page":"API Documentation","title":"BAT.AnyIIDSampleable","text":"BAT.AnyIIDSampleable = Union{...}\n\nUnion of all distribution/density-like types that BAT can draw i.i.d. (independent and identically distributed) samples from:\n\nDistLikeDensity\nDistributions.Distribution\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AnySampleable","page":"API Documentation","title":"BAT.AnySampleable","text":"BAT.AnySampleable = Union{...}\n\nUnion of all types that BAT can sample from:\n\nAbstractDensity\nDensitySampleVector\nDistributions.Distribution\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ARPWeighting","page":"API Documentation","title":"BAT.ARPWeighting","text":"ARPWeighting{T<:AbstractFloat} <: AbstractMCMCWeightingScheme{T}\n\nSample weighting scheme suitable for accept/reject-based sampling algorithms (e.g. MetropolisHastings). Both accepted and rejected samples become part of the output, with a weight proportional to their original acceptance probability.\n\nConstructors:\n\nARPWeighting()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AutocorLenAlgorithm","page":"API Documentation","title":"BAT.AutocorLenAlgorithm","text":"abstract type AutocorLenAlgorithm\n\nAbstract type for integrated autocorrelation length estimation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.bat_transform","page":"API Documentation","title":"BAT.bat_transform","text":"bat_transform(\n    target::AbstractDensityTransformTarget,\n    density::AnyDensityLike,\n    [algorithm::TransformAlgorithm]\n)::AbstractDensity\n\nTransform density to another variate space defined/implied by target.\n\nReturns a NamedTuple of the shape\n\n(result = newdensity::AbstractDensity, trafo = vartrafo::AbstractVariateTransform, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_transform, add methods to bat_transform_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.BrooksGelmanConvergence","page":"API Documentation","title":"BAT.BrooksGelmanConvergence","text":"struct BrooksGelmanConvergence <: MCMCConvergenceTest\n\nBrooks-Gelman maximum R^2 convergence test.\n\nConstructors:\n\nBrooksGelmanConvergence(; fields...)\n\nFields:\n\nthreshold::Float64\nDefault: 1.1\ncorrected::Bool\nDefault: false\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.CholeskyPartialWhitening","page":"API Documentation","title":"BAT.CholeskyPartialWhitening","text":"struct CholeskyPartialWhitening <: WhiteningAlgorithm\n\nWhitening transformation based on a Cholesky transformation of the empirical sample covariance matrix.\n\nOnly transforms dimensions (degrees of freedom) for which the marginalized distribution asymptotically approaches zero in the positive and negative direction.\n\nConstructors:\n\nCholeskyPartialWhitening()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.CholeskyWhitening","page":"API Documentation","title":"BAT.CholeskyWhitening","text":"struct CholeskyWhitening <: WhiteningAlgorithm\n\nWhitening transformation based on a Cholesky transformation of the empirical sample covariance matrix.\n\nConstructors:\n\nCholeskyWhitening()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DensityIdentityTransform","page":"API Documentation","title":"BAT.DensityIdentityTransform","text":"struct DensityIdentityTransform <: TransformAlgorithm\n\nA no-op density transform algorithm that leaves any density unchanged.\n\nConstructors:\n\nDensityIdentityTransform()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DensitySample","page":"API Documentation","title":"BAT.DensitySample","text":"struct DensitySample\n\nA weighted sample drawn according to an statistical density, e.g. a BAT.AbstractDensity.\n\nConstructors:\n\nDensitySampleVector(v::Any, logd::Real, weight::Real, info::Any, aux::Any)\n\nFields:\n\nv::Any\nvariate value\nlogd::Real\nlog(density) value at v\nweight::Real\nWeight of the sample\ninfo::Any\nAdditional info on the provenance of the sample. Content depends     on the sampling algorithm.\naux::Any\nCustom user-defined information attached to the sample.\n\nUse DensitySampleVector to store vectors of multiple samples with an efficient column-based memory layout.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DensitySampleVector","page":"API Documentation","title":"BAT.DensitySampleVector","text":"struct DensitySampleVector <: AbstractVector{<:DensitySample}\n\nA vector of DensitySample elements.\n\nDensitySampleVector is currently a type alias for StructArrays.StructArray{<:DensitySample,...}, though this is subject to change without deprecation.\n\nConstructors:\n\n    DensitySampleVector(\n        (\n            v::AbstractVector{<:AbstractVector{<:Real}},\n            logd::AbstractVector{<:Real},\n            weight::AbstractVector{<:Real},\n            info::AbstractVector{<:Any},\n            aux::AbstractVector{<:Any}\n        )\n    )\n\n    DensitySampleVector(\n            v::AbstractVector,\n            logval::AbstractVector{<:Real};\n            weight::Union{AbstractVector{<:Real}, Symbol} = fill(1, length(eachindex(v))),\n            info::AbstractVector = fill(nothing, length(eachindex(v))),\n            aux::AbstractVector = fill(nothing, length(eachindex(v)))\n        )\n\nWith weight = :multiplicity repeated samples will be replaced by a single sample, with a weight equal to the number of repetitions.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DistLikeDensity","page":"API Documentation","title":"BAT.DistLikeDensity","text":"abstract type DistLikeDensity <: AbstractDensity\n\nA density that implements part of the Distributions.Distribution interface. Such densities are suitable for use as a priors.\n\nTypically, custom priors should be implemented as subtypes of Distributions.Distribution. BAT will automatically wrap them in a subtype of DistLikeDensity.\n\nSubtypes of DistLikeDensity are required to support more functionality than an AbstractDensity, but less than a Distribution{Multivariate,Continuous}.\n\nA d::Distribution{Multivariate,Continuous} can be converted into (wrapped in) an DistLikeDensity via conv(DistLikeDensity, d).\n\nThe following functions must be implemented for subtypes:\n\nBAT.eval_logval_unchecked\nValueShapes.varshape\nDistributions.sampler\nStatistics.cov\nBAT.var_bounds\n\nnote: Note\nThe function BAT.var_bounds is not part of the stable public BAT-API and subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.EffSampleSizeAlgorithm","page":"API Documentation","title":"BAT.EffSampleSizeAlgorithm","text":"abstract type EffSampleSizeAlgorithm\n\nAbstract type for integrated autocorrelation length estimation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.EffSampleSizeFromAC","page":"API Documentation","title":"BAT.EffSampleSizeFromAC","text":"struct EffSampleSizeFromAC <: EffSampleSizeAlgorithm\n\nEffective sample size estimation based on the integrated autocorrelation length of the samples.\n\nConstructors:\n\nEffSampleSizeFromAC(; fields...)\n\nFields:\n\nacalg::AutocorLenAlgorithm\nDefault: GeyerAutocorLen()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ExplicitInit","page":"API Documentation","title":"BAT.ExplicitInit","text":"struct ExplicitInit <: InitvalAlgorithm\n\nUses initial values from a given vector of one or more values/variates. The values are used in the order they appear in the vector, not randomly.\n\nConstructors:\n\nExplicitInit(; fields...)\n\nFields:\n\nxs::AbstractVector{T} where T\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.FullDensityTransform","page":"API Documentation","title":"BAT.FullDensityTransform","text":"struct FullDensityTransform <: TransformAlgorithm\n\nTransform the density as a whole a given specified target space. Operations that use the gradient of the density will require to the log(abs(jacobian)) of the transformation to be auto-differentiable.\n\nConstructors:\n\nFullDensityTransform()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.GelmanRubinConvergence","page":"API Documentation","title":"BAT.GelmanRubinConvergence","text":"struct GelmanRubinConvergence <: MCMCConvergenceTest\n\nGelman-Rubin maximum R^2 convergence test.\n\nConstructors:\n\nGelmanRubinConvergence(; fields...)\n\nFields:\n\nthreshold::Float64\nDefault: 1.1\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.GeyerAutocorLen","page":"API Documentation","title":"BAT.GeyerAutocorLen","text":"struct GeyerAutocorLen <: AutocorLenAlgorithm\n\nIntegrated autocorrelation length estimation based on Geyer’s initial monotone sequence criterion\n\nSee C. J. Geyer, \"Practical Markov Chain Monte Carlo\" (1992) and C. J. Geyer, \"Introduction to Markov Chain Monte Carlo\" (2011).\n\nConstructors:\n\nGeyerAutocorLen()\n\nThe same algorithm is used by STAN (v2.21) and MCMCChains.jl (v3.0, function ess_rhat).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.HamiltonianMC","page":"API Documentation","title":"BAT.HamiltonianMC","text":"struct HamiltonianMC <: MCMCAlgorithm\n\nHamiltonian Monte Carlo sampling algorithm.\n\nThe gradient of the target density is computed via auto-differentiation.\n\nNote: The fields of HamiltonianMC are still subject to change, and not\n\nyet part of stable public API!*\n\nConstructors:\n\nHamiltonianMC(; fields...)\n\nFields:\n\nmetric::BAT.HMCMetric\nDefault: DiagEuclideanMetric()\ngradient::Module\nDefault: ForwardDiff\nintegrator::BAT.HMCIntegrator\nDefault: LeapfrogIntegrator()\nproposal::BAT.HMCProposal\nDefault: NUTS()\nadaptor::BAT.HMCAdaptor\nDefault: StanHMCAdaptor()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.IIDSampling","page":"API Documentation","title":"BAT.IIDSampling","text":"struct IIDSampling <: AbstractSamplingAlgorithm\n\nSample via Random.rand. Only supported for posteriors of type Distributions.MultivariateDistribution and BAT.DistLikeDensity.\n\nConstructors:\n\nIIDSampling(; fields...)\n\nFields:\n\nnsamples::Int64\nDefault: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitFromIID","page":"API Documentation","title":"BAT.InitFromIID","text":"struct InitFromIID <: InitvalAlgorithm\n\nGenerates initial values for sampling, optimization, etc. by random resampling from a given set of samples.\n\nConstructors:\n\nInitFromIID()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitFromSamples","page":"API Documentation","title":"BAT.InitFromSamples","text":"struct InitFromSamples <: InitvalAlgorithm\n\nGenerates initial values for sampling, optimization, etc. by direct sampling from a given i.i.d. sampleable source.\n\nConstructors:\n\nInitFromSamples()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitFromTarget","page":"API Documentation","title":"BAT.InitFromTarget","text":"struct InitFromTarget <: InitvalAlgorithm\n\nGenerates initial values for sampling, optimization, etc. by direct i.i.d. sampling a suitable component of that target density (e.g. it's prior) that supports it.\n\nIf the target is supports direct i.i.d. sampling, e.g. because it is a distribution, initial values are sampled directly from the target.\nIf the target is a posterior density, initial values are sampled from the prior (or the prior's prior if the prior is a posterior itself, etc.).\nIf the target is a sampled density, initial values are (re-)sampled from the available samples.\n\nConstructors:\n\nInitFromTarget()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitvalAlgorithm","page":"API Documentation","title":"BAT.InitvalAlgorithm","text":"abstract type BAT.InitvalAlgorithm\n\nAbstract type for BAT initial/starting value generation algorithms.\n\nMany algorithms in BAT, like MCMC and optimization, need initial/starting values.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.IntegrationAlgorithm","page":"API Documentation","title":"BAT.IntegrationAlgorithm","text":"abstract type IntegrationAlgorithm\n\nAbstract type for integration algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.LogDVal","page":"API Documentation","title":"BAT.LogDVal","text":"LogDVal{T<:Real}\n\nRepresent the logarithm of the value of a statistical density at some point. LogDVal provides means to unambiguously distinguish between linear and logarithmic values of a density.\n\nConstructor:\n\nLogDVal(logd::Real)\n\nUse logvalof to extract the actual log-density value from a LogDVal:\n\n    logvalof(LogDVal(d)) == d\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MaxDensityLBFGS","page":"API Documentation","title":"BAT.MaxDensityLBFGS","text":"struct MaxDensityLBFGS <: AbstractModeEstimator\n\nEstimates the mode of a probability density using LBFGS optimization (currently via Optim.jl, subject to change).\n\nThe gradient of the target density is computed via auto-differentiation.\n\nConstructors:\n\nMaxDensityLBFGS(; fields...)\n\nFields:\n\ntrafo::AbstractDensityTransformTarget\nDefault: PriorToGaussian()\ninit::InitvalAlgorithm\nDefault: InitFromTarget()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MaxDensityNelderMead","page":"API Documentation","title":"BAT.MaxDensityNelderMead","text":"struct MaxDensityNelderMead <: AbstractModeEstimator\n\nEstimates the mode of a probability density using Nelder-Mead optimization (currently via Optim.jl, subject to change).\n\nConstructors:\n\nMaxDensityNelderMead(; fields...)\n\nFields:\n\ntrafo::AbstractDensityTransformTarget\nDefault: NoDensityTransform()\ninit::InitvalAlgorithm\nDefault: InitFromTarget()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MaxDensitySampleSearch","page":"API Documentation","title":"BAT.MaxDensitySampleSearch","text":"MaxDensitySampleSearch <: AbstractModeEstimator\n\nConstructors:\n\nMaxDensitySampleSearch()\n\nEstimate the mode as the variate with the highest posterior density value within a given set of samples.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCAlgorithm","page":"API Documentation","title":"BAT.MCMCAlgorithm","text":"abstract type MCMCAlgorithm\n\nAbstract type for Markov chain Monte Carlo algorithms.\n\nTo implement a new MCMC algorithm, subtypes of both MCMCAlgorithm and MCMCIterator are required.\n\nnote: Note\nThe details of the MCMCIterator and MCMCAlgorithm API required to implement a new MCMC algorithm currently do not (yet) form part of the stable API and are subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCBurninAlgorithm","page":"API Documentation","title":"BAT.MCMCBurninAlgorithm","text":"abstract type MCMCBurninAlgorithm\n\nAbstract type for MCMC burn-in algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCChainPoolInit","page":"API Documentation","title":"BAT.MCMCChainPoolInit","text":"struct MCMCChainPoolInit <: MCMCInitAlgorithm\n\nMCMC chain pool initialization strategy.\n\nConstructors:\n\nMCMCChainPoolInit(; fields...)\n\nFields:\n\ninit_tries_per_chain::IntervalSets.ClosedInterval{Int64}\nDefault: ClosedInterval(8, 128)\nnsteps_init::Int64\nDefault: 1000\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCConvergenceTest","page":"API Documentation","title":"BAT.MCMCConvergenceTest","text":"abstract type MCMCConvergenceTest\n\nAbstract type for MCMC convergence testing algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCInitAlgorithm","page":"API Documentation","title":"BAT.MCMCInitAlgorithm","text":"abstract type MCMCInitAlgorithm\n\nAbstract type for MCMC initialization algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCIterator","page":"API Documentation","title":"BAT.MCMCIterator","text":"abstract type MCMCIterator end\n\nRepresents the current state of an MCMC chain.\n\nnote: Note\nThe details of the MCMCIterator and MCMCAlgorithm API (see below) currently do not form part of the stable API and are subject to change without deprecation.\n\nTo implement a new MCMC algorithm, subtypes of both MCMCAlgorithm and MCMCIterator are required.\n\nThe following methods must be defined for subtypes of MCMCIterator (e.g. SomeMCMCIter<:MCMCIterator):\n\nBAT.getalgorithm(chain::SomeMCMCIter)::MCMCAlgorithm\n\nBAT.getdensity(chain::SomeMCMCIter)::AbstractDensity\n\nBAT.getrng(chain::SomeMCMCIter)::AbstractRNG\n\nBAT.mcmc_info(chain::SomeMCMCIter)::MCMCIteratorInfo\n\nBAT.nsteps(chain::SomeMCMCIter)::Int\n\nBAT.nsamples(chain::SomeMCMCIter)::Int\n\nBAT.current_sample(chain::SomeMCMCIter)::DensitySample\n\nBAT.sample_type(chain::SomeMCMCIter)::Type{<:DensitySample}\n\nBAT.samples_available(chain::SomeMCMCIter, nonzero_weights::Bool = false)::Bool\n\nBAT.get_samples!(samples::DensitySampleVector, chain::SomeMCMCIter, nonzero_weights::Bool)::typeof(samples)\n\nBAT.next_cycle!(chain::SomeMCMCIter)::SomeMCMCIter\n\nBAT.mcmc_step!(\n    chain::SomeMCMCIter\n    callback::Function,\n)::nothing\n\nThe following methods are implemented by default:\n\ngetalgorithm(chain::MCMCIterator)\ngetdensity(chain::MCMCIterator)\nDensitySampleVector(chain::MCMCIterator)\nmcmc_iterate!(chain::MCMCIterator, ...)\nmcmc_iterate!(chains::AbstractVector{<:MCMCIterator}, ...)\nisvalidchain(chain::MCMCIterator)\nisviablechain(chain::MCMCIterator)\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCMultiCycleBurnin","page":"API Documentation","title":"BAT.MCMCMultiCycleBurnin","text":"struct MCMCMultiCycleBurnin <: MCMCBurninAlgorithm\n\nA multi-cycle MCMC burn-in algorithm.\n\nConstructors:\n\nMCMCMultiCycleBurnin(; fields...)\n\nFields:\n\nnsteps_per_cycle::Int64\nDefault: 10000\nmax_ncycles::Int64\nDefault: 30\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCNoOpTuning","page":"API Documentation","title":"BAT.MCMCNoOpTuning","text":"MCMCNoOpTuning <: MCMCTuningAlgorithm\n\nNo-op tuning, marks MCMC chains as tuned without performing any other changes on them. Useful if chains are pre-tuned or tuning is an internal part of the MCMC sampler implementation.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCSampling","page":"API Documentation","title":"BAT.MCMCSampling","text":"struct MCMCSampling <: AbstractSamplingAlgorithm\n\nSamples a probability density using Markov chain Monte Carlo.\n\nConstructors:\n\nMCMCSampling(; fields...)\n\nFields:\n\nmcalg::MCMCAlgorithm\nDefault: MetropolisHastings()\ntrafo::AbstractDensityTransformTarget\nDefault: bat_default(MCMCSampling, Val(:trafo), mcalg)\nnchains::Int64\nDefault: 4\nnsteps::Int64\nDefault: bat_default(MCMCSampling, Val(:nsteps), mcalg, trafo, nchains)\ninit::MCMCInitAlgorithm\nDefault: MCMCChainPoolInit(nsteps_init = max(div(nsteps, 100), 250))\nburnin::MCMCBurninAlgorithm\nDefault: MCMCMultiCycleBurnin(nstepspercycle = max(div(nsteps, 10), 2500))\nconvergence::MCMCConvergenceTest\nDefault: BrooksGelmanConvergence()\nstrict::Bool\nDefault: true\nstore_burnin::Bool\nDefault: false\nnonzero_weights::Bool\nDefault: true\ncallback::Function\nDefault: nop_func\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCTuningAlgorithm","page":"API Documentation","title":"BAT.MCMCTuningAlgorithm","text":"abstract type MCMCTuningAlgorithm\n\nAbstract type for MCMC tuning algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MetropolisHastings","page":"API Documentation","title":"BAT.MetropolisHastings","text":"struct MetropolisHastings <: MCMCAlgorithm\n\nMetropolis-Hastings MCMC sampling algorithm.\n\nConstructors:\n\nMetropolisHastings(; fields...)\n\nFields:\n\nproposal::BAT.ProposalDistSpec\nDefault: MvTDistProposal()\nweighting::AbstractMCMCWeightingScheme\nDefault: RepetitionWeighting()\ntuning::MHProposalDistTuning\nDefault: AdaptiveMHTuning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MHProposalDistTuning","page":"API Documentation","title":"BAT.MHProposalDistTuning","text":"abstract type MHProposalDistTuning\n\nAbstract type for Metropolis-Hastings tuning strategies for proposal distributions.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ModeAsDefined","page":"API Documentation","title":"BAT.ModeAsDefined","text":"struct ModeAsDefined <: AbstractModeEstimator\n\nGet the mode as defined by the density, resp. the underlying distribution (if available), via StatsBase.mode.\n\nConstructors:\n\nModeAsDefined()        \n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.NoDensityTransform","page":"API Documentation","title":"BAT.NoDensityTransform","text":"struct NoDensityTransform <: AbstractDensityTransformTarget\n\nThe identity density transformation target, specifies that densities should not be transformed.\n\nConstructors:\n\nNoDensityTransform()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.NoWhitening","page":"API Documentation","title":"BAT.NoWhitening","text":"struct NoWhitening <: WhiteningAlgorithm\n\nNo-op whitening transformation, leaves samples unchanged.\n\nConstructors:\n\nNoWhitening()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.OrderedResampling","page":"API Documentation","title":"BAT.OrderedResampling","text":"struct OrderedResampling <: AbstractSamplingAlgorithm\n\nEfficiently resamples from a given series of samples, keeping the order of samples.\n\nCan be used to efficiently convert weighted samples into samples with unity weights.\n\nConstructors:\n\nOrderedResampling(; fields...)\n\nFields:\n\nnsamples::Int64\nDefault: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PosteriorDensity","page":"API Documentation","title":"BAT.PosteriorDensity","text":"struct PosteriorDensity{\n    Li<:AbstractDensity,\n    Pr<:DistLikeDensity,\n    ...\n} <: AbstractPosteriorDensity\n\nA representation of a PosteriorDensity, based a likelihood and prior. Likelihood and prior be accessed via\n\ngetlikelihood(posterior::PosteriorDensity)::Li\ngetprior(posterior::PosteriorDensity)::Pr\n\nConstructors:\n\nPosteriorDensity(likelihood, prior)\n\nlikelihood and prior must be convertible to an AbstractDensity.\n\nFields:\n\nlikelihood::AbstractDensity\nprior::AbstractDensity\nparbounds::BAT.AbstractVarBounds\nparshapes::AbstractValueShape\n\nnote: Note\nFields parbounds and parbounds do not form part of the stable public API and are subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PriorSubstitution","page":"API Documentation","title":"BAT.PriorSubstitution","text":"struct PriorSubstitution <: TransformAlgorithm\n\nSubstitute the prior by a given distribution and transform the likelihood accordingly. The log(abs(jacobian)) of the transformation does not need to be auto-differentiable even for operations that use the gradient of the posterior.\n\nConstructors:\n\nPriorSubstitution()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PriorToGaussian","page":"API Documentation","title":"BAT.PriorToGaussian","text":"struct PriorToGaussian <: AbstractTransformToInfinite\n\nSpecifies that posterior densities should be transformed in a way that makes their pior equivalent to a standard multivariate normal distribution with an identity covariance matrix.\n\nConstructors:\n\nPriorToGaussian()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PriorToUniform","page":"API Documentation","title":"BAT.PriorToUniform","text":"struct PriorToUniform <: AbstractTransformToUnitspace\n\nSpecifies that posterior densities should be transformed in a way that makes their pior equivalent to a uniform distribution over the unit hypercube.\n\nConstructors:\n\nPriorToUniform()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RandResampling","page":"API Documentation","title":"BAT.RandResampling","text":"struct RandResampling <: AbstractSamplingAlgorithm\n\nResamples from a given set of samples.\n\nConstructors:\n\nRandResampling(; fields...)\n\nFields:\n\nnsamples::Int64\nDefault: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RepetitionWeighting","page":"API Documentation","title":"BAT.RepetitionWeighting","text":"struct RepetitionWeighting{T<:AbstractFloat} <: AbstractMCMCWeightingScheme{T}\n\nSample weighting scheme suitable for sampling algorithms which may repeated samples multiple times in direct succession (e.g. MetropolisHastings). The repeated sample is stored only once, with a weight equal to the number of times it has been repeated (e.g. because a Markov chain has not moved during a sampling step).\n\nConstructors:\n\nRepetitionWeighting()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SampledDensity","page":"API Documentation","title":"BAT.SampledDensity","text":"struct SampledDensity\n\nStores a density and samples drawn from it.\n\nA report on the density, samples, properties of variates/parameters, etc. can be generated via Base.show.\n\nConstructors:\n\nSampledDensity(density::AbstractPosteriorDensity, samples::DensitySampleVector)\n\nFields:\n\ndensity::AbstractDensity\nsamples::DensitySamplesVector\n_stats::BAT.MCMCBasicStats\n_generator::AbstractSampleGenerator\n\nnote: Note\nFields _stats and _generator do not form part of the stable public API and are subject to change without deprecation.\n\nThis type is likely to evolve into a subtype of AbstractDensity in future versions.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SokalAutocorLen","page":"API Documentation","title":"BAT.SokalAutocorLen","text":"struct SokalAutocorLen <: AutocorLenAlgorithm\n\nIntegrated autocorrelation length estimation based on the automated windowing procedure descibed in A. D. Sokal, \"Monte Carlo Methods in Statistical Mechanics\" (1996)\n\nSame procedure is used by the emcee Python package (v3.0).\n\nConstructors:\n\nSokalAutocorLen(; fields...)\n\nFields:\n\nc::Int64\nStep size for window search Default: 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.StatisticalWhitening","page":"API Documentation","title":"BAT.StatisticalWhitening","text":"struct StatisticalWhitening <: WhiteningAlgorithm\n\nWhitening transformation based statistical whitening. CholeskyPartialWhitening\n\nConstructors:\n\nStatisticalWhitening()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.TransformAlgorithm","page":"API Documentation","title":"BAT.TransformAlgorithm","text":"abstract type TransformAlgorithm\n\nAbstract type for density transformation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.WhiteningAlgorithm","page":"API Documentation","title":"BAT.WhiteningAlgorithm","text":"abstract type WhiteningAlgorithm\n\nAbstract type for sample whitening algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractModeEstimator","page":"API Documentation","title":"BAT.AbstractModeEstimator","text":"abstract type BAT.AbstractModeEstimator\n\nAbstract type for BAT optimization algorithms.\n\nA typical application for optimization in BAT is mode estimation (see bat_findmode),\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractSamplingAlgorithm","page":"API Documentation","title":"BAT.AbstractSamplingAlgorithm","text":"abstract type BAT.AbstractSamplingAlgorithm\n\nAbstract type for BAT sampling algorithms. See bat_sample.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.GenericDensity","page":"API Documentation","title":"BAT.GenericDensity","text":"GenericDensity{F<:Function} <: AbstractDensity\n\nConstructors:\n\nGenericDensity(f)\n\nTurns the density function f into a BAT-compatible AbstractDensity. The return type of f(v) must supported by logvalof.\n\nIt must be safe to execute f in parallel on multiple threads and processes.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#ValueShapes.totalndof","page":"API Documentation","title":"ValueShapes.totalndof","text":"ValueShapes.totalndof(density::AbstractDensity)::Union{Int,Missing}\n\nGet the number of degrees of freedom of the variates of density. May return missing, if the shape of the variates is not fixed.\n\n\n\n\n\nValueShapes.totalndof(density::DistLikeDensity)::Int\n\nGet the number of degrees of freedom of the variates of density. Must not be missing, a DistLikeDensity must have a fixed variate shape.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#ValueShapes.varshape","page":"API Documentation","title":"ValueShapes.varshape","text":"ValueShapes.varshape(\n    density::AbstractDensity\n)::Union{ValueShapes.AbstractValueShape,Missing}\n\nValueShapes.varshape(\n    density::DistLikeDensity\n)::ValueShapes.AbstractValueShape\n\nGet the shapes of the variates of density.\n\nFor prior densities, the result must not be missing, but may be nothing if the prior only supports unshaped variate/parameter vectors.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"note: Note\nThis is the documentation of BAT's internal API. The internal API is fully accessible to users, but all aspects of it are subject to change without deprecation. Functionalities of the internal API that, over time, turn out to require user access (e.g. to support advanced use cases) will be evolved to gain a stable interface and then promoted to the public API.","category":"page"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"DocTestSetup  = quote\n    using BAT\nend","category":"page"},{"location":"internal_api/#Types","page":"Internal API","title":"Types","text":"","category":"section"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"Pages = [\"internal_api.md\"]\nOrder = [:type]","category":"page"},{"location":"internal_api/#Functions-and-macros","page":"Internal API","title":"Functions and macros","text":"","category":"section"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"Pages = [\"internal_api.md\"]\nOrder = [:macro, :function]","category":"page"},{"location":"internal_api/#Documentation","page":"Internal API","title":"Documentation","text":"","category":"section"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"BAT.AbstractProposalDist\nBAT.AbstractSampleGenerator\nBAT.BasicMvStatistics\nBAT.DataSet\nBAT.HMIData\nBAT.HMISettings\nBAT.IntegrationVolume\nBAT.KDTreePartitioning\nBAT.MCMCSampleGenerator\nBAT.NamedTupleTransform\nBAT.OnlineMvCov\nBAT.OnlineMvMean\nBAT.OnlineUvMean\nBAT.OnlineUvVar\nBAT.PointCloud\nBAT.SearchResult\nBAT.SpacePartTree\nBAT.StandardMvNormal\nBAT.StandardMvUniform\nBAT.StandardUvNormal\nBAT.StandardUvUniform\nBAT.TransformedDensity\nBAT.TruncatedDensity\nBAT.VariateSpace\nBAT.VariateTransform\nBAT.WhiteningResult\n\nBAT.argchoice_msg\nBAT.bat_sampler\nBAT.bg_R_2sqr\nBAT.create_hypercube\nBAT.create_hyperrectangle\nBAT.density_logval_type\nBAT.proposaldist_logpdf\nBAT.drop_low_weight_samples\nBAT.eval_gradlogval\nBAT.eval_logval\nBAT.find_hypercube_centers\nBAT.find_marginalmodes\nBAT.fromuhc\nBAT.fromuhc!\nBAT.fromui\nBAT.get_bin_centers\nBAT.getlikelihood\nBAT.getprior\nBAT.gr_Rsqr\nBAT.hm_init\nBAT.hm_integrate!\nBAT.hm_whiteningtransformation!\nBAT.hyperrectangle_creationproccess!\nBAT.integrate_hyperrectangle_cov\nBAT.is_log_zero\nBAT.issymmetric_around_origin\nBAT.log_volume\nBAT.log_zero_density\nBAT.modify_hypercube!\nBAT.modify_integrationvolume!\nBAT.partition_space\nBAT.proposal_rand!\nBAT.reduced_volume_hm\nBAT.repetition_to_weights\nBAT.spatialvolume\nBAT.sum_first_dim\nBAT.trunc_logpdf_ratio\nBAT.truncate_density\nBAT.truncate_dist_hard\nBAT.var_bounds","category":"page"},{"location":"internal_api/#BAT.AbstractProposalDist","page":"Internal API","title":"BAT.AbstractProposalDist","text":"abstract type AbstractProposalDist\n\nBAT-internal, not part of stable public API.\n\nThe following functions must be implemented for subtypes:\n\nBAT.proposaldist_logpdf\nBAT.proposal_rand!\nValueShapes.totalndof, returning the number of DOF (i.e. dimensionality).\nLinearAlgebra.issymmetric, indicating whether p(a -> b) == p(b -> a) holds true.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.AbstractSampleGenerator","page":"Internal API","title":"BAT.AbstractSampleGenerator","text":"abstract type AbstractSampleGenerator\n\nBAT-internal, not part of stable public API.\n\nAbstract super type for sample generators.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BasicMvStatistics","page":"Internal API","title":"BAT.BasicMvStatistics","text":"BasicMvStatistics{T<:Real,W}\n\nBAT-internal, not part of stable public API.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.DataSet","page":"Internal API","title":"BAT.DataSet","text":"DataSet{T<:AbstractFloat, I<:Integer}\n\nAHMI-internal, not part of stable public API.\n\nHolds the MCMC output. For construction use constructor: function DataSet{T<:Real}(data::Matrix{T}, logprob::Vector{T}, weights::Vector{T})\n\nVariables\n\n'data' : An P x N array with N data points with P parameters.\n'logprob' : The logarithmic probability for each samples stored in an array\n'weights' : How often each sample occurred. Set to an array of ones if working directly on MCMC output\n'ids' : Array which is used to assign each sample to a batch, required for the cov. weighed uncertainty estimation\n.sortids : an array of indices which stores the original ordering of the samples (the space partitioning tree reorders the samples), required to calculate an effective sample size.\n'N' : number of samples\n'P' : number of parameters\n'nsubsets' : the number of batches\n'iswhitened' : a boolean value which indicates whether the data set is iswhitened\n'isnew' : a boolean value which indicates whether the data set was swapped out with a different one (it is possible to redo the integration with a different sample set using previously generated hyper-rectangles)\n'partitioningtree' : The space partitioning tree, used to efficiently identify samples in a point cloud\n'startingIDs' : The Hyper-Rectangle Seed Samples are stored in this array\n'tolerance' : A threshold required for the hyper-rectangle creation process.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.HMIData","page":"Internal API","title":"BAT.HMIData","text":"HMIData{T<:AbstractFloat, I<:Integer}\n\nAHMI-internal, not part of stable public API.\n\nIncludes all the informations of the integration process, including a list of hyper-rectangles, the results of the whitening transformation, the starting ids, and the average number of points and volume of the created hyper-rectangles.\n\nVariables\n\n'dataset1' : Data Set 1\n'dataset2' : Data Set 2\n'whiteningresult' : contains the whitening matrix and its determinant, required to scale the final integral estimate\n'volumelist1' : An array of integration volumes created using dataset1, but filled with samples from dataset2\n'volumelist2' : An array of integration volumes created using dataset2, but filled with samples from dataset1\n'cubelist1' : An array of small hyper-cubes created around seeding samples of dataset 1\n'cubelist2' : An array of small hyper-cubes created around seeding samples of dataset 2\n'iterations1' : The number of volume adapting iterations for the creating volumelist1\n'iterations2' : The number of volume adapting iterations for the creating volumelist2\n'rejectedrects1' : An array of ids, indicating which hyper-rectangles of volumelist1 were rejected due to trimming\n'rejectedrects2' : An array of ids, indicating which hyper-rectangles of volumelist2 were rejected due to trimming\n'integralestimates' : A dictionary containing the final integral estimates with uncertainty estimation using different uncertainty estimators. Also includes all intermediate results required for the integral estimate combination\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.HMISettings","page":"Internal API","title":"BAT.HMISettings","text":"HMISettings\n\nAHMI-internal, not part of stable public API.\n\nholds the settings for the hm_integrate function. There are several default constructors available: HMIFastSettings() HMIStandardSettings() HMIPrecisionSettings()\n\n#Variables\n\n'whitening_method::Symbol' : which whitening method to use\n'max_startingIDs::Integer' : influences how many starting ids are allowed to be generated\n'maxstartingIDsfraction::AbstractFloat' : how many points are considered as possible starting points as a fraction of total points available\n'rect_increase::AbstractFloat' : describes the procentual rectangle volume increase/decrease during hyperrectangle creation. Low values can increase the precision if enough points are available but can cause systematically wrong results if not enough points are available.\n'useallrects::Bool' : All rectangles are used for the integration process no matter how big their overlap is. If enabled the rectangles are weighted by their overlap.\n'useMultiThreading' : activate multithreading support.\n'warning_minstartingids' : the required minimum amount of starting samples\n'dotrimming' : determines whether the integral estimates are trimmed (1σ trim) before combining them into a final result (more robust)\n'uncertaintyestimators' : A dictionary of different uncertainty estimator functions. Currently three functions are available: hmcombineresultslegacy! (outdated, overestimates uncertainty significantly in higher dimensions), hmcombineresultscovweighted! (very fast) and hmcombineresults_analyticestimation! (recommended)\n\nend\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.IntegrationVolume","page":"Internal API","title":"BAT.IntegrationVolume","text":"IntegrationVolume{T<:AbstractFloat, I<:Integer}\n\nAHMI-internal, not part of stable public API.\n\nVariables\n\n'pointcloud' : holds the point cloud of the integration volume\n'spatialvolume' : the boundaries of the integration volume\n'volume' : the volume\n\nHold the point cloud and the spatial volume for integration.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.KDTreePartitioning","page":"Internal API","title":"BAT.KDTreePartitioning","text":"struct KDTreePartitioning <: SpacePartitioningAlgorithm\n\nBAT-internal, not part of stable public API.\n\nK-D binary space partitioning algorithm. By default, all parameters are considered for partitioning. Partition parameters can be specified manually by using partition_dims argument. By default, bounds of the partitioning tree are extended to those given by prior. This can be changed by setting extend_bounds = false.\n\nConstructors:\n\nKDTreePartitioning(; fields...)\n\nFields:\n\npartition_dims::Union{Symbol, Vector{Int64}}\nDefault: :auto\nextend_bounds::Bool\nDefault: true\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.MCMCSampleGenerator","page":"Internal API","title":"BAT.MCMCSampleGenerator","text":"BAT.MCMCSampleGenerator\n\nBAT-internal, not part of stable public API.\n\nMCMC sample generator.\n\nConstructors:\n\nMCMCSampleGenerator(chain::AbstractVector{<:MCMCIterator})\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.NamedTupleTransform","page":"Internal API","title":"BAT.NamedTupleTransform","text":"NamedTupleTransform <: VariateTransform\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineMvCov","page":"Internal API","title":"BAT.OnlineMvCov","text":"OnlineMvCov{T<:AbstractFloat,W} <: AbstractMatrix{T}\n\nBAT-internal, not part of stable public API.\n\nImplementation based on variance calculation Algorithms of Welford and West.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineMvMean","page":"Internal API","title":"BAT.OnlineMvMean","text":"OnlineMvMean{T<:AbstractFloat} <: AbstractVector{T}\n\nBAT-internal, not part of stable public API.\n\nMultivariate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineUvMean","page":"Internal API","title":"BAT.OnlineUvMean","text":"OnlineUvMean{T<:AbstractFloat}\n\nBAT-internal, not part of stable public API.\n\nUnivariate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineUvVar","page":"Internal API","title":"BAT.OnlineUvVar","text":"OnlineUvVar{T<:AbstractFloat,W}\n\nBAT-internal, not part of stable public API.\n\nImplementation based on variance calculation Algorithms of Welford and West.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.PointCloud","page":"Internal API","title":"BAT.PointCloud","text":"PointCloud{T<:AbstractFloat, I<:Integer}\n\nAHMI-internal, not part of stable public API.\n\nStores the information of the points of an e.g. HyperRectVolume\n\nVariables\n\n'maxLogProb' : The maximum log. probability of one of the points inside the hyper-rectangle\n'minLogProb' : The minimum log. probability of one of the points inside the hyper-rectangle\n'maxWeightProb' : the weighted max. log. probability\n'minWeightProb' : the weighted min. log. probability\n'probfactor' : The probability factor of the hyper-rectangle\n'probweightfactor' : The weighted probability factor\n'points' : The number of points inside the hyper-rectangle\n'pointIDs' : the IDs of the points inside the hyper-rectangle, might be empty because it is optional and costs performance\n'searchres' : used to boost performance\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.SearchResult","page":"Internal API","title":"BAT.SearchResult","text":"SearchResult{T<:AbstractFloat, I<:Integer}\n\nAHMI-internal, not part of stable public API.\n\nStores the results of the space partitioning tree's search function\n\nVariables\n\n'pointIDs' : the IDs of samples found, might be empty because it is optional\n'points' : The number of points found.\n'maxLogProb' : the maximum log. probability of the points found.\n'minLogProb' : the minimum log. probability of the points found.\n'maxWeightProb' : the weighted minimum log. probability found.\n'minWeightProb' : the weighted maximum log. probfactor found.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.SpacePartTree","page":"Internal API","title":"BAT.SpacePartTree","text":"SpacePartTree\n\nBAT-internal, not part of stable public API.\n\nThe structure stores a partitioning tree generated by any SpacePartitioningAlgorithm. Variables:\n\nterminated_leaf : true if the tree node is terminal, false otherwise.\nbounds : Low and high bound of the tree leaf.\nleft_child : The left child of the tree, missing is the node is terminal.\nright_child : The right child of the tree, missing is the node is terminal.\ncut_axis : Axis along which cut is performed, missing if the node is terminal.\ncut_coordinate : Coordinate at which a cut is performed, missing if the node is terminal.\ncost : The sum of the cost functions over leaves.\ncost_part : The cost function of the current leaf, missing if the node is terminal..\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardMvNormal","page":"Internal API","title":"BAT.StandardMvNormal","text":"StandardMvNormal{T<:Real} <: Distributions.AbstractMvNormal\n\nA standard n-dimensional multivariate normal distribution with it's mean at the origin and an identity covariance matrix.\n\nConstructor:\n\n    StandardMvNormal(n::Integer)\n    StandardMvNormal{T<:Real}(n::Integer)\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardMvUniform","page":"Internal API","title":"BAT.StandardMvUniform","text":"StandardMvUniform{T<:Real} <: Distributions.Distribution{Multivariate,Continuous}\n\nA standard n-dimensional multivariate uniform distribution, from zero to one in each dimension.\n\nConstructor:\n\n    StandardMvUniform(n::Integer)\n    StandardMvUniform{T<:Real}(n::Integer)\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardUvNormal","page":"Internal API","title":"BAT.StandardUvNormal","text":"StandardUvNormal{T<:Real} <: Distributions.Distribution{Univariate,Continuous}\n\nA standard normal distribution with a mean of zero and a variance of one.\n\nConstructor:\n\n    StandardUvNormal()\n    StandardUvNormal{T<:Real}()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardUvUniform","page":"Internal API","title":"BAT.StandardUvUniform","text":"StandardUvUniform{T<:Real} <: Distributions.Distribution{Univariate,Continuous}\n\nA standard uniform distribution between zero and one.\n\nConstructor:\n\n    StandardUvUniform()\n    StandardUvUniform{T<:Real}()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.TransformedDensity","page":"Internal API","title":"BAT.TransformedDensity","text":"TransformedDensity\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.TruncatedDensity","page":"Internal API","title":"BAT.TruncatedDensity","text":"TruncatedDensity\n\nConstructor:\n\nTruncatedDensity(D<:AbstractDensity, B<:VarVolumeBounds)\n\nBAT-internal, not part of stable public API.\n\nA density truncated to given bounds, forced to effectively zero outside of those bounds. In contrast to a truncated distribution, the density is not renormalized.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.VariateSpace","page":"Internal API","title":"BAT.VariateSpace","text":"abstract type VariateSpace <: Function\n\nBAT-internal, not part of stable public API.\n\nAbstract type for variate spaces.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.VariateTransform","page":"Internal API","title":"BAT.VariateTransform","text":"abstract type VariateTransform{VF:<VariateForm,ST<:VariateSpace,SF<:VariateSpace}\n\nBAT-internal, not part of stable public API.\n\nAbstract parameterized type for change-of-variables transformations.\n\nSubtypes (e.g. SomeTrafo <: VariateTransform) must implement:\n\nBAT.target_space(trafo::SomeTrafo, v)\nBAT.source_space(trafo::SomeTrafo, v)\nBAT.apply_vartrafo_impl(trafo::SomeTrafo, v)\nBAT.apply_vartrafo_impl(inv_trafo::InverseVT{SomeTrafo}, v)\nValueShapes.varshape(trafo::SomeTrafo)\n\nfor real values and/or real-valued vectors v.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.WhiteningResult","page":"Internal API","title":"BAT.WhiteningResult","text":"WhiteningResult{T<:AbstractFloat}\n\nAHMI-internal, not part of stable public API.\n\nStores the information obtained during the Whitening Process\n\nVariables\n\n'determinant' : The determinant of the whitening matrix\n'targetprobfactor' : The suggested target probability factor\n'whiteningmatrix' : The whitening matrix\n'meanvalue' : the mean vector of the input data\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.argchoice_msg","page":"Internal API","title":"BAT.argchoice_msg","text":"argchoice_msg(f::Base.Callable, argname::Val, x)\n\nBAT-internal, not part of stable public API.\n\nGenerates an information message regarding the choice of value x for argument argname of function f.\n\nThe value x will often be the result of bat_default.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.bat_sampler","page":"Internal API","title":"BAT.bat_sampler","text":"bat_sampler(d::Distribution)\n\nBAT-internal, not part of stable public API.\n\nTries to return a BAT-compatible sampler for Distribution d. A sampler is BAT-compatible if it supports random number generation using an arbitrary AbstractRNG:\n\nrand(rng::AbstractRNG, s::SamplerType)\nrand!(rng::AbstractRNG, s::SamplerType, x::AbstractArray)\n\nIf no specific method of bat_sampler is defined for the type of d, it will default to sampler(d), which may or may not return a BAT-compatible sampler.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.bg_R_2sqr","page":"Internal API","title":"BAT.bg_R_2sqr","text":"bg_R_2sqr(stats::AbstractVector{<:MCMCBasicStats}; corrected::Bool = false)\nbg_R_2sqr(samples::AbstractVector{<:DensitySampleVector}; corrected::Bool = false)\n\nBAT-internal, not part of stable public API.\n\nBrooks-Gelman R_2^2 for all DOF. If normality is assumed, 'corrected' should be set to true to account for the sampling variability.\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.create_hypercube","page":"Internal API","title":"BAT.create_hypercube","text":"create_hypercube{T<:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume\n\nAHMI-internal, not part of stable public API.\n\ncreates a hypercube shaped spatial volume\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.create_hyperrectangle","page":"Internal API","title":"BAT.create_hyperrectangle","text":"create_hyperrectangle(...)\n\nAHMI-internal, not part of stable public API.\n\nThis function creates a hyper-rectangle around each starting sample. It starts by building a hyper-cube  and subsequently adapts each face individually, thus turning the hyper-cube into a hyper-rectangle. The faces are adjusted in a way to match the shape of the distribution as best as possible.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.density_logval_type","page":"Internal API","title":"BAT.density_logval_type","text":"BAT.density_logval_type(v::Any, density::AbstractDensity, T::Type{<:Real} = Float32)\n\nBAT-internal, not part of stable public API.\n\nDetermine a suitable return type of log-density functions, given a variate v and an optional additional default result type T.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.proposaldist_logpdf","page":"Internal API","title":"BAT.proposaldist_logpdf","text":"proposaldist_logpdf(\n    p::AbstractArray,\n    pdist::AbstractProposalDist,\n    v_proposed::AbstractVector,\n    v_current:::AbstractVector\n)\n\nBAT-internal, not part of stable public API.\n\nReturns log(PDF) value of pdist for transitioning from current to proposed variate/parameters.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.drop_low_weight_samples","page":"Internal API","title":"BAT.drop_low_weight_samples","text":"drop_low_weight_samples(\n    samples::DensitySampleVector,\n    fraction::Real = 10^-4\n)\n\nBAT-internal, not part of stable public API.\n\nDrop fraction of the total probability mass from samples to filter out the samples with the lowest weight.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.eval_gradlogval","page":"Internal API","title":"BAT.eval_gradlogval","text":"eval_gradlogval(density::AbstractDensity, v::AbstractVector{<:Real})\ngrad\n\nBAT-internal, not part of stable public API.\n\nCompute the log of the value of a multivariate density function, as well as the gradient of the log-value for the given variate/parameter-values.\n\nInput:\n\ndensity: density function\nv: argument, i.e. variate / parameter-values\n\nReturns a tuple of the log density value and it's gradient.\n\nNote: This function should not be specialized for custom density types!\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.eval_logval","page":"Internal API","title":"BAT.eval_logval","text":"eval_logval(\n    density::AbstractDensity,\n    v::Any,\n    T::Type{:Real} = density_logval_type(v, density);\n    use_bounds::Bool = true,\n    strict::Bool = false\n)::T\n\nBAT-internal, not part of stable public API.\n\nEvaluates density log-value via eval_logval_unchecked.\n\nThrows an exception on any of these conditions:\n\nThe variate shape of density (if known) does not match the shape of v.\nThe return value of eval_logval_unchecked is NaN.\nThe return value of eval_logval_unchecked is an equivalent of positive infinity.\n\nOptions:\n\nuse_bounds: Return an equivalent of negative infinity if v is out of bounds. use_bounds should only be set to false when it is known that the v is within bounds.\nstrict: Throw an exception if v is out of bounds.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.find_hypercube_centers","page":"Internal API","title":"BAT.find_hypercube_centers","text":"find_hypercube_centers(dataset::DataSet{T, I}, whiteningresult::WhiteningResult, settings::HMISettings)::Vector{I}\n\nAHMI-internal, not part of stable public API.\n\nfinds possible starting points for the hyperrectangle creation\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.find_marginalmodes","page":"Internal API","title":"BAT.find_marginalmodes","text":"find_marginalmodes(marg::MarginalDist)\n\nBAT-internal, not part of stable public API.\n\nFind the modes of a MarginalDist. Returns a vector of the bin-centers of the bin(s) with the heighest weight.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.fromuhc","page":"Internal API","title":"BAT.fromuhc","text":"fromuhc(X::AbstractVector, vol::SpatialVolume)\nfromuhc(X::VectorOfSimilarVectors, vol::SpatialVolume)\n\nBAT-internal, not part of stable public API.\n\nBijective transformation from unit hypercube to vol. See fromuhc!.\n\nUse inv(fromuhc) to get the the inverse transformation.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.fromuhc!","page":"Internal API","title":"BAT.fromuhc!","text":"fromuhc!(Y::AbstractVector, X::AbstractVector, vol::SpatialVolume)\nfromuhc!(Y::VectorOfSimilarVectors, X::VectorOfSimilarVectors, vol::SpatialVolume)\n\nBAT-internal, not part of stable public API.\n\nBijective transformation of coordinates X within the unit hypercube to coordinates Y in vol. If X and Y are matrices, the transformation is applied to the column vectors. Use Y === X to transform in-place.\n\nUse inv(fromuhc!) to get the the inverse transformation.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.fromui","page":"Internal API","title":"BAT.fromui","text":"y = fromui(x::Real, lo::Real, hi::Real)\ny = fromui(x::Real, lo_hi::ClosedInterval{<:Real})\n\nBAT-internal, not part of stable public API.\n\nLinear bijective transformation from the unit inverval (i.e. x ∈ 0..1) to y ∈ lo..hi.\n\nUse inv(fromui) to get the the inverse transformation.\n\nUse @inbounds to disable range checking on the input value.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.get_bin_centers","page":"Internal API","title":"BAT.get_bin_centers","text":"get_bin_centers(marg::MarginalDist)\n\nBAT-internal, not part of stable public API.\n\nReturns a vector of the bin-centers.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.getlikelihood","page":"Internal API","title":"BAT.getlikelihood","text":"getlikelihood(posterior::AbstractPosteriorDensity)::AbstractDensity\n\nBAT-internal, not part of stable public API.\n\nThe likelihood density of posterior. The likelihood may or may not be normalized.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.getprior","page":"Internal API","title":"BAT.getprior","text":"getprior(posterior::AbstractPosteriorDensity)::AbstractDensity\n\nBAT-internal, not part of stable public API.\n\nThe prior density of posterior. The prior may or may not be normalized.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.gr_Rsqr","page":"Internal API","title":"BAT.gr_Rsqr","text":"gr_Rsqr(stats::AbstractVector{<:MCMCBasicStats})\ngr_Rsqr(samples::AbstractVector{<:DensitySampleVector})\n\nBAT-internal, not part of stable public API.\n\nGelman-Rubin R^2 for all DOF.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.hm_init","page":"Internal API","title":"BAT.hm_init","text":"hm_init!(result, settings)\n\nAHMI-internal, not part of stable public API.\n\nSets the global multithreading setting and ensures that a minimum number of samples, dependent on the number of dimensions, are provided.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.hm_integrate!","page":"Internal API","title":"BAT.hm_integrate!","text":"hm_integrate!(result, settings = HMIPrecisionSettings())\n\nAHMI-internal, not part of stable public API.\n\nThis function starts the adaptive harmonic mean integration. See arXiv:1808.08051 for more details. It needs a HMIData struct as input, which holds the samples, in form of a dataset, the integration volumes and other properties, required for the integration, and the final result.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.hm_whiteningtransformation!","page":"Internal API","title":"BAT.hm_whiteningtransformation!","text":"hm_whiteningtransformation!(result, settings)\n\nAHMI-internal, not part of stable public API.\n\nApplies a whitening transformation to the samples. A custom whitening method can be used by overriding settings.whitening_function!\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.hyperrectangle_creationproccess!","page":"Internal API","title":"BAT.hyperrectangle_creationproccess!","text":"hyperrectangle_creationproccess!(...)\n\nAHMI-internal, not part of stable public API.\n\nThis function assigns each thread its own hyper-rectangle to build, if in multithreading-mode.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.integrate_hyperrectangle_cov","page":"Internal API","title":"BAT.integrate_hyperrectangle_cov","text":"Estimates reducedvolumehm quantity for one hyperrectangle including estimates from batches (for covariance calculations).\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.is_log_zero","page":"Internal API","title":"BAT.is_log_zero","text":"BAT.is_log_zero(x::Real, T::Type{<:Real} = typeof(x)}\n\nBAT-internal, not part of stable public API.\n\nCheck if x is an equivalent of log of zero, resp. negative infinity, in respect to type T.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.issymmetric_around_origin","page":"Internal API","title":"BAT.issymmetric_around_origin","text":"issymmetric_around_origin(d::Distribution)\n\nBAT-internal, not part of stable public API.\n\nReturns true (resp. false) if the Distribution is symmetric (resp. non-symmetric) around the origin.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.log_volume","page":"Internal API","title":"BAT.log_volume","text":"log_volume(vol::SpatialVolume)\n\nBAT-internal, not part of stable public API.\n\nGet the logarithm of the volume of the space in vol.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.log_zero_density","page":"Internal API","title":"BAT.log_zero_density","text":"BAT.log_zero_density(T::Type{<:Real})\n\nlog-density value to assume for regions of implicit zero density, e.g. outside of variate/parameter bounds/support.\n\nReturns an equivalent of negative infinity.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.modify_hypercube!","page":"Internal API","title":"BAT.modify_hypercube!","text":"create_hypercube!{T<:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume\n\nAHMI-internal, not part of stable public API.\n\nresizes a hypercube shaped spatial volume\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.modify_integrationvolume!","page":"Internal API","title":"BAT.modify_integrationvolume!","text":"modify_integrationvolume!(intvol::IntegrationVolume{T, I}, dataset::DataSet{T, I}, spvol::HyperRectVolume{T}, searchpts::Bool = true)\n\nAHMI-internal, not part of stable public API.\n\nupdates an integration volume with new boundaries. Recalculates the pointcloud and volume.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.partition_space","page":"Internal API","title":"BAT.partition_space","text":"partition_space(\n\tsamples::DensitySampleVector,\n\tnpartitions::Integer,\n\talgorithm::KDTreePartitioning\n)\n\nBAT-internal, not part of stable public API.\n\nThe function generates a space partition tree with the number of partitions given by npartitions, using KDTreePartitioning algorithm. Exploration samples are given by samples. The output contains SpacePartTree and the values of the cost function.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.proposal_rand!","page":"Internal API","title":"BAT.proposal_rand!","text":"function proposal_rand!(\n    rng::AbstractRNG,\n    pdist::GenericProposalDist,\n    v_proposed::Union{AbstractVector,VectorOfSimilarVectors},\n    v_current::Union{AbstractVector,VectorOfSimilarVectors}\n)\n\nBAT-internal, not part of stable public API.\n\nGenerate one or multiple proposed variate/parameter vectors, based on one or multiple previous vectors.\n\nInput:\n\nrng: Random number generator to use\npdist: Proposal distribution to use\nv_current: Old values (vector or column vectors, if a matrix)\n\nOutput is stored in\n\nv_proposed: New values (vector or column vectors, if a matrix)\n\nThe caller must guarantee:\n\nsize(v_current, 1) == size(v_proposed, 1)\nsize(v_current, 2) == size(v_proposed, 2) or size(v_current, 2) == 1\nv_proposed !== v_current (no aliasing)\n\nImplementations of proposal_rand! must be thread-safe.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.reduced_volume_hm","page":"Internal API","title":"BAT.reduced_volume_hm","text":"reduced_volume_hm!(log_prob, sample_weights, volume_size, n_total, weight_total, bias_correction==true)\n\nEstimate reduced volume harmonic mean for given arguments. Includes bias corection by default. Note: Weights are expected to be frequency weights (i.e. counts).\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.repetition_to_weights","page":"Internal API","title":"BAT.repetition_to_weights","text":"repetition_to_weights(v::AbstractVector)\n\nBAT-internal, not part of stable public API.\n\nDrop (subsequently) repeated samples by adding weights.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.spatialvolume","page":"Internal API","title":"BAT.spatialvolume","text":"spatialvolume(b::VarVolumeBounds)::SpatialVolume\n\nBAT-internal, not part of stable public API.\n\nReturns the spatial volume that defines the variate/parameter bounds.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.sum_first_dim","page":"Internal API","title":"BAT.sum_first_dim","text":"@propagate_inbounds sum_first_dim(A::AbstractArray, j::Integer, ks::Integer...)\n\nBAT-internal, not part of stable public API.\n\nCalculate the equivalent of sum(A[:, j, ks...]).\n\n\n\n\n\n@propagate_inbounds sum_first_dim(A::AbstractArray)\n\nBAT-internal, not part of stable public API.\n\nIf A is a vector, return sum(A), else sum(A, 1)[:].\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.trunc_logpdf_ratio","page":"Internal API","title":"BAT.trunc_logpdf_ratio","text":"BAT.trunc_logpdf_ratio(orig_dist::Distribution{TP}, trunc_dist::Distribution{TP})::AbstractFloat\n\nBAT-internal, not part of stable public API.\n\nComputes the log-ratio between the amplitude of the PDF of a truncated distribution and the original (untruncted) distribution, within the support of the truncated one.\n\nThe PDF of both distributions must have the same shape within the support of trunc_dist and may only differ in amplitude.\n\nMainly used to implement BAT.truncate_density, in conjunction with BAT.truncate_dist_hard. The result contributes to the logscalecorr factor of a [TruncatedDensity] that uses truncated distributions internally, to ensure the density does not get renormalized.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.truncate_density","page":"Internal API","title":"BAT.truncate_density","text":"BAT.truncate_density(density::AbstractDensity, bounds::AbstractVarBounds)::AbstractDensity\n\nBAT-internal, not part of stable public API.\n\nTruncate density to bounds, the resulting density will be effectively zero outside of those bounds. In contrast Distributions.truncated, truncate_density does not renormalize the density.\n\nCurrently implemented for BAT.HyperRectBounds only.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.truncate_dist_hard","page":"Internal API","title":"BAT.truncate_dist_hard","text":"BAT.truncate_dist_hard(dist::Distribution{Univariate}, bounds::Interval)::Distribution{Univariate}\nBAT.truncate_dist_hard(dist::Distribution{Multivariate}, bounds::AbstractArray{<:Interval})::Distribution{Multivariate}\n\nBAT-internal, not part of stable public API.\n\nGeneralized variant of Distributions.truncated - also handles multivariate distributions and operates on a best-effort basis: If distributions cannot be truncated, may return the original distribution.\n\nReturns a NamedTuple\n\n    (dist = trunc_dist, logscalecorr = logscalecorr)\n\nwith the truncated distribution and the log-PDF amplitude difference to the original (see BAT.trunc_logpdf_ratio).\n\nMainly used to implement BAT.truncate_density.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.var_bounds","page":"Internal API","title":"BAT.var_bounds","text":"var_bounds(density::DistLikeDensity)::AbstractVarBounds\n\nBAT-internal, not part of stable public API.\n\nGet the parameter bounds of density. Must not be missing.\n\n\n\n\n\n","category":"function"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"BAT.jl is written in the Julia programming language. To use BAT.jl, you will need to install Julia itself, the BAT.jl Julia package, and some additional Julia packages. Depending on your use case, you may also want to need a Python installation with certain Python packages (optional).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Table of contents:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Pages = [\"installation.md\"]\nDepth = 3","category":"page"},{"location":"installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia is available for Linux, OS-X and Windows, and easy to install:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download Julia.\nExtract the archive, resp. run the installer.\nYou may want to add the Julia bin directory to your $PATH. To get the location of the Julia bin directory on OS-X or Windows, start a Julia session (via applications menu) and run the Julia command Sys.BINDIR.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"note: Note\nBAT.jl requires Julia >= v1.3.","category":"page"},{"location":"installation/#Installing-Jupyter-and-matplotlib/pyplot-(optional)","page":"Installation","title":"Installing Jupyter and matplotlib/pyplot (optional)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you plan to use Jupyter notebooks and/or the matplotlib/pyplot backend of the Julia Plots.jl package, you will also need a Python installation and certain Python packages (see below). BAT.jl is fully usable without Jupyter and matplotlib/pyplot, but both can come in very handy.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia can either use existing installations of Jupyter and pyplot , or install both internally by creating an internal Conda installation within $HOME/.julia/conda. We recommend the first approach (especially using Anaconda), since Julia will otherwise have to download over 1 GB of software, the $HOME/.julia directory will grow very large, and you will need to start Jupyter in an indirect fashion via Julia (only to have Jupyter then start additional Julia instances as Jupyter kernels in return).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"For details, see the IJulia.jl, PyCall.jl and PyPlot.jl documentation (you should not need to if you follow the steps below).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"On Linux, Julia (more specifically the Julia packages IJulia.jl, PyCall.jl, and PyPlot.jl) will by default try to use the matplotlib/pyplot installation associated with the python3 (resp. python) executable on your $PATH. Likewise, Julia will by default try to use the Jupyter installation associated with the jupyter executable on your $PATH.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"However, on OS-X and Windows, both IJulia.jl and PyCall.jl by default always create a Julia-internal Conda installation (see above), even if Jupyter and matplotlib/pyplot are available (apparently broken Jupyter/Python installations on these platforms caused frequent support requests).  In contrast to this default behavior, we recommend to use a standalone Jupyter and Python installation on all OS platforms. Set the environment variables $JUPYTER and $PYTHON to point to your Jupyter and Python executable to force Julia to use the existing installation.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"We recommend that you install the Anaconda Python distribution, it includes both Jupyter and pyplot (it is of course possible to use non-Anaconda Jupyter and pyplot installations instead).","category":"page"},{"location":"installation/#Installing-Anaconda-(optional)","page":"Installation","title":"Installing Anaconda (optional)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install Anaconda","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download Anaconda.\nRun the installer\nSet the environment variables $JUPYTER and $PYTHON to the full path of the Jupyter and Python executables (see above).\nNote: OS-X => v1.15 (\"Catalina\") by default uses the \"zsh\" shell instead of \"bash\". However, the Anaconda installer (at least in some versions) still seems to add add it's $PATH settings to \"HOMEbash_profile instead of HOME/.zshrc\". You may have to copy the Anaconda-related section to the correct file.","category":"page"},{"location":"installation/#Environment-variables","page":"Installation","title":"Environment variables","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You may want/need to set the following environment variables:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"$PATH: Include the Julia bin-directory in your binary search path, see above.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you intend to use Jupyter, you will probably want to include the directory containing the jupyter binary to your PATH as well.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"$JULIA_NUM_THREADS: Number of threads to use for Julia multi-threading\n$JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR: If you want Julia to install packages in another location than $HOME/.julia.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"See the Julia manual for a description of other Julia-specific environment variables.","category":"page"},{"location":"installation/#Installing-BAT.jl-and-related-Julia-packages","page":"Installation","title":"Installing BAT.jl and related Julia packages","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"BAT.jl is provided as a registered Julia package. To install it, simply run","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> pkg\"add BAT\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"However, you will likely need other Julia packages too. We recommend that you install certain statistics, plotting, I/O and array packages as well:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> pkg\"add BAT ArraysOfArrays Distributions ElasticArrays IntervalSets Parameters Plots ValueShapes StatsBase Tables TypedTables\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the latest development version of BAT (master branch), instead of the latest stable release, use","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> pkg\"add BAT#master\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you'd like to precompile all installed packages right aways (otherwise they'll get precompiled when loaded for the first time), run","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> pkg\"precompile\"","category":"page"},{"location":"installation/#Installing-additional-Julia-packages","page":"Installation","title":"Installing additional Julia packages","text":"","category":"section"},{"location":"installation/#HDF5-(File-I/O)","page":"Installation","title":"HDF5 (File I/O)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To enable BAT's HDF5 file I/O capabilities, add the package \"HDF5.jl\":","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg\"add HDF5\"","category":"page"},{"location":"installation/#IJulia-(Jupyter-Julia-kernel)","page":"Installation","title":"IJulia (Jupyter Julia kernel)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To use the the Julia Jupyter kernel, you need to add the package \"IJulia.jl\":","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"On Linux, simply use","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg\"add IJulia\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"On OS-X, if you have an existing Jupyter installation (e.g. via Anaconda) and would like Julia to use it (instead of an internal Conda installation, see above), use (e.g.)","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"ENV[\"JUPYTER\"] = \"$(homedir())/opt/anaconda3/bin/jupyter\"; pkg\"add IJulia\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"On Windows, if would like Julia to use an existing Jupyter installation (see above), use something like","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"ENV[\"JUPYTER\"] = \"DRIVE:/path/to/your/anaconda/.../jupyter.exe\"; pkg\"add IJulia\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia will remember the chosen Jupyter installation permanently, ENV[\"JUPYTER\"] only needs to be set the first time you run pkg\"add IJulia\".","category":"page"},{"location":"installation/#PyPlot-(optinal-backend-for-Plots.jl)","page":"Installation","title":"PyPlot (optinal backend for Plots.jl)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To use the Plots.jl matplotlib/pyplot backend (see above), add the package \"PyPlot.jl\". To call Python code from Julia yourself directly, you may want to add \"PyCall.jl\" as well:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"On Linux, use:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg\"add PyPlot PyCall\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"On OS-X, if you have an existing Python/matplotlib/pyplot installation and would like Julia to use it (see above), use (e.g.):","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"ENV[\"PYTHON\"] = \"$(homedir())/opt/anaconda3/bin/python\", pkg\"add PyPlot PyCall\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"On Windows, if would like Julia to use an existing Python installation (see above), use something like:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"ENV[\"PYTHON\"] = \"DRIVE:/path/to/your/anaconda/.../python.exe\"; pkg\"add PyPlot PyCall\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia will remember the chosen Python installation permanently, ENV[\"PYTHON\"] only needs to be set the first time you run pkg\"add PyPlot PyCall\".","category":"page"},{"location":"installation/#Additional-customization-options","page":"Installation","title":"Additional customization options","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Note: If you want Julia to install packages in another location than $HOME/.julia, set the environment variables JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR (see above).","category":"page"},{"location":"plotting/#Plot-Recipes","page":"Plotting","title":"Plot Recipes","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The plot recipes described below apply for plotting samples and priors. Only the plotting of estimators (mean, standard deviation, global mode and local mode) is currently only supported for samples.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Also see the plotting tutorial for examples and further information on the plotting options.","category":"page"},{"location":"plotting/#D-plots","page":"Plotting","title":"1D plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(\n    samples::DensitySampleVector / prior::NamedTupleDist,\n    vsel::Union{Integer, Symbol, Expr};\n    intervals = BAT.default_credibilities,\n    bins = 200,\n    colors = BAT.default_colors,\n    interval_labels = [],\n    mean = false,\n    std = false,\n    globalmode = false,\n    marginalmode = true,\n    filter = false,\n    closed = :left\n)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Required inputs:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"samples::DensitySampleVector or prior::NamedTupleDist: samples (shaped or unshaped) or prior to be plotted\nvsel::Union{Integer, Symbol, Expr}: index or name of the parameter to be plotted","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"seriestype::Symbol = :smallest_intervals: plot style        ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"available seriestypes:\n* `:smallest_intervals` (default for samples), alias `:HDR`\n* `:central_intervals`\n* `:histogram`, alias `:steppost`\n* `:stephist` (default for prior)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"bins::Union{Integer, AbstractRange} = 200: number of histogram bins or bin edges.\nintervals::Array{<:Real, 1} = [0.683, 0.955, 0.997]: probability to be enclosed in the smallest/central intervals when using the corresponding seriestypes\ncolors::Array{Symbol, 1} = [:chartreuse2, :yellow, :red]: colors of the smallest/central interval regions, in same order as the values in intervals\nmean::Union{Dict, Bool} = true: indicate mean value (currently only for samples), calculated via bat_stats().mean.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The plot style of the mean can be customized using a Dict.  For mean = true, the default style is:   Dict(\"linestyle\" => :solid, \"linewidth\" => 1, \"linecolor\" => :dimgrey, \"alpha\" => 1, \"label\" => \"mean\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"std::Union{Dict, Bool} = true: indicate the standard deviation of the mean (currently only for samples), calculated from bat_stats().cov. The style of the standard deviation can be customized using a Dict.  For std = true, the default style is:   ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Dict(\"fillcolor\" => :grey, \"fillalpha\" => 0.5, \"label\" => \"std. dev.\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"globalmode::Union{Dict, Bool} = true: indicate global mode (currently only for samples), calculated via bat_stats().mode.  The style of the global mode can be passed as a Dict.  For globalmode = true, the default style is:  ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dash, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"global mode\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"marginalmode::Union{Dict, Bool} = true: indicate the marginal mode(s), i.e. the center of the highest histogram bin(s) (currently only for samples). The style can be passed as a Dict. If marginalmode = true, the default style is:  ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dot, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"local mode\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(only for samples) filter::Bool = false: if true, BAT.drop_low_weight_samples() is applied before plotting\nclosed = :left: see StatsBase.Histogram","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments for attributes supported by Plots.jl can also be passed to the function.","category":"page"},{"location":"plotting/#D-plots-2","page":"Plotting","title":"2D plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(\n    samples::DensitySampleVector / prior::NamedTupleDist,\n    vsel::Union{NTuple{2, Integer}, NTuple{2, Union{Symbol, Expr}}};\n    intervals = BAT.default_credibilities,\n\tinterval_labels = [],\n    colors = BAT.default_colors,\n\tbins = 200,\n    mean = false,\n    std = false,\n    globalmode = false,\n    marginalmode = true,\n    diagonal = Dict(),\n    upper = Dict(),\n    right = Dict(),\n    filter = false,\n    closed = :left\n)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Required inputs:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"samples::DensitySampleVector or prior::NamedTupleDist: samples (shaped or unshaped) or prior to be plotted\nvsel::Union{NTuple{2, Integer}, NTuple{2, Union{Symbol, Expr}}}: indices or names of the two parameters to be plotted","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"seriestype::Symbol = :smallest_intervals: plot style  ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"available seriestypes:\n* `:smallest_intervals` (default for samples)\n* `:smallest_intervals_contour` (default for prior)\n* `:smallest_intervals_contourf`: filled contours)\n* `:histogram`, alias `:hist`, alias `:histogram2d`\n* `:scatter`","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"bins::Union{Integer, NTuple{2, Integer}, NTuple{2, AbstractRange}} = 200: number of histogram bins or bin edges. Use a NTuple{2, Union{Integer, AbstractRange}} to specify bins/edges of x and y axes seperately.\nintervals::Array{<:Real, 1} = [0.683, 0.955, 0.997]  probability to be enclosed in the smallest intervals when using the corresponding seriestypes\ninterval_labels = []  label of the intervals as strings, LatexStrings are possible.\ncolors::Array{Symbol, 1} = [:chartreuse2, :yellow, :red] colors of the smallest interval regions, in same order as the values in intervals\nmean::Union{Dict, Bool} = true: indicate mean value (currently only for samples) , calculated via bat_stats().mean.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The plot style of the mean can be customized using a Dict.  For mean = true, the default style is: Dict(\"markercolor\" => :black, \"markersize\" => 4, \"markeralpha\" => 1, \"markershape\" => :circle, \"markerstrokealpha\" => 1, \"markerstrokecolor\" => :black, \"markerstrokestyle\" => :solid, \"markerstrokewidth\" => 1, \"label\" => \"mean\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"std::Union{Bool} = true: indicate the standard deviation of the mean as errorbars (currently only for samples), calculated from bat_stats().cov. The style of the errorbars can be customized using the markerstroke... options in mean.\nglobalmode::Union{Dict, Bool} = true: indicate global mode (currently only for samples), calculated via bat_stats().mode.  The style of the global mode can be passed as a Dict.  For globalmode = true, the default style is:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dash, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"global mode\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"marginalmode::Union{Dict, Bool} = true: indicate the marginalmode(s), i.e. the center of the highest histogram bin(s) (currently only for samples). The style can be passed as a Dict. If marginalmode = true, the default style is:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dot, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"local mode\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"diagonal = Dict(): Used only for the seriestype :marginal. The dictionary can contain the seriestypes and plot options for 2D distributions explained above to modify the 2D plot of the marginal plot. Nested Dictionaries are possible to modify the styles of the estimators as described above\nupper = Dict() and right = Dict():  Used only for the seriestype :marginal. The dictionaries can contain the seriestypes and plot options for 1D distributions explained above to modify the upper and right plots of the 1D marginal distributions. Nested Dictionaries are possible to modify the styles of the estimators as described above\nfilter::Bool = false: if true, BAT.drop_low_weight_samples() is applied before plotting\nclosed = :left: see StatsBase.Histogram","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments for attributes supported by Plots.jl can also be passed to the function.","category":"page"},{"location":"plotting/#D-and-2D-overview-plots","page":"Plotting","title":"1D & 2D overview plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(\n\tsamples::DensitySampleVector / prior::NamedTupleDist;\n    vsel=collect(1:5),\n\tbins = 200,\n    mean=false,\n    std=false,\n    globalmode=false,\n    marginalmode=false,\n    diagonal = Dict(),\n    upper = Dict(),\n    lower = Dict(),\n    vsel_label = []\n)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Plot a grid with the 1D marginalized distributions on the diagonal and all combinations of the 2D marginalized distributions in the lower and upper triangle.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Required inputs:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"samples::DensitySampleVector or prior::NamedTupleDist: samples (shaped or unshaped) or prior to be plotted","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"vsel = collect(1:5): indices or parameter names of the parameters to be plotted. By default (up to) the first five parameters are plotted.\nbins::Union{Integer, Tuple{Union{Integer, AbstractRange}}, NamedTuple} = 200: Number of bins or bin edges\nmean::Bool = false: Indicate mean value, calculated via  bat_stats().mean, in all plots (currently only for samples)\nstd::Bool = false: Indicate the standard deviation of the mean calculated from bat_stats().cov in all plots (currently only for samples)\nglobalmode::Bool = false: Indicate global mode, calculated via bat_stats().mode, in all plots (currently only for samples)\nmarginalmode::Bool = false: Indicate local mode(s), i.e. the center of the highest histogram bin(s), in all plots (currently only for samples)\ndiagonal = Dict(): The dictionary can contain the seriestypes and plot options for 1D distributions explained above to modify the plots of the 1D marginal distributions on the diagonal of the grid. Nested Dictionaries are possible to modify the styles of the estimators as described above\nlower = Dict() and upper = Dict():  The dictionaries can contain the seriestypes and plot options for 2D distributions explained above to modify the 2D plots in the lower and upper triangles of the grid. Nested Dictionaries are possible to modify the styles of the estimators as described above\nvsel_label = []: parameter label as strings, LatexStrings are possible","category":"page"},{"location":"experimental_api/#Experimental-features","page":"Experimental Features","title":"Experimental features","text":"","category":"section"},{"location":"experimental_api/","page":"Experimental Features","title":"Experimental Features","text":"These are experimental features. Forward/backward compatibility does not follow Julia's semantic versioning rules. Instead, compatibility is only guaranteed across changes in patch version, but not across changes of minor (or major) version changes.","category":"page"},{"location":"experimental_api/","page":"Experimental Features","title":"Experimental Features","text":"The features listed here are likely to transition to the stable API in future versions, but may still evolve in a API-breaking fashion during that process.","category":"page"},{"location":"experimental_api/","page":"Experimental Features","title":"Experimental Features","text":"bat_compare\nbat_rng\nbat_marginalmode\nBAT.ExternalDensity\nBAT.FunnelDistribution\nBAT.GaussianShell\nBAT.MultimodalCauchy\nCuhreIntegration\nDivonneIntegration\nGridSampler\nHierarchicalDistribution\nPartitionedSampling\nPriorImportanceSampler\nSobolSampler\nSuaveIntegration\nVEGASIntegration","category":"page"},{"location":"experimental_api/#BAT.bat_compare","page":"Experimental Features","title":"BAT.bat_compare","text":"bat_compare(\n    samples_1::DensitySampleVector,\n    samples_2::DensitySampleVector;\n    nsamples::Symbol=:effective\n)\n\nCompares two DensitySampleVectors given by samples_1 and samples_2 applying the Kolmogorov-Smirnov test for all marginals.\n\nnsamples specifies how to define a number of samples in the Kolmogorov-Smirnov distribution. The default value is nsamples=:effective, which uses the effective number of samples estimated by bat_eff_sample_size. The optimal keywords:\n\n:length  — length of the DensitySamplesVector is used\n:weights — the sum of the weights is used\n\nReturns a NamedTuple of the shape\n\n(result = X::TypedTables.Table, ...)\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.bat_rng","page":"Experimental Features","title":"BAT.bat_rng","text":"bat_rng()\n\nExperimental feature, not part of stable public API.\n\nReturn a new BAT-compatible random number generator, with a random seed drawn from the system entropy pool.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.bat_marginalmode","page":"Experimental Features","title":"BAT.bat_marginalmode","text":"bat_marginalmode(\n    samples::DensitySampleVector;\n    nbins::Union{Integer, Symbol} = 200\n)::DensitySampleVector\n\nExperimental feature, not part of stable public API.\n\nEstimates a local mode of samples by finding the maximum of marginalized posterior for each dimension.\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\nnbins specifies the number of bins that are used for marginalization. The default value is nbins=200. The optimal number of bins can be estimated using  the following keywords:\n\n:sqrt  — Square-root choice\n:sturges — Sturges' formula\n:rice — Rice Rule\n:scott — Scott's normal reference rule\n:fd —  Freedman–Diaconis rule\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_marginalmode, add methods to bat_marginalmode_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.ExternalDensity","page":"Experimental Features","title":"BAT.ExternalDensity","text":"struct BAT.ExternalDensity <: AbstractDensity\n\nExperimental feature, not part of stable public API.\n\nUses an external program to calculate log-density values, the program must support the BAT binary communication protocol.\n\nConstructor:\n\nExternalDensity(cmd::Cmd, density_id::Integer = 0)\n\nAll fields of this type are considered internal and subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.FunnelDistribution","page":"Experimental Features","title":"BAT.FunnelDistribution","text":"struct BAT.FunnelDistribution <: Distribution{Multivariate,Continuous}\n\nExperimental feature, not part of stable public API.\n\nA funnel distribution (see Caldwell et al. for definition).\n\nConstructors:\n\nFunnelDistribution(; a::Real = 1.0, b::Real = 0.5, n::Integer = 3)\n\nFields:\n\na::Real\nVariance of the dominant normal distribution.\nb::Real\nVariance of the supporting normal distributions.\nn::Integer\nNumber of dimensions.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.GaussianShell","page":"Experimental Features","title":"BAT.GaussianShell","text":"struct BAT.GaussianShell <: Distribution{Multivariate,Continuous}\n\nExperimental feature, not part of stable public API.\n\nGaussian Shell (see Caldwell et al. for definition).\n\nConstructors:\n\nBAT.GaussianShell(; r::Real=5, w::Real=2, n::Integer=2)\n\nFields:\n\nr::Real\nThe radius of the Gaussian shell distribution.\nw::Real\nVariance of the Gaussian shell distribution\nn::Int64\nNumber of dimensions\nc::AbstractVector{var\"#s22\"} where var\"#s22\"<:Real\nlognorm::AbstractFloat\n\nnote: Note\nFields c and lognorm are considered internal and subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.MultimodalCauchy","page":"Experimental Features","title":"BAT.MultimodalCauchy","text":"BAT.MultimodalCauchy <: Distribution{Multivariate,Continuous}\n\nExperimental feature, not part of stable public API.\n\nThe Multimodal Cauchy Distribution (see Caldwell et al. for definition).\n\nAssumes two bimodal peaks, each in its own dimension.\n\nConstructors:\n\nBAT.MultimodalCauchy(; μ::Real=1, σ::Float64=0.2, n::Integer=4)\n\nArguments:\n\nμ::Real: The location parameter used for the two bimodal peaks.\nσ::Float64: The scale parameter shared among all components.\nn::Int: The number of dimensions.\n\nFields:\n\nbimodals::Distributions.MixtureModel\nσ::Float64\nn::Int64\ndist::Distributions.Product\n\nnote: Note\nAll fields of MultimodalCauchy are considered internal and subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.CuhreIntegration","page":"Experimental Features","title":"BAT.CuhreIntegration","text":"struct CuhreIntegration <: IntegrationAlgorithm\n\nExperimental feature, not part of stable public API.\n\nCuhreIntegration integration algorithm.\n\nConstructors:\n\nCuhreIntegration(; fields...)\n\nFields:\n\ntrafo::AbstractDensityTransformTarget\nDefault: PriorToUniform()\nlog_density_shift::Float64\nDefault: 0.0\nrtol::Float64\nDefault: Cuba.RTOL\natol::Float64\nDefault: Cuba.ATOL\nminevals::Int64\nDefault: Cuba.MINEVALS\nmaxevals::Int64\nDefault: Cuba.MAXEVALS\nkey::Int64\nDefault: Cuba.KEY\nnthreads::Int64\nDefault: Base.Threads.nthreads()\nstrict::Bool\nDefault: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.DivonneIntegration","page":"Experimental Features","title":"BAT.DivonneIntegration","text":"struct DivonneIntegration <: IntegrationAlgorithm\n\nExperimental feature, not part of stable public API.\n\nDivonneIntegration integration algorithm.\n\nConstructors:\n\nDivonneIntegration(; fields...)\n\nFields:\n\ntrafo::AbstractDensityTransformTarget\nDefault: PriorToUniform()\nlog_density_shift::Float64\nDefault: 0.0\nrtol::Float64\nDefault: Cuba.RTOL\natol::Float64\nDefault: Cuba.ATOL\nminevals::Int64\nDefault: Cuba.MINEVALS\nmaxevals::Int64\nDefault: Cuba.MAXEVALS\nkey1::Int64\nDefault: Cuba.KEY1\nkey2::Int64\nDefault: Cuba.KEY2\nkey3::Int64\nDefault: Cuba.KEY3\nmaxpass::Int64\nDefault: Cuba.MAXPASS\nborder::Float64\nDefault: Cuba.BORDER\nmaxchisq::Float64\nDefault: Cuba.MAXCHISQ\nmindeviation::Float64\nDefault: Cuba.MINDEVIATION\nngiven::Int64\nDefault: Cuba.NGIVEN\nldxgiven::Int64\nDefault: Cuba.LDXGIVEN\nnextra::Int64\nDefault: Cuba.NEXTRA\nnthreads::Int64\nDefault: Base.Threads.nthreads()\nstrict::Bool\nDefault: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.GridSampler","page":"Experimental Features","title":"BAT.GridSampler","text":"struct GridSampler <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nSample from equidistantly distributed points in each dimension.\n\nConstructors:\n\nGridSampler(; fields...)\n\nFields:\n\ntrafo::AbstractDensityTransformTarget\nDefault: PriorToUniform()\nppa::Int64\nDefault: 100\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.HierarchicalDistribution","page":"Experimental Features","title":"BAT.HierarchicalDistribution","text":"struct HierarchicalDistribution <: ContinuousDistribution\n\nExperimental feature, not part of stable public API.\n\nA hierarchical distribution, useful for hierarchical models/priors.\n\nConstructors:\n\nHierarchicalDistribution(f::Function, primary_dist::NamedTupleDist)\n\nwith a functon f that returns a ContinuousDistribution for any variate v drawn from primary_dist.\n\nExample:\n\nhd = HierarchicalDistribution(\n    v -> NamedTupleDist(\n        baz = fill(Normal(v.bar, v.foo), 3)\n    ),\n    NamedTupleDist(\n        foo = Exponential(3.5),\n        bar = Normal(2.0, 1.0)\n    )\n)\n\nvarshape(hd) == NamedTupleShape(\n    foo = ScalarShape{Real}(),\n    bar = ScalarShape{Real}(),\n    baz = ArrayShape{Real}(3)\n)\n\nv = rand(hd)\n\nnote: Note\nAll fields of HierarchicalDistribution are considered internal and subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.PartitionedSampling","page":"Experimental Features","title":"BAT.PartitionedSampling","text":"struct PartitionedSampling <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nA sampling algorithm that partitions parameter space into multiple subspaces and samples/integrates them independently (Caldwell et al.).\n\nConstructors:\n\nPartitionedSampling(; fields...)\n\nFields:\n\ntrafo::AbstractDensityTransformTarget\nDefault: PriorToUniform()\nnpartitions::Integer\nDefault: 10\nsampler::BAT.AbstractSamplingAlgorithm\nDefault: MCMCSampling()\nexploration_sampler::BAT.AbstractSamplingAlgorithm\nDefault: MCMCSampling(nchains = 30)\npartitioner::SpacePartitioningAlgorithm\nDefault: KDTreePartitioning()\nintegrator::IntegrationAlgorithm\nDefault: AHMIntegration()\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.PriorImportanceSampler","page":"Experimental Features","title":"BAT.PriorImportanceSampler","text":"struct PriorImportanceSampler <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nImportance sampler using IID samples from the prior.\n\nConstructors:\n\nPriorImportanceSampler(; fields...)\n\nFields:\n\nnsamples::Int64\nDefault: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.SobolSampler","page":"Experimental Features","title":"BAT.SobolSampler","text":"struct SobolSampler <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nSample from Sobol sequence. Also see Sobol.jl.\n\nConstructors:\n\nSobolSampler(; fields...)\n\nFields:\n\ntrafo::AbstractDensityTransformTarget\nDefault: PriorToUniform()\nnsamples::Int64\nDefault: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.SuaveIntegration","page":"Experimental Features","title":"BAT.SuaveIntegration","text":"struct SuaveIntegration <: IntegrationAlgorithm\n\nExperimental feature, not part of stable public API.\n\nSuaveIntegration integration algorithm.\n\nConstructors:\n\nSuaveIntegration(; fields...)\n\nFields:\n\ntrafo::AbstractDensityTransformTarget\nDefault: PriorToUniform()\nlog_density_shift::Float64\nDefault: 0.0\nrtol::Float64\nDefault: Cuba.RTOL\natol::Float64\nDefault: Cuba.ATOL\nminevals::Int64\nDefault: Cuba.MINEVALS\nmaxevals::Int64\nDefault: Cuba.MAXEVALS\nnnew::Int64\nDefault: Cuba.NNEW\nnmin::Int64\nDefault: Cuba.NMIN\nflatness::Float64\nDefault: Cuba.FLATNESS\nnthreads::Int64\nDefault: Base.Threads.nthreads()\nstrict::Bool\nDefault: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.VEGASIntegration","page":"Experimental Features","title":"BAT.VEGASIntegration","text":"struct VEGASIntegration <: IntegrationAlgorithm\n\nExperimental feature, not part of stable public API.\n\nVEGASIntegration integration algorithm.\n\nConstructors:\n\nVEGASIntegration(; fields...)\n\nFields:\n\ntrafo::AbstractDensityTransformTarget\nDefault: PriorToUniform()\nlog_density_shift::Float64\nDefault: 0.0\nrtol::Float64\nDefault: Cuba.RTOL\natol::Float64\nDefault: Cuba.ATOL\nminevals::Int64\nDefault: Cuba.MINEVALS\nmaxevals::Int64\nDefault: Cuba.MAXEVALS\nnstart::Int64\nDefault: Cuba.NSTART\nnincrease::Int64\nDefault: Cuba.NINCREASE\nnbatch::Int64\nDefault: Cuba.NBATCH\nnthreads::Int64\nDefault: Base.Threads.nthreads()\nstrict::Bool\nDefault: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"#BAT.jl-Documentation","page":"Home","title":"BAT.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BAT.jl is a Bayesian Analysis Toolkit in Julia. It is a high-performance tool box for Bayesian inference with statistical models expressed in a general-purpose programming language instead of a domain-specific language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Typical applications for this package are parameter inference given a model (in the form of a likelihood function and prior), the comparison of different models in the light of a given data set, and the test of the validity of a model to represent the data set at hand. BAT.jl provides access to the full Bayesian posterior distribution to enable parameter estimation, limit setting and uncertainty propagation. BAT.jl also provides supporting functionality like plotting recipes and reporting functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BAT.jl is implemented in pure Julia and allows for a flexible definition of mathematical models and applications while enabling the user to code for the performance required for computationally expensive numerical operations. BAT.jl provides implementations (internally and via other Julia packages) of algorithms for sampling, optimization and integration. BAT's main focus is on the analysis of complex custom models. It is designed to enable parallel code execution at various levels (running multiple MCMC chains in parallel is provided out-of-the-box).","category":"page"},{"location":"","page":"Home","title":"Home","text":"It's possible to use BAT.jl with likelihood functions implemented in languages other than Julia: Julia allows for calling code in C and Fortran, C++, Python and several other languages directly. In addition, BAT.jl provides (as an experimental feature) a very lightweight binary RPC protocol that is easy to implement, to call non-Julia likelihood functions written in another language and running in separate processes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BAT.jl originated as a rewrite/redesign of BAT, the Bayesian Analysis Toolkit in C++. BAT.jl now offer a different set of functionality and a wider variety of algorithms than it's C++ predecessor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nBAT.jl requires Julia >= v1.3, we recommend to use Julia >= v1.6.","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    # \"basics.md\",\n    \"installation.md\",\n    \"tutorial.md\",\n    # \"faq.md\",\n    # \"examples.md\",\n    # \"algorithms.md\",\n    # \"benchmarks.md\",\n    # \"publications.md\",\n    \"api.md\",\n    \"developing.md\",\n    \"license.md\",\n]\nDepth = 1","category":"page"},{"location":"#Citing-BAT.jl","page":"Home","title":"Citing BAT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When using BAT.jl for research, teaching or similar, please cite Schulz et al. \"BAT.jl: A Julia-Based Tool for Bayesian Inference\", SNCS (2021).","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Schulz:2021BAT,\n  author  = {Schulz, Oliver and Beaujean, Frederik and Caldwell, Allen and Grunwald, Cornelius and Hafych, Vasyl and Kr{\\\"o}ninger, Kevin and Cagnina, Salvatore La and R{\\\"o}hrig, Lars and Shtembari, Lolian},\n  journal = {SN Computer Science},\n  title   = {BAT.jl: A Julia-Based Tool for Bayesian Inference},\n  year    = {2021},\n  issn    = {2661-8907},\n  month   = {Apr},\n  number  = {3},\n  pages   = {210},\n  volume  = {2},\n  day     = {12},\n  doi     = {10.1007/s42979-021-00626-4},\n  url     = {https://doi.org/10.1007/s42979-021-00626-4},\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use BAT.AHMIntegration as an important part of your work, please also cite  Caldwell et al. \"Integration with an Adaptive Harmonic Mean Algorithm\", IJMPA (2020).","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Caldwell:2020AHMI,\n  author    = {Caldwell, Allen and Eller, Philipp and Hafych, Vasyl and Schick, Rafael and Schulz, Oliver and Szalay, Marco},\n  journal   = {International Journal of Modern Physics A},\n  title     = {Integration with an adaptive harmonic mean algorithm},\n  year      = {2020},\n  number    = {24},\n  pages     = {2050142},\n  volume    = {35},\n  doi       = {10.1142/S0217751X20501420},\n  publisher = {World Scientific},\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use BAT.PartitionedSampling (experimental feature) as an important part of your work, please also cite  Hafych et al. \"Parallelizing MCMC Sampling via Space Partitioning\", arXiv:2008.03098 (2020).","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Hafych:2008.03098,\n  author        = {Hafych, Vasyl and Eller, Philipp and Caldwell, Allen and Schulz, Oliver},\n  title         = {Parallelizing MCMC Sampling via Space Partitioning},\n  year          = {2018},\n  month         = {8},\n  archiveprefix = {arXiv},\n  eprint        = {2008.03098},\n  primaryclass  = {stat.CO},\n}","category":"page"},{"location":"#Learning-(more-about)-Julia","page":"Home","title":"Learning (more about) Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BAT.jl supersedes BAT in C++. If you're considering to switch to BAT.jl, but you're new to Julia and want to learn more about the the language, here are a few resources to get started:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Julia website provides many links to introductory videos and written tutorials, e.g. \"Intro to Julia\", Think Julia: How to Think Like a Computer Scientist and \"The Fast Track to Julia\". If you are familar with MATLAB or Python, you may also want to take a look at the \"MATLAB–Python–Julia cheatsheet\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"The in-depth article Why Numba and Cython are not substitutes for Julia explains how Julia addresses several fundamental challenges inherent to scientific high-performance computing.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We acknowledge the contributions from all the BAT.jl users, they help us make BAT.jl a better project. Your help is most welcome!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Development of BAT.jl has been supported by funding from","category":"page"},{"location":"","page":"Home","title":"Home","text":"Deutsche Forschungsgemeinschaft (DFG, German Research Foundation)\nEuropean Union Framework Programme for Research and Innovation Horizon 2020 (2014-2020) under the Marie Sklodowska-Curie Grant Agreement No.765710","category":"page"},{"location":"faq/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"... to be written ...","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/bat/BAT.jl/blob/master/docs/src/tutorial_lit.jl\"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates a simple application of BAT.jl: A Bayesian fit of a histogram with two Gaussian peaks.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Table of contents:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pages = [\"tutorial.md\"]\nDepth = 3","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note: This tutorial is somewhat verbose, as it aims to be easy to follow for users who are new to Julia. For the same reason, we deliberately avoid making use of Julia features like closures, anonymous functions, broadcasting syntax, performance annotations, etc.","category":"page"},{"location":"tutorial/#Input-Data-Generation","page":"Tutorial","title":"Input Data Generation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, let's generate some synthetic data to fit. We'll need the Julia standard-library packages \"Random\", \"LinearAlgebra\" and \"Statistics\", as well as the packages \"Distributions\" and \"StatsBase\":","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Random, LinearAlgebra, Statistics, Distributions, StatsBase","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As the underlying truth of our input data/histogram, let us choose an non-normalized probability density composed of two Gaussian peaks with a peak area of 500 and 1000, a mean of -1.0 and 2.0 and a standard error of 0.5","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"data = vcat(\n    rand(Normal(-1.0, 0.5), 500),\n    rand(Normal( 2.0, 0.5), 1000)\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"resulting in a vector of floating-point numbers:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"typeof(data) == Vector{Float64}","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we'll create a histogram of that data, this histogram will serve as the input for the Bayesian fit:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hist = append!(Histogram(-2:0.1:4), data)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using the Julia \"Plots\" package","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we can plot the histogram:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data\"\n)\nsavefig(\"tutorial-data.pdf\")\nsavefig(\"tutorial-data.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Data)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's define our fit function - the function that we expect to describe the data histogram, at each x-Axis position x, depending on a given set p of model parameters:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function fit_function(p::NamedTuple{(:a, :mu, :sigma)}, x::Real)\n    p.a[1] * pdf(Normal(p.mu[1], p.sigma), x) +\n    p.a[2] * pdf(Normal(p.mu[2], p.sigma), x)\nend\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The fit parameters (model parameters) a (peak areas) and mu (peak means) are vectors, parameter sigma (peak width) is a scalar, we assume it's the same for both Gaussian peaks.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The true values for the model/fit parameters are the values we used to generate the data:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"true_par_values = (a = [500, 1000], mu = (-1.0, 2.0), sigma = 0.5)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's visually compare the histogram and the fit function, using these true parameter values, to make sure everything is set up correctly:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data and True Statistical Model\"\n)\nplot!(\n    -4:0.01:4, x -> fit_function(true_par_values, x),\n    label = \"Truth\"\n)\nsavefig(\"tutorial-data-and-truth.pdf\")\nsavefig(\"tutorial-data-and-truth.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Data and True Statistical Model)","category":"page"},{"location":"tutorial/#Bayesian-Fit","page":"Tutorial","title":"Bayesian Fit","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we'll perform a Bayesian fit of the generated histogram, using BAT, to infer the model parameters from the data histogram.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition to the Julia packages loaded above, we need BAT itself, as well as IntervalSets:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using BAT, IntervalSets","category":"page"},{"location":"tutorial/#Likelihood-Definition","page":"Tutorial","title":"Likelihood Definition","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, we need to define the likelihood (function) for our problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT represents densities like likelihoods and priors as subtypes of BAT.AbstractDensity. Custom likelihood can be defined by creating a new subtype of AbstractDensity and by implementing (at minimum) BAT.eval_logval_unchecked for that type - in complex uses cases, this may become necessary. Typically, however, it is sufficient to define a custom likelihood as a simple function that returns the log-likelihood value for a given set of parameters. BAT will automatically convert such a likelihood function into a subtype of AbstractDensity.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For performance reasons, functions should not access global variables directly. So we'll use an anonymous function inside of a let-statement to capture the value of the global variable hist in a local variable h (and to shorten function name fit_function to f, purely for convenience). The likelihood function wraps it's result in a LogDVal to indicate that it returns a log-likelihood value:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"likelihood = let h = hist, f = fit_function\n    # Histogram counts for each bin as an array:\n    observed_counts = h.weights\n\n    # Histogram binning:\n    bin_edges = h.edges[1]\n    bin_edges_left = bin_edges[1:end-1]\n    bin_edges_right = bin_edges[2:end]\n    bin_widths = bin_edges_right - bin_edges_left\n    bin_centers = (bin_edges_right + bin_edges_left) / 2\n\n    params -> begin\n        # Log-likelihood for a single bin:\n        function bin_log_likelihood(i)\n            # Simple mid-point rule integration of fit function `f` over bin:\n            expected_counts = bin_widths[i] * f(params, bin_centers[i])\n            logpdf(Poisson(expected_counts), observed_counts[i])\n        end\n\n        # Sum log-likelihood over bins:\n        idxs = eachindex(observed_counts)\n        ll_value = bin_log_likelihood(idxs[1])\n        for i in idxs[2:end]\n            ll_value += bin_log_likelihood(i)\n        end\n\n        # Wrap `ll_value` in `LogDVal` so BAT knows it's a log density-value.\n        return LogDVal(ll_value)\n    end\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT makes use of Julia's parallel programming facilities if possible, e.g. to run multiple Markov chains in parallel. Therefore, log-likelihood (and other) code must be thread-safe. Mark non-thread-safe code with @critical (provided by Julia package ParallelProcessingTools).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Support for automatic parallelization across multiple (local and remote) Julia processes is planned, but not implemented yet.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that Julia currently starts only a single thread by default. Set the the environment variable JULIA_NUM_THREADS to specify the desired number of Julia threads.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can evaluate likelihood, e.g. for the true parameter values:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"likelihood(true_par_values)","category":"page"},{"location":"tutorial/#Prior-Definition","page":"Tutorial","title":"Prior Definition","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we need to choose a sensible prior for the fit:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using ValueShapes\n\nprior = NamedTupleDist(\n    a = [Weibull(1.1, 5000), Weibull(1.1, 5000)],\n    mu = [-2.0..0.0, 1.0..3.0],\n    sigma = Weibull(1.2, 2)\n)\n\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In general, BAT allows instances of any subtype of AbstractDensity to be uses as a prior, as long as a sampler is defined for it. This way, users may implement complex application-specific priors. You can also use convert(AbstractDensity, distribution) to convert any continuous multivariate Distributions.Distribution to a BAT.AbstractDensity that can be used as a prior (or likelihood).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The prior also implies the shapes of the parameters:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"parshapes = varshape(prior)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"These will come in handy later on, e.g. to access (the posterior distribution of) individual parameter values.","category":"page"},{"location":"tutorial/#Bayesian-Model-Definition","page":"Tutorial","title":"Bayesian Model Definition","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given the likelihood and prior definition, a BAT.PosteriorDensity is simply defined via","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"posterior = PosteriorDensity(likelihood, prior)\nnothing # hide","category":"page"},{"location":"tutorial/#Parameter-Space-Exploration-via-MCMC","page":"Tutorial","title":"Parameter Space Exploration via MCMC","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now use Markov chain Monte Carlo (MCMC) to explore the space of possible parameter values for the histogram fit.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To increase the verbosity level of BAT logging output, you may want to set the Julia logging level for BAT to debug via ENV[\"JULIA_DEBUG\"] = \"BAT\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can generate a set of MCMC samples via bat_sample. We'll use 4 MCMC chains with 10^5 MC steps in each chain (after tuning/burn-in):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"samples = bat_sample(posterior, MCMCSampling(mcalg = MetropolisHastings(), nsteps = 10^5, nchains = 4)).result\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Construct a SampledDensity to get a quick overview of the properties of the sampled posterior, estimates of the fit parameters:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SampledDensity(posterior, samples)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's calculate some statistics on the posterior samples:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"Truth: $true_par_values\")\nprintln(\"Mode: $(mode(samples))\")\nprintln(\"Mean: $(mean(samples))\")\nprintln(\"Stddev: $(std(samples))\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Internally, BAT often needs to represent variates as flat real-valued vectors:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"unshaped.(samples).v","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT uses ValueShapes.jl to implement a dual view of variate values in both shaped and unshaped form, based on shape inferred from the prior and propagated to the posterior. Shaped and unshaped samples are views of the same data in memory. The variate/parameter shape can be accessed via","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"parshapes = varshape(posterior)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The statisics above (mode, mean and std-dev) are presented in shaped form. However, it's not possible to represent statistics with matrix shape, e.g. the parameter covariance matrix, this way. So the covariance has to be accessed in unshaped form:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"par_cov = cov(unshaped.(samples))\nprintln(\"Covariance: $par_cov\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Our parshapes is a NamedTupleShape. It's properties (i.e. individual parameter accessors) can be used as indices to query the covariance between specific parameters:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"par_cov[parshapes.mu, parshapes.sigma]","category":"page"},{"location":"tutorial/#Visualization-of-Results","page":"Tutorial","title":"Visualization of Results","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT.jl comes with an extensive set of plotting recipes for \"Plots.jl\". We can plot the marginalized distribution for a single parameter (e.g. parameter 3, i.e. μ[1]):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples, :(mu[1]),\n    mean = true, std = true, globalmode = true, marginalmode = true,\n    nbins = 50, title = \"Marginalized Distribution for mu[1]\"\n)\nsavefig(\"tutorial-single-par.pdf\")\nsavefig(\"tutorial-single-par.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Marginalized Distribution for mu_1)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"or plot the marginalized distribution for a pair of parameters (e.g. parameters 3 and 5, i.e. μ[1] and σ), including information from the parameter stats:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples, (:(mu[1]), :sigma),\n    mean = true, std = true, globalmode = true, marginalmode = true,\n    nbins = 50, title = \"Marginalized Distribution for mu[1] and sigma\"\n)\nplot!(BAT.MCMCBasicStats(samples), (3, 5))\nsavefig(\"tutorial-param-pair.png\")\nsavefig(\"tutorial-param-pair.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Marginalized Distribution for mu_1 and sigma)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also create an overview plot of the marginalized distribution for all pairs of parameters:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples,\n    mean = false, std = false, globalmode = true, marginalmode = false,\n    nbins = 50\n)\nsavefig(\"tutorial-all-params.png\")\nsavefig(\"tutorial-all-params.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Pairwise Correlation between Parameters)","category":"page"},{"location":"tutorial/#Integration-with-Tables.jl","page":"Tutorial","title":"Integration with Tables.jl","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DensitySamplesVector supports the Tables.jl interface, so it is a table itself. We can also convert it to other table types, e.g. a TypedTables.Table:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TypedTables\n\ntbl = Table(samples)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"or a DataFrames.DataFrame, etc.","category":"page"},{"location":"tutorial/#Comparison-of-Truth-and-Best-Fit","page":"Tutorial","title":"Comparison of Truth and Best Fit","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As a final step, we retrieve the parameter values at the mode, representing the best-fit parameters","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"samples_mode = mode(samples)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Like the samples themselves, the result can be viewed in both shaped and unshaped form. samples_mode is presented as a 0-dimensional array that contains a NamedTuple, this representation preserves the shape information:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"samples_mode[] isa NamedTuple\n\nunshaped(samples_mode)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"samples_mode is only an estimate of the mode of the posterior distribution. It can be further refined using bat_findmode:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"findmode_result = bat_findmode(posterior, MaxDensityNelderMead(init = ExplicitInit([samples_mode])))\n\nfit_par_values = findmode_result.result[]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's plot the data and fit function given the true parameters and MCMC samples","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(-4:0.01:4, fit_function, samples)\n\nplot!(\n    normalize(hist, mode=:density),\n    color=1, linewidth=2, fillalpha=0.0,\n    st = :steps, fill=false, label = \"Data\",\n    title = \"Data, True Model and Best Fit\"\n)\n\nplot!(-4:0.01:4, x -> fit_function(true_par_values, x), color=4, label = \"Truth\")\nsavefig(\"tutorial-data-truth-bestfit.pdf\")\nsavefig(\"tutorial-data-truth-bestfit.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Data, True Model and Best Fit)","category":"page"},{"location":"tutorial/#Fine-grained-control","page":"Tutorial","title":"Fine-grained control","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT provides fine-grained control over the MCMC algorithm options, the MCMC chain initialization, tuning/burn-in strategy and convergence testing. All option value used in the following are the default values, any or all may be omitted.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We'll sample using the The Metropolis-Hastings MCMC algorithm:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mcmcalgo = MetropolisHastings(\n    weighting = RepetitionWeighting(),\n    tuning = AdaptiveMHTuning()\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT requires a counter-based random number generator (RNG), since it partitions the RNG space over the MCMC chains. This way, a single RNG seed is sufficient for all chains and results are reproducible even under parallel execution. By default, BAT uses a Philox4x RNG initialized with a random seed drawn from the system entropy pool:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Random123\nrng = Philox4x()\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By default, MetropolisHastings() uses the following options.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For Markov chain initialization:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"init = MCMCChainPoolInit()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the MCMC burn-in procedure:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"burnin = MCMCMultiCycleBurnin()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For convergence testing:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"convergence = BrooksGelmanConvergence()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To generate MCMC samples with explicit control over all options, use something like","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"samples = bat_sample(\n    rng, posterior,\n    MCMCSampling(\n        mcalg = mcmcalgo,\n        nchains = 4,\n        nsteps = 10^5,\n        init = init,\n        burnin = burnin,\n        convergence = convergence,\n        strict = true,\n        store_burnin = false,\n        nonzero_weights = true,\n        callback = (x...) -> nothing\n    )\n).result\nnothing # hide","category":"page"},{"location":"tutorial/#Saving-result-data-to-files","page":"Tutorial","title":"Saving result data to files","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The package FileIO.jl(in conjuction with JLD2.jl) offers a convenient way to store results like posterior samples to file:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FileIO\nFileIO.save(\"results.jld2\", Dict(\"samples\" => samples))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"JLD2 persists the full information (including value shapes), so you can reload exactly the same data into memory in a new Julia session via","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FileIO, BAT\nsamples = FileIO.load(\"results.jld2\", \"samples\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"provided you use compatible versions of BAT and it's dependencies. Note that JLD2 is not a long-term stable file format. Also note that this functionality is provided by FileIO.jl and JLD2.jl and not part of the BAT API itself.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT.jl itself can write samples to standard HDF5 files in a form suitable for long-term storage (via HDF5.jl):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"import HDF5\nbat_write(\"results.h5\", samples)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The resulting files have an intuitive HDF5 layout and can be read with the standard HDF5 libraries, so they are easily accessible from other programming languages as well. Not all value shape information can be preserved, though. To read BAT.jl HDF5 sample data, use","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using BAT\nimport HDF5\nsamples = bat_read(\"results.h5\").result","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT.jl's HDF5 file format may evolve over time, but future versions of BAT.jl will be able to read HDF5 sample data written by this version of BAT.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
