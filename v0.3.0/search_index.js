var documenterSearchIndex = {"docs":
[{"location":"#BAT.jl-Documentation-1","page":"Home","title":"BAT.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl stands for Bayesian Analysis Toolkit in Julia. It is a high high-performance tool box for Bayesian inference with statistical models expressed in a general-purpose programming language, instead of a domain-specific language.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Typical applications for this package are the extraction of the values of the parameters of a model, the comparison of different models in the light of a given data set and the test of the validity of a model to represent the data set at hand. BAT.jl provides access to the full Bayesian posterior distribution to enable parameter estimation, limit setting and uncertainty propagation. BAT.jl also provides supporting functionality like plotting recipes and reporting functions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl is implemented in pure Julia and allows for a flexible definition of mathematical models and applications while enabling the user to code for the performance required for computationally expensive numerical operations. BAT.jl provides implementations (internally and via other Julia packages) of algorithms for sampling, optimization and integration. A few predefined models will be  provided for standard cases such as histogram fitting and simple counting experiments (work in progress), but BAT's main focus is on the analysis of complex custom models. It is designed to enable multi-threaded and distributed (work in progress) code execution at various levels, running multiple MCMC chains in parallel is provided out-of-the-box.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"It's possible to use BAT.jl with likelihood functions implemented in languages other than Julia: Julia allows for calling code in C and Fortran, C++, Python and several other languages directly. In addition, BAT.jl provides a very lightweight binary RPC protocol that is easy to implement, to call non-Julia functions written in any language, running in separate processes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nBAT.jl requires Julia v1.2.","category":"page"},{"location":"#History-and-Status-1","page":"Home","title":"History and Status","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl is a complete rewrite of BAT, the Bayesian Analysis Toolkit in C++. BAT.jl is still a work in progress: It already provides several improvements over it's C++ predecessor, but has not yet reached feature parity.","category":"page"},{"location":"#Table-of-contents-1","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    # \"basics.md\",\n    \"installation.md\",\n    \"tutorial.md\",\n    # \"faq.md\",\n    # \"examples.md\",\n    # \"algorithms.md\",\n    # \"benchmarks.md\",\n    # \"publications.md\",\n    \"api.md\",\n    \"developing.md\",\n    \"license.md\",\n]\nDepth = 1","category":"page"},{"location":"#Citing-BAT.jl-1","page":"Home","title":"Citing BAT.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"When using BAT.jl for work that will result in a scientific publication, please cite","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Caldwell et al., BAT.jl - A Bayesian Analysis Toolkit in Julia, doi:10.5281/zenodo.2605312","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The DOI above is version-independent, you may want to use the DOI of the specific BAT.jl version used in your work.","category":"page"},{"location":"#Learning-(more-about)-Julia-1","page":"Home","title":"Learning (more about) Julia","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BAT.jl is intended to supersede BAT in C++, long term. If you're considering to switch to BAT.jl but you're new to Julia and want to learn more about the the language, here are a few resources to get started:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The Julia website provides many links to introductory videos and written tutorials, e.g. \"Intro to Julia\", \"A Deep Introduction to Julia for Data Science and Scientific Computing\" and \"The Fast Track to Julia 1.0\". If you are familar with MATLAB or Python, you may also want to take a look at the \"MATLAB–Python–Julia cheatsheet\".","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note: Try to avoid tutorials and books written for older versions of Julia, as there have been quite a few changes to the language in v1.0.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"There are also a lot of interesting talks and tutorials on the Julia YouTube Channel. Have a look at the talks at JuliaCon 2018 to get an impression on the kinds of scientific applications Julia is being used for and why, e.g. \"Why Julia is the most suitable language for science\".","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The in-depth article Why Numba and Cython are not substitutes for Julia explains how Julia addresses several fundamental challenges inherent to scientific high-performance computing.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you want to get an impression of the attention to detail so typical for Julia, watch \"0.1 vs 1//10: How numbers are compared\".","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We acknowledge the contributions from all the BAT.jl users, they help us make BAT.jl a better project. Your help is most welcome!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Development of BAT.jl has been supported by funding from","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Deutsche Forschungsgemeinschaft (DFG, German Research Foundation)","category":"page"},{"location":"installation/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"BAT.jl is written in the Julia programming language. To use BAT.jl, you will need to install Julia itself, the BAT.jl Julia package, and some additional Julia packages. Depending on your use case, you may also want to need a Python installation with certain Python packages (optional).","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Table of contents:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Pages = [\"installation.md\"]\nDepth = 3","category":"page"},{"location":"installation/#Prerequisites-1","page":"Installation","title":"Prerequisites","text":"","category":"section"},{"location":"installation/#OS-Specific-Prerequisites-1","page":"Installation","title":"OS-Specific Prerequisites","text":"","category":"section"},{"location":"installation/#Mac-OS-X-1","page":"Installation","title":"Mac OS-X","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"TODO:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On OS-X, you need to install the Apple command line developer tools. They are required by the Julia package Homebrew.jl, which in turn is required by lot's of other Julia packages.","category":"page"},{"location":"installation/#Installing-Julia-1","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Julia is available for Linux, OS-X and Windows, and easy to install:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Download Julia.\nExtract the archive, resp. run the installer.\nYou'll probably want to add the Julia bin directory to your $PATH","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"note: Note\nBAT.jl requires Julia v1.2.","category":"page"},{"location":"installation/#Installing-Jupyter-and-matplotlib/pyplot-(Optional)-1","page":"Installation","title":"Installing Jupyter and matplotlib/pyplot (Optional)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"If you plan to use Jupyter notebooks and/or the matplotlib/pyplot backend of the Julia Plots.jl package, you will also need a Python installation and certain Python packages (see below). BAT.jl is fully usable without Jupyter and matplotlib/pyplot, but both can come in very handy.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Julia can either use existing installations of Jupyter and pyplot , or install both internally by creating an internal Conda installation within $HOME/.julia/conda. We recommend the first approach (especially using Anaconda), since Julia will otherwise have to download over 1 GB of software, the $HOME/.julia directory will grow very large, and require you to start Jupyter in an indirect fashion via Julia (only to have Jupyter then start additional Julia instances as Jupyter kernels in return).","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"For details, see the IJulia.jl, PyCall.jl and PyPlot.jl documentation (you should not need to if you follow the steps below).","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"On Linux, Julia (more specifically the Julia packages IJulia.jl, PyCall.jl, and PyPlot.jl) will by default try to use the matplotlib/pyplot installation associated with the python3 (resp. python) executable on your $PATH. Likewise, Julia will by default try to use the Jupyter installation associated with the jupyter executable on your $PATH.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"However, on OS-X and Windows, both IJulia.jl and PyCall.jl by default always create a Julia-internal Conda installation (see above), even if Jupyter and matplotlib/pyplot are available (apparently broken Jupyter/Python installations on these platforms caused frequent support requests).  In contrast to this default behavior, we recommend to use a standalone Jupyter and Python installation on all OS platforms. Set the environment variables $JUPYTER and $PYTHON to point to your Jupyter and Python executable to force Julia to use the existing installation.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"We recommend that you install the Anaconda Python distribution, it includes both Jupyter and pyplot (it is of course possible to use non-Anaconda Jupyter and pyplot installations instead).","category":"page"},{"location":"installation/#Installing-Anaconda-(Optional)-1","page":"Installation","title":"Installing Anaconda (Optional)","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To install Anaconda","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Download Anaconda.\nRun the installer\nSet the environment variables $JUPYTER and $PYTHON to the full path of the Jupyter and Python executables (see above).","category":"page"},{"location":"installation/#Environment-Variables-1","page":"Installation","title":"Environment Variables","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"You may want/need to set the following environment variables:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"$PATH: Include the Julia bin-directory in your binary search path, see above.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"If you intend to use Jupyter, you will probably want to include the directory containing the jupyter binary to your PATH as well.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"$JUPYTER: See above, only when using Jupyter\n$PYTHON: See above, only when using the Plots.jl matplotlib/pyplot backend.\n$JULIA_NUM_THREADS: Number of threads to use for Julia multi-threading\n$JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR: If you want Julia to install packages in another location than $HOME/.julia.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"See the Julia manual for a description of other Julia-specific environment variables.","category":"page"},{"location":"installation/#Installing-BAT.jl-and-Other-Julia-Packages-1","page":"Installation","title":"Installing BAT.jl and Other Julia Packages","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"BAT.jl is provided as a registered Julia package. To install it, simply run","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> pkg\"add BAT\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"However, you will likely need other Julia packages too. We recommend that you install certain statistics, plotting, I/O and array packages as well:","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> pkg\"add BAT ArraysOfArrays Distributions ElasticArrays HDF5 IntervalSets Plots ShapesOfVariables StatsBase Tables TypedTables\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To install the latest development version of BAT (master branch), instead of the latest stable release, use","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia> pkg\"add BAT#master\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"TODO: PRECOMPILE","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To use the the Jupyter Julia kernel, you also need to install the package \"IJulia\":","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"pkg\"add IJulia\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"To use the Plots.jl matplotlib/pyplot backend (see above), you also need to add the package \"PyPlot\":","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"pkg\"add PyPlot\"","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Depending on your application, you may want to install additional Julia packages.","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Note: If you want Julia to install packages in another location than $HOME/.julia, set the environment variables JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR (see above).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/bat/BAT.jl/blob/master/docs/src/tutorial_lit.jl\"","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates a simple application of BAT.jl: A Bayesian fit of a histogram with two Gaussian peaks.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"You can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Table of contents:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Pages = [\"tutorial.md\"]\nDepth = 3","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note: This tutorial is somewhat verbose, as it aims to be easy to follow for users who are new to Julia. For the same reason, we deliberately avoid making use of Julia features like closures, anonymous functions, broadcasting syntax, performance annotations, etc.","category":"page"},{"location":"tutorial/#Input-Data-Generation-1","page":"Tutorial","title":"Input Data Generation","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"First, let's generate some synthetic data to fit. We'll need the Julia standard-library packages \"Random\", \"LinearAlgebra\" and \"Statistics\", as well as the packages \"Distributions\" and \"StatsBase\":","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Random, LinearAlgebra, Statistics, Distributions, StatsBase","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"As the underlying truth of our input data/histogram, let us choose an non-normalized probability density composed of two Gaussian peaks with a peak area of 500 and 1000, a mean of -1.0 and 2.0 and a standard error of 0.5. So our model parameters will be:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"par_names = [\"a_1\", \"a_2\", \"mu_1\", \"mu_2\", \"sigma\"]\n\ntrue_par_values = [500, 1000, -1.0, 2.0, 0.5]\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We'll define a function that returns two Gaussian distributions, based on a specific set of parameters","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function model_distributions(parameters::AbstractVector{<:Real})\n    return (\n        Normal(parameters[3], parameters[5]),\n        Normal(parameters[4], parameters[5])\n    )\nend\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"and then generate some synthetic data by drawing a number (according to the parameters a₁ and a₂) of samples from the two Gaussian distributions","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"data = vcat(\n    rand(model_distributions(true_par_values)[1], Int(true_par_values[1])),\n    rand(model_distributions(true_par_values)[2], Int(true_par_values[2]))\n)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"resulting in a vector of floating-point numbers:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"typeof(data) == Vector{Float64}","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Then we create a histogram of that data, this histogram will serve as the input for the Bayesian fit:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"hist = append!(Histogram(-2:0.1:4), data)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The fit function that describes such a histogram (depending on the model parameters) will be","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function fit_function(x::Real, parameters::AbstractVector{<:Real})\n    dists = model_distributions(parameters)\n    return parameters[1] * pdf(dists[1], x) +\n           parameters[2] * pdf(dists[2], x)\nend\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Using the Julia \"Plots\" package","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Plots","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"we can visually compare the histogram and the fit function, using the true values of the parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data and True Statistical Model\"\n)\nplot!(\n    -4:0.01:4, x -> fit_function(x, true_par_values),\n    label = \"Truth\"\n)\nsavefig(\"tutorial-data-and-truth.pdf\")\nsavefig(\"tutorial-data-and-truth.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Data and True Statistical Model)","category":"page"},{"location":"tutorial/#Bayesian-Fit-1","page":"Tutorial","title":"Bayesian Fit","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now let's do a Bayesian fit of the generated histogram, using BAT.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In addition to the Julia packages loaded above, we need BAT itself, as well as IntervalSets:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using BAT, IntervalSets","category":"page"},{"location":"tutorial/#Likelihood-Definition-1","page":"Tutorial","title":"Likelihood Definition","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"First, we need to define a likelihood function for our problem. In BAT, all likelihood functions and priors are subtypes of BAT.AbstractDensity. We'll store the histogram that we want to fit in our likelihood density type, as accessing the histogram as a global variable would reduce performance:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"struct HistogramLikelihood{H<:Histogram} <: AbstractDensity\n    histogram::H\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"As a minimum, BAT requires methods of BAT.nparams and BAT.unsafe_density_logval to be defined for each subtype of AbstractDensity.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT.nparams simply needs to return the number of free parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT.nparams(likelihood::HistogramLikelihood) = 5","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT.unsafe_density_logval has to implement the actual log-likelihood function:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function BAT.unsafe_density_logval(\n    likelihood::HistogramLikelihood,\n    parameters::AbstractVector{<:Real},\n    exec_context::ExecContext\n)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Histogram counts for each bin as an array:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"    counts = likelihood.histogram.weights","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Histogram binning, has length (length(counts) + 1):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"    binning = likelihood.histogram.edges[1]","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"sum log-likelihood over bins:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"    log_likelihood::Float64 = 0.0\n    for i in eachindex(counts)\n        bin_left, bin_right = binning[i], binning[i+1]\n        bin_width = bin_right - bin_left\n        bin_center = (bin_right + bin_left) / 2\n\n        observed_counts = counts[i]","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Simple mid-point rule integration of fit_function over bin:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"        expected_counts = bin_width * fit_function(bin_center, parameters)\n\n        log_likelihood += logpdf(Poisson(expected_counts), observed_counts)\n    end\n\n    return log_likelihood\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Methods of BAT.unsafe_density_logval may be \"unsafe\" insofar as the implementation is not required to check the length of the parameters vector or the validity of the parameter values - BAT takes care of that (assuming that value provided by BAT.nparams is correct and that the prior that will only cover valid parameter values).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note: Currently, implementations of BAT.unsafedensitylogval must be type stable, to avoid triggering a Julia-internal error. The matter is under investigation. If the implementation of BAT.unsafe_density_logval is not type-stable, this will often result in an error like this:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Internal error: encountered unexpected error in runtime:\nMethodError(f=typeof(Core.Compiler.fieldindex)(), args=(Random123.Philox4x{T, R} ...","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The exec_context argument can be ignored in simple use cases, it is only of interest for unsafe_density_logval methods that internally use Julia's multi-threading and/or distributed code execution capabilities.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT itself also makes use of Julia's parallel programming facilities. BAT can calculate log-density values in parallel (e.g. for multiple MCMC chains) on multiple threads (implemented) and support for distributed execution (on multiple hosts) is planned. By default, however, BAT will assume that implementations of BAT.unsafe_density_logval are not thread safe. If your implementation is thread-safe (as is the case in the example above), you can advertise this fact to BAT:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT.exec_capabilities(::typeof(BAT.unsafe_density_logval), likelihood::HistogramLikelihood, parameters::AbstractVector{<:Real}) =\n    ExecCapabilities(0, true, 0, true)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT will then use multi-threaded log-likelihood evaluation where possible. Note that Julia starts only a single thread by default, you will need to set the environment variable JULIA_NUM_THREADS to configure the number of Julia threads.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Given our fit function and the histogram to fit, we'll define the likelihood as","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"likelihood = HistogramLikelihood(hist)","category":"page"},{"location":"tutorial/#Prior-Definition-1","page":"Tutorial","title":"Prior Definition","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"For simplicity, we choose a flat prior, i.e. a normalized constant density:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"prior = ConstDensity(\n    HyperRectBounds(\n        [\n            0.0..10.0^4, 0.0..10.0^4,\n            -2.0..0.0, 1.0..3.0,\n            0.3..0.7\n        ],\n        reflective_bounds\n    ),\n    normalize\n)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In general, BAT allows instances of any subtype of AbstractDensity to be uses as a prior, as long as a sampler is defined for it. This way, users may implement complex application-specific priors. You can also use convert(AbstractDensity, distribution) to convert any continuous multivariate Distributions.Distribution to a BAT.AbstractDensity that can be used as a prior (or likelihood).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"### Bayesian Model Definition","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Given the likelihood and prior definition, a BAT.BayesianModel is simply defined via","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"model = BayesianModel(likelihood, prior)\nnothing # hide\n\n\n### Parameter Space Exploration via MCMC","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can now use Markov chain Monte Carlo (MCMC) to explore the space of possible parameter values for the histogram fit.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We'll use the Metropolis-Hastings algorithm and a multivariate t-distribution (ν = 1) as it's proposal function:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"algorithm = MetropolisHastings(MvTDistProposalSpec(1.0))\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We also need to which random number generator and seed to use. BAT requires a counter-based RNG and partitions the RNG space over the MCMC chains. This way, a single RNG seed is sufficient for all chains and results can be reproducible even under parallel execution. Let's choose a Philox4x RNG with a random seed:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"rngseed = BAT.Philox4xSeed()\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The algorithm, model and RNG seed specify the MCMC chains:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"chainspec = MCMCSpec(algorithm, model, rngseed)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's use 4 MCMC chains and require 10^5 unique samples from each chain (after tuning/burn-in):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"nsamples = 10^5\nnchains = 4\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT provides fine-grained control over the MCMC tuning algorithm, convergence test and the chain initialization and tuning/burn-in strategy (the values used here are the default values):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"tuner_config = ProposalCovTunerConfig(\n    λ = 0.5,\n    α = 0.15..0.35,\n    β = 1.5,\n    c = 1e-4..1e2\n)\n\nconvergence_test = BGConvergence(1.1)\n\ninit_strategy = MCMCInitStrategy(\n    ninit_tries_per_chain = 8..128,\n    max_nsamples_pretune = 25,\n    max_nsteps_pretune = 250,\n    max_time_pretune = Inf\n)\n\nburnin_strategy = MCMCBurninStrategy(\n    max_nsamples_per_cycle = 1000,\n    max_nsteps_per_cycle = 10000,\n    max_time_per_cycle = Inf,\n    max_ncycles = 30\n)\n\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Before running the Markov chains, let's set BAT's logging level to debug, to see what's going on in more detail (note: BAT's logging API will change in the future for better integration with the Julia v1 logging facilities):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT.Logging.set_log_level!(BAT, BAT.Logging.LOG_DEBUG)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now we can generate a set of MCMC samples via rand:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"samples, sampleids, stats, chains = rand(\n    chainspec,\n    nsamples,\n    nchains,\n    tuner_config = tuner_config,\n    convergence_test = convergence_test,\n    init_strategy = init_strategy,\n    burnin_strategy = burnin_strategy,\n    max_nsteps = 10000,\n    max_time = Inf,\n    granularity = 1,\n    ll = BAT.Logging.LOG_INFO\n)\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note: Reasonable default values are defined for all of the above. In many use cases, a simple","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"samples, sampleids, stats, chains =\n   rand(MCMCSpec(MetropolisHastings(), model), nsamples, nchains)`","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"may be sufficient.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's print some results:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"println(\"Truth: $true_par_values\")\nprintln(\"Mode: $(stats.mode)\")\nprintln(\"Mean: $(stats.param_stats.mean)\")\nprintln(\"Covariance: $(stats.param_stats.cov)\")","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"stats contains some statistics collected during MCMC sample generation, e.g. the mean and covariance of the parameters and the mode. Equal values for these statistics may of course be calculated afterwards, from the samples:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"@assert vec(mean(samples.params, FrequencyWeights(samples.weight))) ≈ stats.param_stats.mean\n@assert vec(var(samples.params, FrequencyWeights(samples.weight))) ≈ diag(stats.param_stats.cov)\n@assert cov(samples.params, FrequencyWeights(samples.weight)) ≈ stats.param_stats.cov","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can also, e.g., get the Pearson auto-correlation of the parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"vec(cor(samples.params, FrequencyWeights(samples.weight)))","category":"page"},{"location":"tutorial/#Visualization-of-Results-1","page":"Tutorial","title":"Visualization of Results","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT.jl comes with an extensive set of plotting recipes for \"Plots.jl\". We can plot the marginalized distribution for a single parameter (e.g. parameter 3, i.e. μ₁):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples, 3,\n    mean = true, std_dev = true, globalmode = true, localmode = true,\n    nbins = 50, xlabel = par_names[3], ylabel = \"P($(par_names[3]))\",\n    title = \"Marginalized Distribution for mu_1\"\n)\nsavefig(\"tutorial-single-par.pdf\")\nsavefig(\"tutorial-single-par.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Marginalized Distribution for mu_1)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"or plot the marginalized distribution for a pair of parameters (e.g. parameters 3 and 5, i.e. μ₁ and σ), including information from the parameter stats:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples, (3, 5),\n    mean = true, std_dev = true, globalmode = true, localmode = true,\n    nbins = 50, xlabel = par_names[3], ylabel = par_names[5],\n    title = \"Marginalized Distribution for mu_1 and sigma\"\n)\nplot!(stats, (3, 5))\nsavefig(\"tutorial-param-pair.pdf\")\nsavefig(\"tutorial-param-pair.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Marginalized Distribution for mu_1 and sigma)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can also create an overview plot of the marginalized distribution for all pairs of parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples,\n    mean = false, std_dev = false, globalmode = true, localmode = false,\n    nbins = 50\n)\nsavefig(\"tutorial-all-params.pdf\")\nsavefig(\"tutorial-all-params.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Pairwise Correlation between Parameters)","category":"page"},{"location":"tutorial/#Integration-with-Tables.jl-1","page":"Tutorial","title":"Integration with Tables.jl","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"BAT.jl supports the Tables.jl interface. Using a tables implementation like TypedTables.jl](http://blog.roames.com/TypedTables.jl/stable/), the whole MCMC output (parameter vectors, weights, sample/chain numbers, etc.) can easily can be combined into a single table:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using TypedTables\n\ntbl = Table(samples, sampleids)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can now, e.g., find the sample with the maximum posterior value (i.e. the mode):","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"mode_log_posterior, mode_idx = findmax(tbl.log_posterior)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"And get row mode_idx of the table, with all information about the sample at the mode:","category":"page"},{"location":"tutorial/#Comparison-of-Truth-and-Best-Fit-1","page":"Tutorial","title":"Comparison of Truth and Best Fit","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"As a final step, we retrieve the parameter values at the mode, representing the best-fit parameters","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"fit_par_values = tbl[mode_idx].params","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"And plot the truth, data, and best fit:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"plot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data, True Model and Best Fit\"\n)\nplot!(-4:0.01:4, x -> fit_function(x, true_par_values), label = \"Truth\")\nplot!(-4:0.01:4, x -> fit_function(x, fit_par_values), label = \"Best fit\")\nsavefig(\"tutorial-data-truth-bestfit.pdf\")\nsavefig(\"tutorial-data-truth-bestfit.svg\"); nothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Data, True Model and Best Fit)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"DocTestSetup  = quote\n    using BAT\nend","category":"page"},{"location":"api/#Types-1","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Order = [:type]","category":"page"},{"location":"api/#Functions-1","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Order = [:function]","category":"page"},{"location":"api/#Documentation-1","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [BAT]\nOrder = [:type, :function]","category":"page"},{"location":"api/#BAT.AbstractDensity","page":"API","title":"BAT.AbstractDensity","text":"AbstractDensity\n\nThe following functions must be implemented for subtypes:\n\nBAT.nparams\nBAT.unsafe_density_logval\n\nIn some cases, it may be desirable to override the default implementations of the functions\n\nBAT.exec_capabilities\nBAT.unsafe_density_logval!\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.AbstractMCMCCallback","page":"API","title":"BAT.AbstractMCMCCallback","text":"AbstractMCMCCallback <: Function\n\nSubtypes (e.g. X) must support\n\n(::X)(level::Integer, chain::MCMCIterator) => nothing\n(::X)(level::Integer, tuner::AbstractMCMCTuner) => nothing\n\nto be compabtible with mcmc_iterate!, mcmc_tune_burnin!, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.AbstractProposalDist","page":"API","title":"BAT.AbstractProposalDist","text":"AbstractProposalDist\n\nThe following functions must be implemented for subtypes:\n\nBAT.distribution_logpdf\nBAT.proposal_rand!\nBAT.nparams, returning the number of parameters (i.e. dimensionality).\nLinearAlgebra.issymmetric, indicating whether p(a -> b) == p(b -> a) holds true.\n\nIn some cases, it may be desirable to override the default implementation of BAT.distribution_logpdf!.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.DataSet","page":"API","title":"BAT.DataSet","text":"DataSet{T<:AbstractFloat, I<:Integer}\n\nHolds the MCMC output. For construction use constructor: function DataSet{T<:Real}(data::Matrix{T}, logprob::Vector{T}, weights::Vector{T})\n\nVariables\n\n'data' : An P x N array with N data points with P parameters.\n'logprob' : The logarithmic probability for each samples stored in an array\n'weights' : How often each sample occurred. Set to an array of ones if working directly on MCMC output\n'ids' : Array which is used to assign each sample to a batch, required for the cov. weighed uncertainty estimation\n.sortids : an array of indices which stores the original ordering of the samples (the space partitioning tree reorders the samples), required to calculate an effective sample size.\n'N' : number of samples\n'P' : number of parameters\n'nsubsets' : the number of batches\n'iswhitened' : a boolean value which indicates whether the data set is iswhitened\n'isnew' : a boolean value which indicates whether the data set was swapped out with a different one (it is possible to redo the integration with a different sample set using previously generated hyper-rectangles)\n'partitioningtree' : The space partitioning tree, used to efficiently identify samples in a point cloud\n'startingIDs' : The Hyper-Rectangle Seed Samples are stored in this array\n'tolerance' : A threshold required for the hyper-rectangle creation process.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.ExecCapabilities","page":"API","title":"BAT.ExecCapabilities","text":"struct ExecCapabilities\n    nthreads::Int\n    threadsafe::Bool\n    nprocs::Int\n    remotesafe::Bool\nend\n\nSpecifies the execution capabilities of functions that support an ExecContext argument.\n\nnthreads specifies the maximum number of threads the function can utilize efficiently, internally. If nthreads <= 1, the function implementation is single-threaded. nthreads == 0 indicates that the function is cheap and that when used in combination with other functions, their capabilities should dominate.\n\nthreadsafe specifies whether the function is thread-safe, and can be can be run on multiple threads in parallel by the caller.\n\nnprocs specifies the maximum number of worker processes the function can utilize efficiently, internally. If procs <= 1, the function cannot use worker processes. nthreads == 0 carries equivalent meaning to nthreads == 0.\n\nremotesafe specifies that the function can be run on a remote thread, it implies that the function arguments can be (de-)serialized safely.\n\nFunctions with an ExecContext argument should announce their capabilities via methods of exec_capabilities. Functions should, ideally, either support internal multithreading (nthreads > 1) or be thread-safe (threadsafe == true). Likewise, functions should either utilize worker processes (nprocs > 1) internally or support remote execution (remotesafe == true) by the caller.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.ExecContext","page":"API","title":"BAT.ExecContext","text":"struct ExecContext\n    use_threads::Bool\n    onprocs::Vector{Int64}\nend\n\nFunctions that take an ExecContext argument must limit their use of threads and processes accordingly. Depending on use_threads, the function may use all (or only a single) thread(s) on each process in onprocs (in addition to the current thread on the current process).\n\nThe caller may choose to change the ExecContext from call to call, based on execution time and latency measurements, etc.\n\nFunctions can announce their BAT.ExecCapabilities via exec_capabilities.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.GRConvergence","page":"API","title":"BAT.GRConvergence","text":"GRConvergence\n\nGelman-Rubin maximum(R^2) convergence test.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.GenericDensity","page":"API","title":"BAT.GenericDensity","text":"GenericDensity{F} <: AbstractDensity\n\nConstructors:\n\nGenericDensity(log_f, nparams::Int)\n\nTurns the logarithmic density function log_f into a BAT-compatible AbstractDensity. log_f must support\n\n`log_f(params::AbstractVector{<:Real})::Real`\n\nwith length(params) == nparams.\n\nIt must be safe to execute log_f in parallel on multiple threads and processes.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.HMIData","page":"API","title":"BAT.HMIData","text":"HMIData{T<:AbstractFloat, I<:Integer}\n\nIncludes all the informations of the integration process, including a list of hyper-rectangles, the results of the whitening transformation, the starting ids, and the average number of points and volume of the created hyper-rectangles.\n\nVariables\n\n'dataset1' : Data Set 1\n'dataset2' : Data Set 2\n'whiteningresult' : contains the whitening matrix and its determinant, required to scale the final integral estimate\n'volumelist1' : An array of integration volumes created using dataset1, but filled with samples from dataset2\n'volumelist2' : An array of integration volumes created using dataset2, but filled with samples from dataset1\n'cubelist1' : An array of small hyper-cubes created around seeding samples of dataset 1\n'cubelist2' : An array of small hyper-cubes created around seeding samples of dataset 2\n'iterations1' : The number of volume adapting iterations for the creating volumelist1\n'iterations2' : The number of volume adapting iterations for the creating volumelist2\n'rejectedrects1' : An array of ids, indicating which hyper-rectangles of volumelist1 were rejected due to trimming\n'rejectedrects2' : An array of ids, indicating which hyper-rectangles of volumelist2 were rejected due to trimming\n'integralestimates' : A dictionary containing the final integral estimates with uncertainty estimation using different uncertainty estimators. Also includes all intermediate results required for the integral estimate combination\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.HMISettings","page":"API","title":"BAT.HMISettings","text":"HMISettings\n\nholds the settings for the hm_integrate function. There are several default constructors available: HMIFastSettings() HMIStandardSettings() HMIPrecisionSettings()\n\n#Variables\n\n'whitening_method::Symbol' : which whitening method to use\n'max_startingIDs::Integer' : influences how many starting ids are allowed to be generated\n'maxstartingIDsfraction::AbstractFloat' : how many points are considered as possible starting points as a fraction of total points available\n'rect_increase::AbstractFloat' : describes the procentual rectangle volume increase/decrease during hyperrectangle creation. Low values can increase the precision if enough points are available but can cause systematically wrong results if not enough points are available.\n'useallrects::Bool' : All rectangles are used for the integration process no matter how big their overlap is. If enabled the rectangles are weighted by their overlap.\n'useMultiThreading' : activate multithreading support.\n'warning_minstartingids' : the required minimum amount of starting samples\n'dotrimming' : determines whether the integral estimates are trimmed (1σ trim) before combining them into a final result (more robust)\n'uncertaintyestimators' : A dictionary of different uncertainty estimator functions. Currently three functions are available: hmcombineresultslegacy! (outdated, overestimates uncertainty significantly in higher dimensions), hmcombineresultscovweighted! (very fast) and hmcombineresults_analyticestimation! (recommended)\n\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.IntegrationVolume","page":"API","title":"BAT.IntegrationVolume","text":"IntegrationVolume{T<:AbstractFloat, I<:Integer}\n\nVariables\n\n'pointcloud' : holds the point cloud of the integration volume\n'spatialvolume' : the boundaries of the integration volume\n'volume' : the volume\n\nHold the point cloud and the spatial volume for integration.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.IntegrationVolume-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},HyperRectVolume{T}}, Tuple{DataSet{T,I},HyperRectVolume{T},Bool}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.IntegrationVolume","text":"IntegrationVolume(dataset::DataSet{T, I}, spvol::HyperRectVolume{T}, searchpts::Bool = true)::IntegrationVolume{T, I}\n\ncreates an integration region by calculating the point cloud an the volume of the spatial volume.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.OnlineMvMean","page":"API","title":"BAT.OnlineMvMean","text":"OnlineMvMean{T<:AbstractFloat} <: AbstractVector{T}\n\nMulti-variate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.OnlineUvMean","page":"API","title":"BAT.OnlineUvMean","text":"OnlineUvMean{T<:AbstractFloat}\n\nUnivariate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.PointCloud","page":"API","title":"BAT.PointCloud","text":"PointCloud{T<:AbstractFloat, I<:Integer}\n\nStores the information of the points of an e.g. HyperRectVolume\n\nVariables\n\n'maxLogProb' : The maximum log. probability of one of the points inside the hyper-rectangle\n'minLogProb' : The minimum log. probability of one of the points inside the hyper-rectangle\n'maxWeightProb' : the weighted max. log. probability\n'minWeightProb' : the weighted min. log. probability\n'probfactor' : The probability factor of the hyper-rectangle\n'probweightfactor' : The weighted probability factor\n'points' : The number of points inside the hyper-rectangle\n'pointIDs' : the IDs of the points inside the hyper-rectangle, might be empty because it is optional and costs performance\n'searchres' : used to boost performance\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.PointCloud-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},HyperRectVolume{T},Bool}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.PointCloud","text":"PointCloud{T<:AbstractFloat, I<:Integer}(dataset::DataSet{T, I}, hyperrect::HyperRectVolume{T}, searchpts::Bool = false)::PointCloud\n\ncreates a point cloud by searching the data tree for points which are inside the hyper-rectangle The parameter searchpts determines if an array of the point IDs is created as well\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.WhiteningResult","page":"API","title":"BAT.WhiteningResult","text":"WhiteningResult{T<:AbstractFloat}\n\nStores the information obtained during the Whitening Process\n\nVariables\n\n'determinant' : The determinant of the whitening matrix\n'targetprobfactor' : The suggested target probability factor\n'whiteningmatrix' : The whitening matrix\n'meanvalue' : the mean vector of the input data\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.bat_sampler","page":"API","title":"BAT.bat_sampler","text":"bat_sampler(d::Distribution)\n\nTries to return a BAT-compatible sampler for Distribution d. A sampler is BAT-compatible if it supports random number generation using an arbitrary AbstractRNG:\n\nrand(rng::AbstractRNG, s::SamplerType)\nrand!(rng::AbstractRNG, s::SamplerType, x::AbstractArray)\n\nIf no specific method of bat_sampler is defined for the type of d, it will default to sampler(d), which may or may not return a BAT-compatible sampler.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.density_logval","page":"API","title":"BAT.density_logval","text":"density_logval(\n    density::AbstractDensity,\n    params::AbstractVector{<:Real},\n    exec_context::ExecContext = ExecContext()\n)\n\nVersion of density_logval for a single parameter vector.\n\nDo not implement density_logval directly for subtypes of AbstractDensity, implement BAT.unsafe_density_logval instead.\n\nSee ExecContext for thread-safety requirements.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.density_logval!","page":"API","title":"BAT.density_logval!","text":"density_logval!(\n    r::AbstractVector{<:Real},\n    density::AbstractDensity,\n    params::VectorOfSimilarVectors{<:Real},\n    exec_context::ExecContext = ExecContext()\n)\n\nCompute log of values of a density function for multiple parameter value vectors.\n\nInput:\n\ndensity: density function\nparams: parameter values\nexec_context: Execution context\n\nOutput is stored in\n\nr: Vector of log-result values\n\nArray size requirements:\n\naxes(params, 1) == axes(r, 1)\n\nNote: density_logval! must not be called with out-of-bounds parameter vectors (see param_bounds). The result of density_logval! for parameter vectors that are out of bounds is implicitly -Inf, but for performance reasons the output is left undefined: density_logval! may fail or store arbitrary values in r.\n\nDo not implement density_logval! directly for subtypes of AbstractDensity, implement BAT.unsafe_density_logval! instead.\n\nSee ExecContext for thread-safety requirements.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.distribution_logpdf","page":"API","title":"BAT.distribution_logpdf","text":"distribution_logpdf(\n    pdist::AbstractProposalDist,\n    params_new::AbstractVector,\n    params_old:::AbstractVector\n)\n\nAnalog to distribution_logpdf!, but for a single parameter vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.distribution_logpdf!","page":"API","title":"BAT.distribution_logpdf!","text":"distribution_logpdf!(\n    p::AbstractArray,\n    pdist::AbstractProposalDist,\n    params_new::Union{AbstractVector,VectorOfSimilarVectors},\n    params_old:::Union{AbstractVector,VectorOfSimilarVectors}\n)\n\nReturns log(PDF) value of pdist for transitioning from old to new parameter values for multiple parameter sets.\n\nend\n\nInput:\n\nparams_new: New parameter values (column vectors)\nparams_old: Old parameter values (column vectors)\n\nOutput is stored in\n\np: Array of PDF values, length must match, shape is ignored\n\nArray size requirements:\n\nsize(params_old, 1) == size(params_new, 1) == length(pdist)\nsize(params_old, 2) == size(params_new, 2) or size(params_old, 2) == 1\nsize(params_new, 2) == length(p)\n\nImplementations of distribution_logpdf! must be thread-safe.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.fromuhc!","page":"API","title":"BAT.fromuhc!","text":"fromuhc!(Y::AbstractVector, X::AbstractVector, vol::SpatialVolume)\nfromuhc!(Y::VectorOfSimilarVectors, X::VectorOfSimilarVectors, vol::SpatialVolume)\n\nBijective transformation of coordinates X within the unit hypercube to coordinates Y in vol. If X and Y are matrices, the transformation is applied to the column vectors. Use Y === X to transform in-place.\n\nUse inv(fromuhc!) to get the the inverse transformation.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.fromuhc-Tuple{AbstractArray{T,1} where T,SpatialVolume}","page":"API","title":"BAT.fromuhc","text":"fromuhc(X::AbstractVector, vol::SpatialVolume)\nfromuhc(X::VectorOfSimilarVectors, vol::SpatialVolume)\n\nBijective transformation from unit hypercube to vol. See fromuhc!.\n\nUse inv(fromuhc) to get the the inverse transformation.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.fromui","page":"API","title":"BAT.fromui","text":"y = fromui(x::Real, lo::Real, hi::Real)\ny = fromui(x::Real, lo_hi::ClosedInterval{<:Real})\n\nLinear bijective transformation from the unit inverval (i.e. x ∈ 0..1) to y ∈ lo..hi.\n\nUse inv(fromui) to get the the inverse transformation.\n\nUse @inbounds to disable range checking on the input value.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.hm_init-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},HMISettings}} where V<:SpatialVolume where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.hm_init","text":"function hm_init!(result, settings)\n\nSets the global multithreading setting and ensures that a minimum number of samples, dependent on the number of dimensions, are provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.hm_integrate!-Union{Tuple{HMIData{T,I,V}}, Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},Symbol}} where V<:SpatialVolume where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.hm_integrate!","text":"function hm_integrate!(result, settings = HMIPrecisionSettings())\n\nThis function starts the adaptive harmonic mean integration. See arXiv:1808.08051 for more details. It needs a HMIData struct as input, which holds the samples, in form of a dataset, the integration volumes and other properties, required for the integration, and the final result.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.hm_whiteningtransformation!-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},HMISettings}} where V<:SpatialVolume where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.hm_whiteningtransformation!","text":"function hm_whiteningtransformation!(result, settings)\n\nApplies a whitening transformation to the samples. A custom whitening method can be used by overriding settings.whitening_function!\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.issymmetric_around_origin","page":"API","title":"BAT.issymmetric_around_origin","text":"issymmetric_around_origin(d::Distribution)\n\nReturns true (resp. false) if the Distribution is symmetric (resp. non-symmetric) around the origin.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.log_volume","page":"API","title":"BAT.log_volume","text":"log_volume(vol::SpatialVolume)\n\nGet the logarithm of the volume of the space in vol.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.nparams","page":"API","title":"BAT.nparams","text":"nparams(X::Union{AbstractParamBounds,MCMCIterator,...})\n\nGet the number of parameters of X.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.param_bounds-Tuple{AbstractDensity}","page":"API","title":"BAT.param_bounds","text":"param_bounds(density::AbstractDensity)::AbstractParamBounds\n\nGet the parameter bounds of density. See density_logval! for the implications and handling of the bounds.\n\nUse\n\nnew_density = density[bounds::ParamVolumeBounds]\n\nto create a new density function with additional bounds.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.proposal_rand!","page":"API","title":"BAT.proposal_rand!","text":"function proposal_rand!(\n    rng::AbstractRNG,\n    pdist::GenericProposalDist,\n    params_new::Union{AbstractVector,VectorOfSimilarVectors},\n    params_old::Union{AbstractVector,VectorOfSimilarVectors}\n)\n\nGenerate one or multiple proposed parameter vectors, based on one or multiple previous parameter vectors.\n\nInput:\n\nrng: Random number generator to use\npdist: Proposal distribution to use\nparams_old: Old parameter values (vector or column vectors, if a matrix)\n\nOutput is stored in\n\nparams_new: New parameter values (vector or column vectors, if a matrix)\n\nThe caller must guarantee:\n\nsize(params_old, 1) == size(params_new, 1)\nsize(params_old, 2) == size(params_new, 2) or size(params_old, 2) == 1\nparams_new !== params_old (no aliasing)\n\nImplementations of proposal_rand! must be thread-safe.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.spatialvolume","page":"API","title":"BAT.spatialvolume","text":"spatialvolume(b::ParamVolumeBounds)::SpatialVolume\n\nReturns the spatial volume that defines the parameter bounds.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.MCMCCallbackWrapper","page":"API","title":"BAT.MCMCCallbackWrapper","text":"MCMCCallbackWrapper{F} <: AbstractMCMCCallback\n\nWraps a callable object to turn it into an AbstractMCMCCallback.\n\nConstructor:\n\nMCMCCallbackWrapper(f::Any)\n\nf needs to support the call syntax of an AbstractMCMCCallback.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.SearchResult","page":"API","title":"BAT.SearchResult","text":"SearchResult{T<:AbstractFloat, I<:Integer}\n\nStores the results of the space partitioning tree's search function\n\nVariables\n\n'pointIDs' : the IDs of samples found, might be empty because it is optional\n'points' : The number of points found.\n'maxLogProb' : the maximum log. probability of the points found.\n'minLogProb' : the minimum log. probability of the points found.\n'maxWeightProb' : the weighted minimum log. probability found.\n'minWeightProb' : the weighted maximum log. probfactor found.\n\n\n\n\n\n","category":"type"},{"location":"api/#BAT.apply_bounds","page":"API","title":"BAT.apply_bounds","text":"apply_bounds(x::Real, interval::ClosedInterval, boundary_type::BoundsType)\n\nSpecify lower and upper bound via interval.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.apply_bounds!","page":"API","title":"BAT.apply_bounds!","text":"apply_bounds!(params::AbstractVector, bounds::AbstractParamBounds)\n\nApply bounds to parameters params.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.apply_bounds-Union{Tuple{H}, Tuple{L}, Tuple{X}, Tuple{X,L,H,BoundsType}, Tuple{X,L,H,BoundsType,Any}} where H<:Real where L<:Real where X<:Real","page":"API","title":"BAT.apply_bounds","text":"apply_bounds(x::<:Real, lo::<:Real, hi::<:Real, boundary_type::BoundsType)\n\nApply lower/upper bound lo/hi to value x. boundary_type may be hard_bounds, cyclic_bounds or reflective_bounds.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.autocrl-Union{Tuple{AbstractArray{T,1}}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{Int64,1}}} where T<:Real","page":"API","title":"BAT.autocrl","text":"autocrl(xv::AbstractVector{T}, kv::AbstractVector{Int} = Vector{Int}())\n\nautocorrelation := Σ Cov[xi,x(i+k)]/Var[x]\n\nComputes the autocorrelations at various leg k of the input vector (time series) xv. The vector kv is the collections of lags to take into account\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.calculate_localmode-Tuple{Any}","page":"API","title":"BAT.calculate_localmode","text":"calculate_localmode(hist)\n\nCalculates the modes of a 1d statsbase histogram. A vector of the bin-center of the heighest bin(s) is(are) returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.create_hypercube-Union{Tuple{T}, Tuple{Array{T,1},T}} where T<:AbstractFloat","page":"API","title":"BAT.create_hypercube","text":"create_hypercube{T<:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume\n\ncreates a hypercube shaped spatial volume\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.create_hyperrectangle-Union{Tuple{I}, Tuple{T}, Tuple{I,DataSet{T,I},T,HMISettings}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.create_hyperrectangle","text":"This function creates a hyper-rectangle around each starting sample. It starts by building a hyper-cube  and subsequently adapts each face individually, thus turning the hyper-cube into a hyper-rectangle. The faces are adjusted in a way to match the shape of the distribution as best as possible.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.effective_sample_size-Tuple{AbstractArray,AbstractArray{T,1} where T}","page":"API","title":"BAT.effective_sample_size","text":"effective_sample_size(params::AbstractArray, weights::AbstractVector; with_weights=true)\n\nEffective size estimation for a (multidimensional) ElasticArray. By default applies the Kish approximation with the weigths available, but can be turned off (with_weights=false).\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.effective_sample_size-Tuple{DensitySampleVector}","page":"API","title":"BAT.effective_sample_size","text":"effective_sample_size(samples::DensitySampleVector; with_weights=true)\n\nEffective size estimation for a (multidimensional) DensitySampleVector. By default applies the Kish approximation with the weigths available, but can be turned off (with_weights=false).\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.effective_sample_size-Union{Tuple{AbstractArray{T1,1}}, Tuple{T1}, Tuple{T2}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1}}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},AbstractArray{Int64,1}}} where T1<:Real where T2<:Number","page":"API","title":"BAT.effective_sample_size","text":"Effective size estimation for a vector of samples xv. If a weight vector w is provided, the Kish approximation is applied.\n\nBy default computes the autocorrelation up to the square root of the number of entries in the vector, unless an explicit list of lags is provided (kv).\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.eval_density_logval!","page":"API","title":"BAT.eval_density_logval!","text":"eval_density_logval!(...)\n\nInternal function to first apply bounds and then evaluate density.\n\nGuarantees that for out-of-bounds parameters:\n\ndensity_logval is not called\nlog value of density is set to (resp. returned as) -Inf\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.eval_prior_posterior_logval!","page":"API","title":"BAT.eval_prior_posterior_logval!","text":"BAT.eval_prior_posterior_logval!(...)\n\nInternal function to first apply bounds to the parameters and then compute prior and posterior log valued.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.exec_capabilities","page":"API","title":"BAT.exec_capabilities","text":"exec_capabilities(f, args...)::ExecCapabilities\n\nDetermines the execution capabilities of a function f that supports an ExecContext argument, when called with arguments args.... The ExecContext argument itself is excluded from args... for exec_capabilities.\n\nBefore calling f, the caller must use\n\nexec_capabilities(f, args...)\n\nto determine the execution capabilities of f with the intended arguments, and take the resulting ExecCapabilities into account. If f is not thread-safe (but remote-safe), and the caller needs to run it on multiple threads, the caller may deep-copy the function arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.find_hypercube_centers-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},WhiteningResult{T},HMISettings}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.find_hypercube_centers","text":"find_hypercube_centers(dataset::DataSet{T, I}, whiteningresult::WhiteningResult, settings::HMISettings)::Vector{I}\n\nfinds possible starting points for the hyperrectangle creation\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.gr_Rsqr-Tuple{AbstractArray{#s78,1} where #s78<:MCMCBasicStats}","page":"API","title":"BAT.gr_Rsqr","text":"gr_Rsqr(stats::AbstractVector{<:MCMCBasicStats})\n\nGelman-Rubin R^2 for all parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.hyperrectangle_creationproccess!-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},T,HMISettings,Array{IntegrationVolume{T,I,HyperRectVolume{T}},1},Array{HyperRectVolume{T},1},Array{I,1},Base.Threads.Atomic{I},ProgressMeter.Progress}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.hyperrectangle_creationproccess!","text":"This function assigns each thread its own hyper-rectangle to build, if in multithreading-mode.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.initial_params!","page":"API","title":"BAT.initial_params!","text":"BAT.initial_params!(\n    params::Union{AbstractVector{<:Real},VectorOfSimilarVectors{<:Real}},\n    rng::AbstractRNG,\n    model::AbstractBayesianModel,\n    algorithm::MCMCAlgorithm\n)::typeof(params)\n\nFill params with random initial parameters suitable for model and algorithm. The default implementation will try to draw the initial parameters from the prior of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.modify_hypercube!-Union{Tuple{T}, Tuple{HyperRectVolume{T},Array{T,1},T}} where T<:AbstractFloat","page":"API","title":"BAT.modify_hypercube!","text":"create_hypercube!{T<:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume\n\nresizes a hypercube shaped spatial volume\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.modify_integrationvolume!-Union{Tuple{I}, Tuple{T}, Tuple{IntegrationVolume{T,I,V} where V<:SpatialVolume,DataSet{T,I},HyperRectVolume{T}}, Tuple{IntegrationVolume{T,I,V} where V<:SpatialVolume,DataSet{T,I},HyperRectVolume{T},Bool}} where I<:Integer where T<:AbstractFloat","page":"API","title":"BAT.modify_integrationvolume!","text":"modify_integrationvolume!(intvol::IntegrationVolume{T, I}, dataset::DataSet{T, I}, spvol::HyperRectVolume{T}, searchpts::Bool = true)\n\nupdates an integration volume with new boundaries. Recalculates the pointcloud and volume.\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.unsafe_density_logval","page":"API","title":"BAT.unsafe_density_logval","text":"BAT.unsafe_density_logval(\n    density::AbstractDensity,\n    params::AbstractVector{<:Real},\n    exec_context::ExecContext = ExecContext()\n)\n\nUnsafe variant of density_logval, implementations may rely on\n\nsize(params, 1) == nparams(density)\n\nThe caller must ensure that these conditions are met!\n\n\n\n\n\n","category":"function"},{"location":"api/#BAT.unsafe_density_logval!-Tuple{AbstractArray{#s45,1} where #s45<:Real,AbstractDensity,ArraysOfArrays.ArrayOfSimilarArrays{#s31,1,1,2,P} where P<:AbstractArray{#s31,2} where #s31<:Real,ExecContext}","page":"API","title":"BAT.unsafe_density_logval!","text":"BAT.unsafe_density_logval!(\n    r::AbstractVector{<:Real},\n    density::AbstractDensity,\n    params::VectorOfSimilarVectors{<:Real},\n    exec_context::ExecContext\n)\n\nUnsafe variant of density_logval!, implementations may rely on\n\nsize(params, 1) == nparams(density)\nsize(params, 2) == length(r)\n\nThe caller must ensure that these conditions are met!\n\n\n\n\n\n","category":"method"},{"location":"api/#BAT.wgt_effective_sample_size-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T<:Real","page":"API","title":"BAT.wgt_effective_sample_size","text":"wgt_effective_sample_size(w::AbstractVector{T})\n\nKish's approximation for weighted samples effectivesamplesize estimation. Computes the weighting factor for weigthed samples, where w is the vector of weigths.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.intersect-Tuple{ExecCapabilities,ExecCapabilities}","page":"API","title":"Base.intersect","text":"intersect(a:ExecCapabilities, b:ExecCapabilities)\n\nGet the intersection of execution capabilities of a and b, i.e. the ExecCapabilities that should be used when to functions are used in combination (e.g. in sequence).\n\n\n\n\n\n","category":"method"},{"location":"developing/#Developer-Instructions-1","page":"Developer instructions","title":"Developer Instructions","text":"","category":"section"},{"location":"developing/#Documentation-Generation-1","page":"Developer instructions","title":"Documentation Generation","text":"","category":"section"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"To generate and view a local version of the documentation, run","category":"page"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"cd docs\njulia make.jl local","category":"page"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"then open \"docs/build/index.html\" in your browser.","category":"page"},{"location":"developing/#Code-Reloading-1","page":"Developer instructions","title":"Code Reloading","text":"","category":"section"},{"location":"developing/#","page":"Developer instructions","title":"Developer instructions","text":"When changing the code of BAT.jl and testing snippets and examples in the REPL, automatic code reloading comes in very handy. Try out Revise.jl.","category":"page"},{"location":"license/#License-1","page":"License","title":"License","text":"","category":"section"},{"location":"license/#","page":"License","title":"License","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"}]
}
