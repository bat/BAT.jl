<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · BAT</title><link rel="canonical" href="https://bat.github.io/BAT.jl/stable/api/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BAT</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li><li class="toplevel"><a class="toctext" href="#Documentation-1">Documentation</a></li></ul></li><li><a class="toctext" href="../developing/">Developer instructions</a></li><li><a class="toctext" href="../license/">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/bat/BAT.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><ul><li><a href="#BAT.AbstractDensity"><code>BAT.AbstractDensity</code></a></li><li><a href="#BAT.AbstractMCMCCallback"><code>BAT.AbstractMCMCCallback</code></a></li><li><a href="#BAT.AbstractProposalDist"><code>BAT.AbstractProposalDist</code></a></li><li><a href="#BAT.DataSet"><code>BAT.DataSet</code></a></li><li><a href="#BAT.ExecCapabilities"><code>BAT.ExecCapabilities</code></a></li><li><a href="#BAT.ExecContext"><code>BAT.ExecContext</code></a></li><li><a href="#BAT.GRConvergence"><code>BAT.GRConvergence</code></a></li><li><a href="#BAT.GenericDensity"><code>BAT.GenericDensity</code></a></li><li><a href="#BAT.HMIData"><code>BAT.HMIData</code></a></li><li><a href="#BAT.HMISettings"><code>BAT.HMISettings</code></a></li><li><a href="#BAT.IntegrationVolume-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},HyperRectVolume{T}}, Tuple{DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.IntegrationVolume</code></a></li><li><a href="#BAT.IntegrationVolume"><code>BAT.IntegrationVolume</code></a></li><li><a href="#BAT.MCMCCallbackWrapper"><code>BAT.MCMCCallbackWrapper</code></a></li><li><a href="#BAT.OnlineMvMean"><code>BAT.OnlineMvMean</code></a></li><li><a href="#BAT.OnlineUvMean"><code>BAT.OnlineUvMean</code></a></li><li><a href="#BAT.PointCloud-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.PointCloud</code></a></li><li><a href="#BAT.PointCloud"><code>BAT.PointCloud</code></a></li><li><a href="#BAT.SearchResult"><code>BAT.SearchResult</code></a></li><li><a href="#BAT.WhiteningResult"><code>BAT.WhiteningResult</code></a></li></ul><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><ul><li><a href="#BAT.apply_bounds"><code>BAT.apply_bounds</code></a></li><li><a href="#BAT.apply_bounds-Union{Tuple{H}, Tuple{L}, Tuple{X}, Tuple{X,L,H,BoundsType}, Tuple{X,L,H,BoundsType,Any}} where H&lt;:Real where L&lt;:Real where X&lt;:Real"><code>BAT.apply_bounds</code></a></li><li><a href="#BAT.apply_bounds!"><code>BAT.apply_bounds!</code></a></li><li><a href="#BAT.autocrl-Union{Tuple{AbstractArray{T,1}}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{Int64,1}}} where T&lt;:Real"><code>BAT.autocrl</code></a></li><li><a href="#BAT.bat_sampler"><code>BAT.bat_sampler</code></a></li><li><a href="#BAT.calculate_localmode-Tuple{Any}"><code>BAT.calculate_localmode</code></a></li><li><a href="#BAT.create_hypercube-Union{Tuple{T}, Tuple{Array{T,1},T}} where T&lt;:AbstractFloat"><code>BAT.create_hypercube</code></a></li><li><a href="#BAT.create_hyperrectangle-Union{Tuple{I}, Tuple{T}, Tuple{I,DataSet{T,I},T,HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.create_hyperrectangle</code></a></li><li><a href="#BAT.density_logval"><code>BAT.density_logval</code></a></li><li><a href="#BAT.density_logval!"><code>BAT.density_logval!</code></a></li><li><a href="#BAT.distribution_logpdf"><code>BAT.distribution_logpdf</code></a></li><li><a href="#BAT.distribution_logpdf!"><code>BAT.distribution_logpdf!</code></a></li><li><a href="#BAT.effective_sample_size-Union{Tuple{AbstractArray{T1,1}}, Tuple{T1}, Tuple{T2}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1}}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},AbstractArray{Int64,1}}} where T1&lt;:Real where T2&lt;:Number"><code>BAT.effective_sample_size</code></a></li><li><a href="#BAT.effective_sample_size-Tuple{DensitySampleVector}"><code>BAT.effective_sample_size</code></a></li><li><a href="#BAT.effective_sample_size-Tuple{AbstractArray,AbstractArray{T,1} where T}"><code>BAT.effective_sample_size</code></a></li><li><a href="#BAT.eval_density_logval!"><code>BAT.eval_density_logval!</code></a></li><li><a href="#BAT.eval_prior_posterior_logval!"><code>BAT.eval_prior_posterior_logval!</code></a></li><li><a href="#BAT.exec_capabilities"><code>BAT.exec_capabilities</code></a></li><li><a href="#BAT.find_hypercube_centers-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},WhiteningResult{T},HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.find_hypercube_centers</code></a></li><li><a href="#BAT.fromuhc-Tuple{AbstractArray{T,1} where T,SpatialVolume}"><code>BAT.fromuhc</code></a></li><li><a href="#BAT.fromuhc!"><code>BAT.fromuhc!</code></a></li><li><a href="#BAT.fromui"><code>BAT.fromui</code></a></li><li><a href="#BAT.gr_Rsqr-Tuple{AbstractArray{#s78,1} where #s78&lt;:MCMCBasicStats}"><code>BAT.gr_Rsqr</code></a></li><li><a href="#BAT.hm_init-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_init</code></a></li><li><a href="#BAT.hm_integrate!-Union{Tuple{HMIData{T,I,V}}, Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},Symbol}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_integrate!</code></a></li><li><a href="#BAT.hm_whiteningtransformation!-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_whiteningtransformation!</code></a></li><li><a href="#BAT.hyperrectangle_creationproccess!-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},T,HMISettings,Array{IntegrationVolume{T,I,HyperRectVolume{T}},1},Array{HyperRectVolume{T},1},Array{I,1},Base.Threads.Atomic{I},ProgressMeter.Progress}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hyperrectangle_creationproccess!</code></a></li><li><a href="#BAT.initial_params!"><code>BAT.initial_params!</code></a></li><li><a href="#BAT.issymmetric_around_origin"><code>BAT.issymmetric_around_origin</code></a></li><li><a href="#BAT.log_volume"><code>BAT.log_volume</code></a></li><li><a href="#BAT.modify_hypercube!-Union{Tuple{T}, Tuple{HyperRectVolume{T},Array{T,1},T}} where T&lt;:AbstractFloat"><code>BAT.modify_hypercube!</code></a></li><li><a href="#BAT.modify_integrationvolume!-Union{Tuple{I}, Tuple{T}, Tuple{IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,DataSet{T,I},HyperRectVolume{T}}, Tuple{IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.modify_integrationvolume!</code></a></li><li><a href="#BAT.nparams"><code>BAT.nparams</code></a></li><li><a href="#BAT.param_bounds-Tuple{AbstractDensity}"><code>BAT.param_bounds</code></a></li><li><a href="#BAT.proposal_rand!"><code>BAT.proposal_rand!</code></a></li><li><a href="#BAT.spatialvolume"><code>BAT.spatialvolume</code></a></li><li><a href="#BAT.unsafe_density_logval"><code>BAT.unsafe_density_logval</code></a></li><li><a href="#BAT.unsafe_density_logval!-Tuple{AbstractArray{#s45,1} where #s45&lt;:Real,AbstractDensity,ArraysOfArrays.ArrayOfSimilarArrays{#s31,1,1,2,P} where P&lt;:AbstractArray{#s31,2} where #s31&lt;:Real,ExecContext}"><code>BAT.unsafe_density_logval!</code></a></li><li><a href="#BAT.wgt_effective_sample_size-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Real"><code>BAT.wgt_effective_sample_size</code></a></li><li><a href="#Base.intersect-Tuple{ExecCapabilities,ExecCapabilities}"><code>Base.intersect</code></a></li></ul><h1><a class="nav-anchor" id="Documentation-1" href="#Documentation-1">Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.AbstractDensity" href="#BAT.AbstractDensity"><code>BAT.AbstractDensity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractDensity</code></pre><p>The following functions must be implemented for subtypes:</p><ul><li><code>BAT.nparams</code></li><li><code>BAT.unsafe_density_logval</code></li></ul><p>In some cases, it may be desirable to override the default implementations of the functions</p><ul><li><code>BAT.exec_capabilities</code></li><li><code>BAT.unsafe_density_logval!</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/densities/density.jl#L7-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.AbstractMCMCCallback" href="#BAT.AbstractMCMCCallback"><code>BAT.AbstractMCMCCallback</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractMCMCCallback &lt;: Function</code></pre><p>Subtypes (e.g. <code>X</code>) must support</p><pre><code class="language-none">(::X)(level::Integer, chain::MCMCIterator) =&gt; nothing
(::X)(level::Integer, tuner::AbstractMCMCTuner) =&gt; nothing</code></pre><p>to be compabtible with <code>mcmc_iterate!</code>, <code>mcmc_tune_burnin!</code>, etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/samplers/mcmc/mcmc_callback.jl#L4-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.AbstractProposalDist" href="#BAT.AbstractProposalDist"><code>BAT.AbstractProposalDist</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractProposalDist</code></pre><p>The following functions must be implemented for subtypes:</p><ul><li><code>BAT.distribution_logpdf</code></li><li><code>BAT.proposal_rand!</code></li><li><code>BAT.nparams</code>, returning the number of parameters (i.e. dimensionality).</li><li><code>LinearAlgebra.issymmetric</code>, indicating whether p(a -&gt; b) == p(b -&gt; a) holds true.</li></ul><p>In some cases, it may be desirable to override the default implementation of <code>BAT.distribution_logpdf!</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/samplers/mcmc/proposaldist.jl#L4-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.DataSet" href="#BAT.DataSet"><code>BAT.DataSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DataSet{T&lt;:AbstractFloat, I&lt;:Integer}</code></pre><p>Holds the MCMC output. For construction use constructor: function DataSet{T&lt;:Real}(data::Matrix{T}, logprob::Vector{T}, weights::Vector{T})</p><p><strong>Variables</strong></p><ul><li>&#39;data&#39; : An P x N array with N data points with P parameters.</li><li>&#39;logprob&#39; : The logarithmic probability for each samples stored in an array</li><li>&#39;weights&#39; : How often each sample occurred. Set to an array of ones if working directly on MCMC output</li><li>&#39;ids&#39; : Array which is used to assign each sample to a batch, required for the cov. weighed uncertainty estimation</li><li>.sortids : an array of indices which stores the original ordering of the samples (the space partitioning tree reorders the samples), required to calculate an effective sample size.</li><li>&#39;N&#39; : number of samples</li><li>&#39;P&#39; : number of parameters</li><li>&#39;nsubsets&#39; : the number of batches</li><li>&#39;iswhitened&#39; : a boolean value which indicates whether the data set is iswhitened</li><li>&#39;isnew&#39; : a boolean value which indicates whether the data set was swapped out with a different one (it is possible to redo the integration with a different sample set using previously generated hyper-rectangles)</li><li>&#39;partitioningtree&#39; : The space partitioning tree, used to efficiently identify samples in a point cloud</li><li>&#39;startingIDs&#39; : The Hyper-Rectangle Seed Samples are stored in this array</li><li>&#39;tolerance&#39; : A threshold required for the hyper-rectangle creation process.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/data_types.jl#L18-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.ExecCapabilities" href="#BAT.ExecCapabilities"><code>BAT.ExecCapabilities</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ExecCapabilities
    nthreads::Int
    threadsafe::Bool
    nprocs::Int
    remotesafe::Bool
end</code></pre><p>Specifies the execution capabilities of functions that support an <code>ExecContext</code> argument.</p><p><code>nthreads</code> specifies the maximum number of threads the function can utilize efficiently, internally. If <code>nthreads &lt;= 1</code>, the function implementation is single-threaded. <code>nthreads == 0</code> indicates that the function is cheap and that when used in combination with other functions, their capabilities should dominate.</p><p><code>threadsafe</code> specifies whether the function is thread-safe, and can be can be run on multiple threads in parallel by the caller.</p><p><code>nprocs</code> specifies the maximum number of worker processes the function can utilize efficiently, internally. If <code>procs &lt;= 1</code>, the function cannot use worker processes. <code>nthreads == 0</code> carries equivalent meaning to <code>nthreads == 0</code>.</p><p><code>remotesafe</code> specifies that the function can be run on a remote thread, it implies that the function arguments can be (de-)serialized safely.</p><p>Functions with an <code>ExecContext</code> argument should announce their capabilities via methods of <code>exec_capabilities</code>. Functions should, ideally, either support internal multithreading (<code>nthreads &gt; 1</code>) or be thread-safe (<code>threadsafe</code> == true). Likewise, functions should either utilize worker processes (<code>nprocs</code> &gt; 1) internally or support remote execution (<code>remotesafe</code> == true) by the caller.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/scheduling/execcontext.jl#L30-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.ExecContext" href="#BAT.ExecContext"><code>BAT.ExecContext</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ExecContext
    use_threads::Bool
    onprocs::Vector{Int64}
end</code></pre><p>Functions that take an <code>ExecContext</code> argument must limit their use of threads and processes accordingly. Depending on <code>use_threads</code>, the function may use all (or only a single) thread(s) on each process in <code>onprocs</code> (in addition to the current thread on the current process).</p><p>The caller may choose to change the <code>ExecContext</code> from call to call, based on execution time and latency measurements, etc.</p><p>Functions can announce their <a href="#BAT.ExecCapabilities"><code>BAT.ExecCapabilities</code></a> via <a href="#BAT.exec_capabilities"><code>exec_capabilities</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/scheduling/execcontext.jl#L4-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.GRConvergence" href="#BAT.GRConvergence"><code>BAT.GRConvergence</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GRConvergence</code></pre><p>Gelman-Rubin <span>$$maximum(R^2)$$</span> convergence test.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/samplers/mcmc/mcmc_convergence.jl#L38-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.GenericDensity" href="#BAT.GenericDensity"><code>BAT.GenericDensity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GenericDensity{F} &lt;: AbstractDensity</code></pre><p>Constructors:</p><pre><code class="language-none">GenericDensity(log_f, nparams::Int)</code></pre><p>Turns the logarithmic density function <code>log_f</code> into a BAT-compatible <code>AbstractDensity</code>. <code>log_f</code> must support</p><pre><code class="language-none">`log_f(params::AbstractVector{&lt;:Real})::Real`</code></pre><p>with <code>length(params) == nparams</code>.</p><p>It must be safe to execute <code>log_f</code> in parallel on multiple threads and processes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/densities/density.jl#L230-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.HMIData" href="#BAT.HMIData"><code>BAT.HMIData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HMIData{T&lt;:AbstractFloat, I&lt;:Integer}</code></pre><p>Includes all the informations of the integration process, including a list of hyper-rectangles, the results of the whitening transformation, the starting ids, and the average number of points and volume of the created hyper-rectangles.</p><p><strong>Variables</strong></p><ul><li>&#39;dataset1&#39; : Data Set 1</li><li>&#39;dataset2&#39; : Data Set 2</li><li>&#39;whiteningresult&#39; : contains the whitening matrix and its determinant, required to scale the final integral estimate</li><li>&#39;volumelist1&#39; : An array of integration volumes created using dataset1, but filled with samples from dataset2</li><li>&#39;volumelist2&#39; : An array of integration volumes created using dataset2, but filled with samples from dataset1</li><li>&#39;cubelist1&#39; : An array of small hyper-cubes created around seeding samples of dataset 1</li><li>&#39;cubelist2&#39; : An array of small hyper-cubes created around seeding samples of dataset 2</li><li>&#39;iterations1&#39; : The number of volume adapting iterations for the creating volumelist1</li><li>&#39;iterations2&#39; : The number of volume adapting iterations for the creating volumelist2</li><li>&#39;rejectedrects1&#39; : An array of ids, indicating which hyper-rectangles of volumelist1 were rejected due to trimming</li><li>&#39;rejectedrects2&#39; : An array of ids, indicating which hyper-rectangles of volumelist2 were rejected due to trimming</li><li>&#39;integralestimates&#39; : A dictionary containing the final integral estimates with uncertainty estimation using different uncertainty estimators. Also includes all intermediate results required for the integral estimate combination</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/data_types.jl#L273-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.HMISettings" href="#BAT.HMISettings"><code>BAT.HMISettings</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HMISettings</code></pre><p>holds the settings for the hm_integrate function. There are several default constructors available: HMIFastSettings() HMIStandardSettings() HMIPrecisionSettings()</p><p>#Variables</p><ul><li>&#39;whitening_method::Symbol&#39; : which whitening method to use</li><li>&#39;max_startingIDs::Integer&#39; : influences how many starting ids are allowed to be generated</li><li>&#39;max<em>startingIDs</em>fraction::AbstractFloat&#39; : how many points are considered as possible starting points as a fraction of total points available</li><li>&#39;rect_increase::AbstractFloat&#39; : describes the procentual rectangle volume increase/decrease during hyperrectangle creation. Low values can increase the precision if enough points are available but can cause systematically wrong results if not enough points are available.</li><li>&#39;use<em>all</em>rects::Bool&#39; : All rectangles are used for the integration process no matter how big their overlap is. If enabled the rectangles are weighted by their overlap.</li><li>&#39;useMultiThreading&#39; : activate multithreading support.</li><li>&#39;warning_minstartingids&#39; : the required minimum amount of starting samples</li><li>&#39;dotrimming&#39; : determines whether the integral estimates are trimmed (1σ trim) before combining them into a final result (more robust)</li><li>&#39;uncertainty<em>estimators&#39; : A dictionary of different uncertainty estimator functions. Currently three functions are available: hm</em>combineresults<em>legacy! (outdated, overestimates uncertainty significantly in higher dimensions), hm</em>combineresults<em>covweighted! (very fast) and hm</em>combineresults_analyticestimation! (recommended)</li></ul><p>end</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/data_types.jl#L109-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.IntegrationVolume" href="#BAT.IntegrationVolume"><code>BAT.IntegrationVolume</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IntegrationVolume{T&lt;:AbstractFloat, I&lt;:Integer}</code></pre><p><strong>Variables</strong></p><ul><li>&#39;pointcloud&#39; : holds the point cloud of the integration volume</li><li>&#39;spatialvolume&#39; : the boundaries of the integration volume</li><li>&#39;volume&#39; : the volume</li></ul><p>Hold the point cloud and the spatial volume for integration.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/data_types.jl#L223-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.IntegrationVolume-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},HyperRectVolume{T}}, Tuple{DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.IntegrationVolume-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},HyperRectVolume{T}}, Tuple{DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.IntegrationVolume</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IntegrationVolume(dataset::DataSet{T, I}, spvol::HyperRectVolume{T}, searchpts::Bool = true)::IntegrationVolume{T, I}</code></pre><p>creates an integration region by calculating the point cloud an the volume of the spatial volume.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/integration_volume.jl#L2-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.OnlineMvMean" href="#BAT.OnlineMvMean"><code>BAT.OnlineMvMean</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OnlineMvMean{T&lt;:AbstractFloat} &lt;: AbstractVector{T}</code></pre><p>Multi-variate mean implemented via Kahan-Babuška-Neumaier summation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/statistics/onlinemvstats.jl#L30-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.OnlineUvMean" href="#BAT.OnlineUvMean"><code>BAT.OnlineUvMean</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OnlineUvMean{T&lt;:AbstractFloat}</code></pre><p>Univariate mean implemented via Kahan-Babuška-Neumaier summation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/statistics/onlineuvstats.jl#L6-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.PointCloud" href="#BAT.PointCloud"><code>BAT.PointCloud</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PointCloud{T&lt;:AbstractFloat, I&lt;:Integer}</code></pre><p>Stores the information of the points of an e.g. HyperRectVolume</p><p><strong>Variables</strong></p><ul><li>&#39;maxLogProb&#39; : The maximum log. probability of one of the points inside the hyper-rectangle</li><li>&#39;minLogProb&#39; : The minimum log. probability of one of the points inside the hyper-rectangle</li><li>&#39;maxWeightProb&#39; : the weighted max. log. probability</li><li>&#39;minWeightProb&#39; : the weighted min. log. probability</li><li>&#39;probfactor&#39; : The probability factor of the hyper-rectangle</li><li>&#39;probweightfactor&#39; : The weighted probability factor</li><li>&#39;points&#39; : The number of points inside the hyper-rectangle</li><li>&#39;pointIDs&#39; : the IDs of the points inside the hyper-rectangle, might be empty because it is optional and costs performance</li><li>&#39;searchres&#39; : used to boost performance</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/data_types.jl#L193-L207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.PointCloud-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.PointCloud-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.PointCloud</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">PointCloud{T&lt;:AbstractFloat, I&lt;:Integer}(dataset::DataSet{T, I}, hyperrect::HyperRectVolume{T}, searchpts::Bool = false)::PointCloud</code></pre><p>creates a point cloud by searching the data tree for points which are inside the hyper-rectangle The parameter searchpts determines if an array of the point IDs is created as well</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/point_cloud.jl#L2-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.WhiteningResult" href="#BAT.WhiteningResult"><code>BAT.WhiteningResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">WhiteningResult{T&lt;:AbstractFloat}</code></pre><p>Stores the information obtained during the Whitening Process</p><p><strong>Variables</strong></p><ul><li>&#39;determinant&#39; : The determinant of the whitening matrix</li><li>&#39;targetprobfactor&#39; : The suggested target probability factor</li><li>&#39;whiteningmatrix&#39; : The whitening matrix</li><li>&#39;meanvalue&#39; : the mean vector of the input data</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/data_types.jl#L143-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.bat_sampler" href="#BAT.bat_sampler"><code>BAT.bat_sampler</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bat_sampler(d::Distribution)</code></pre><p>Tries to return a BAT-compatible sampler for Distribution d. A sampler is BAT-compatible if it supports random number generation using an arbitrary <code>AbstractRNG</code>:</p><pre><code class="language-none">rand(rng::AbstractRNG, s::SamplerType)
rand!(rng::AbstractRNG, s::SamplerType, x::AbstractArray)</code></pre><p>If no specific method of <code>bat_sampler</code> is defined for the type of <code>d</code>, it will default to <code>sampler(d)</code>, which may or may not return a BAT-compatible sampler.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/distributions/distribution_functions.jl#L16-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.density_logval" href="#BAT.density_logval"><code>BAT.density_logval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">density_logval(
    density::AbstractDensity,
    params::AbstractVector{&lt;:Real},
    exec_context::ExecContext = ExecContext()
)</code></pre><p>Version of <code>density_logval</code> for a single parameter vector.</p><p>Do not implement <code>density_logval</code> directly for subtypes of <code>AbstractDensity</code>, implement <code>BAT.unsafe_density_logval</code> instead.</p><p>See <code>ExecContext</code> for thread-safety requirements.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/densities/density.jl#L58-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.density_logval!" href="#BAT.density_logval!"><code>BAT.density_logval!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">density_logval!(
    r::AbstractVector{&lt;:Real},
    density::AbstractDensity,
    params::VectorOfSimilarVectors{&lt;:Real},
    exec_context::ExecContext = ExecContext()
)</code></pre><p>Compute log of values of a density function for multiple parameter value vectors.</p><p>Input:</p><ul><li><code>density</code>: density function</li><li><code>params</code>: parameter values</li><li><code>exec_context</code>: Execution context</li></ul><p>Output is stored in</p><ul><li><code>r</code>: Vector of log-result values</li></ul><p>Array size requirements:</p><pre><code class="language-none">axes(params, 1) == axes(r, 1)</code></pre><p>Note: <code>density_logval!</code> must not be called with out-of-bounds parameter vectors (see <code>param_bounds</code>). The result of <code>density_logval!</code> for parameter vectors that are out of bounds is implicitly <code>-Inf</code>, but for performance reasons the output is left undefined: <code>density_logval!</code> may fail or store arbitrary values in <code>r</code>.</p><p>Do not implement <code>density_logval!</code> directly for subtypes of <code>AbstractDensity</code>, implement <code>BAT.unsafe_density_logval!</code> instead.</p><p>See <code>ExecContext</code> for thread-safety requirements.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/densities/density.jl#L111-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.distribution_logpdf" href="#BAT.distribution_logpdf"><code>BAT.distribution_logpdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">distribution_logpdf(
    pdist::AbstractProposalDist,
    params_new::AbstractVector,
    params_old:::AbstractVector
)</code></pre><p>Analog to <code>distribution_logpdf!</code>, but for a single parameter vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/samplers/mcmc/proposaldist.jl#L21-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.distribution_logpdf!" href="#BAT.distribution_logpdf!"><code>BAT.distribution_logpdf!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">distribution_logpdf!(
    p::AbstractArray,
    pdist::AbstractProposalDist,
    params_new::Union{AbstractVector,VectorOfSimilarVectors},
    params_old:::Union{AbstractVector,VectorOfSimilarVectors}
)</code></pre><p>Returns log(PDF) value of <code>pdist</code> for transitioning from old to new parameter values for multiple parameter sets.</p><p>end</p><p>Input:</p><ul><li><code>params_new</code>: New parameter values (column vectors)</li><li><code>params_old</code>: Old parameter values (column vectors)</li></ul><p>Output is stored in</p><ul><li><code>p</code>: Array of PDF values, length must match, shape is ignored</li></ul><p>Array size requirements:</p><ul><li><code>size(params_old, 1) == size(params_new, 1) == length(pdist)</code></li><li><code>size(params_old, 2) == size(params_new, 2)</code> or <code>size(params_old, 2) == 1</code></li><li><code>size(params_new, 2) == length(p)</code></li></ul><p>Implementations of <code>distribution_logpdf!</code> must be thread-safe.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/samplers/mcmc/proposaldist.jl#L36-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.fromuhc!" href="#BAT.fromuhc!"><code>BAT.fromuhc!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fromuhc!(Y::AbstractVector, X::AbstractVector, vol::SpatialVolume)
fromuhc!(Y::VectorOfSimilarVectors, X::VectorOfSimilarVectors, vol::SpatialVolume)</code></pre><p>Bijective transformation of coordinates <code>X</code> within the unit hypercube to coordinates <code>Y</code> in <code>vol</code>. If <code>X</code> and <code>Y</code> are matrices, the transformation is applied to the column vectors. Use <code>Y === X</code> to transform in-place.</p><p>Use <code>inv(fromuhc!)</code> to get the the inverse transformation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/parameters/spatialvolume.jl#L27-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.fromuhc-Tuple{AbstractArray{T,1} where T,SpatialVolume}" href="#BAT.fromuhc-Tuple{AbstractArray{T,1} where T,SpatialVolume}"><code>BAT.fromuhc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fromuhc(X::AbstractVector, vol::SpatialVolume)
fromuhc(X::VectorOfSimilarVectors, vol::SpatialVolume)</code></pre><p>Bijective transformation from unit hypercube to <code>vol</code>. See <code>fromuhc!</code>.</p><p>Use <code>inv(fromuhc)</code> to get the the inverse transformation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/parameters/spatialvolume.jl#L46-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.fromui" href="#BAT.fromui"><code>BAT.fromui</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">y = fromui(x::Real, lo::Real, hi::Real)
y = fromui(x::Real, lo_hi::ClosedInterval{&lt;:Real})</code></pre><p>Linear bijective transformation from the unit inverval (i.e. <code>x ∈ 0..1</code>) to <code>y ∈ lo..hi</code>.</p><p>Use <code>inv(fromui)</code> to get the the inverse transformation.</p><p>Use <code>@inbounds</code> to disable range checking on the input value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/utils/coord_utils.jl#L7-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.hm_init-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.hm_init-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_init</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>function hm_init!(result, settings)</p><p>Sets the global multithreading setting and ensures that a minimum number of samples, dependent on the number of dimensions, are provided.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/harmonic_mean_integration.jl#L71-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.hm_integrate!-Union{Tuple{HMIData{T,I,V}}, Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},Symbol}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.hm_integrate!-Union{Tuple{HMIData{T,I,V}}, Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},Symbol}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_integrate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>function hm_integrate!(result, settings = HMIPrecisionSettings())</p><p>This function starts the adaptive harmonic mean integration. See arXiv:1808.08051 for more details. It needs a HMIData struct as input, which holds the samples, in form of a dataset, the integration volumes and other properties, required for the integration, and the final result.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/harmonic_mean_integration.jl#L23-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.hm_whiteningtransformation!-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.hm_whiteningtransformation!-Union{Tuple{V}, Tuple{I}, Tuple{T}, Tuple{HMIData{T,I,V},HMISettings}} where V&lt;:SpatialVolume where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hm_whiteningtransformation!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>function hm_whiteningtransformation!(result, settings)</p><p>Applies a whitening transformation to the samples. A custom whitening method can be used by overriding settings.whitening_function!</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/harmonic_mean_integration.jl#L90-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.issymmetric_around_origin" href="#BAT.issymmetric_around_origin"><code>BAT.issymmetric_around_origin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">issymmetric_around_origin(d::Distribution)</code></pre><p>Returns <code>true</code> (resp. <code>false</code>) if the Distribution is symmetric (resp. non-symmetric) around the origin.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/distributions/distribution_functions.jl#L37-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.log_volume" href="#BAT.log_volume"><code>BAT.log_volume</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">log_volume(vol::SpatialVolume)</code></pre><p>Get the logarithm of the volume of the space in <code>vol</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/parameters/spatialvolume.jl#L18-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.nparams" href="#BAT.nparams"><code>BAT.nparams</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nparams(X::Union{AbstractParamBounds,MCMCIterator,...})</code></pre><p>Get the number of parameters of <code>X</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/parameters/parambounds.jl#L4-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.param_bounds-Tuple{AbstractDensity}" href="#BAT.param_bounds-Tuple{AbstractDensity}"><code>BAT.param_bounds</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">param_bounds(density::AbstractDensity)::AbstractParamBounds</code></pre><p>Get the parameter bounds of <code>density</code>. See <code>density_logval!</code> for the implications and handling of the bounds.</p><p>Use</p><p>new_density = density[bounds::ParamVolumeBounds]</p><p>to create a new density function with additional bounds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/densities/density.jl#L39-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.proposal_rand!" href="#BAT.proposal_rand!"><code>BAT.proposal_rand!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function proposal_rand!(
    rng::AbstractRNG,
    pdist::GenericProposalDist,
    params_new::Union{AbstractVector,VectorOfSimilarVectors},
    params_old::Union{AbstractVector,VectorOfSimilarVectors}
)</code></pre><p>Generate one or multiple proposed parameter vectors, based on one or multiple previous parameter vectors.</p><p>Input:</p><ul><li><code>rng</code>: Random number generator to use</li><li><code>pdist</code>: Proposal distribution to use</li><li><code>params_old</code>: Old parameter values (vector or column vectors, if a matrix)</li></ul><p>Output is stored in</p><ul><li><code>params_new</code>: New parameter values (vector or column vectors, if a matrix)</li></ul><p>The caller must guarantee:</p><ul><li><code>size(params_old, 1) == size(params_new, 1)</code></li><li><code>size(params_old, 2) == size(params_new, 2)</code> or <code>size(params_old, 2) == 1</code></li><li><code>params_new !== params_old</code> (no aliasing)</li></ul><p>Implementations of <code>proposal_rand!</code> must be thread-safe.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/samplers/mcmc/proposaldist.jl#L72-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.spatialvolume" href="#BAT.spatialvolume"><code>BAT.spatialvolume</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">spatialvolume(b::ParamVolumeBounds)::SpatialVolume</code></pre><p>Returns the spatial volume that defines the parameter bounds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/parameters/parambounds.jl#L145-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.MCMCCallbackWrapper" href="#BAT.MCMCCallbackWrapper"><code>BAT.MCMCCallbackWrapper</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MCMCCallbackWrapper{F} &lt;: AbstractMCMCCallback</code></pre><p>Wraps a callable object to turn it into an <code>AbstractMCMCCallback</code>.</p><p>Constructor:</p><pre><code class="language-none">MCMCCallbackWrapper(f::Any)</code></pre><p><code>f</code> needs to support the call syntax of an <code>AbstractMCMCCallback</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/samplers/mcmc/mcmc_callback.jl#L38-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.SearchResult" href="#BAT.SearchResult"><code>BAT.SearchResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SearchResult{T&lt;:AbstractFloat, I&lt;:Integer}</code></pre><p>Stores the results of the space partitioning tree&#39;s search function</p><p><strong>Variables</strong></p><ul><li>&#39;pointIDs&#39; : the IDs of samples found, might be empty because it is optional</li><li>&#39;points&#39; : The number of points found.</li><li>&#39;maxLogProb&#39; : the maximum log. probability of the points found.</li><li>&#39;minLogProb&#39; : the minimum log. probability of the points found.</li><li>&#39;maxWeightProb&#39; : the weighted minimum log. probability found.</li><li>&#39;minWeightProb&#39; : the weighted maximum log. probfactor found.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/data_types.jl#L163-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.apply_bounds" href="#BAT.apply_bounds"><code>BAT.apply_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_bounds(x::Real, interval::ClosedInterval, boundary_type::BoundsType)</code></pre><p>Specify lower and upper bound via <code>interval</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/parameters/parambounds.jl#L94-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.apply_bounds!" href="#BAT.apply_bounds!"><code>BAT.apply_bounds!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_bounds!(params::AbstractVector, bounds::AbstractParamBounds)</code></pre><p>Apply <code>bounds</code> to parameters <code>params</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/parameters/parambounds.jl#L53-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.apply_bounds-Union{Tuple{H}, Tuple{L}, Tuple{X}, Tuple{X,L,H,BoundsType}, Tuple{X,L,H,BoundsType,Any}} where H&lt;:Real where L&lt;:Real where X&lt;:Real" href="#BAT.apply_bounds-Union{Tuple{H}, Tuple{L}, Tuple{X}, Tuple{X,L,H,BoundsType}, Tuple{X,L,H,BoundsType,Any}} where H&lt;:Real where L&lt;:Real where X&lt;:Real"><code>BAT.apply_bounds</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">apply_bounds(x::&lt;:Real, lo::&lt;:Real, hi::&lt;:Real, boundary_type::BoundsType)</code></pre><p>Apply lower/upper bound <code>lo</code>/<code>hi</code> to value <code>x</code>. <code>boundary_type</code> may be <code>hard_bounds</code>, <code>cyclic_bounds</code> or <code>reflective_bounds</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/parameters/parambounds.jl#L61-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.autocrl-Union{Tuple{AbstractArray{T,1}}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{Int64,1}}} where T&lt;:Real" href="#BAT.autocrl-Union{Tuple{AbstractArray{T,1}}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{Int64,1}}} where T&lt;:Real"><code>BAT.autocrl</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">autocrl(xv::AbstractVector{T}, kv::AbstractVector{Int} = Vector{Int}())</code></pre><p>autocorrelation := Σ Cov[x<em>i,x</em>(i+k)]/Var[x]</p><p>Computes the autocorrelations at various leg k of the input vector (time series) xv. The vector kv is the collections of lags to take into account</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/statistics/effective_sample_size.jl#L4-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.calculate_localmode-Tuple{Any}" href="#BAT.calculate_localmode-Tuple{Any}"><code>BAT.calculate_localmode</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">calculate_localmode(hist)</code></pre><p>Calculates the modes of a 1d statsbase histogram. A vector of the bin-center of the heighest bin(s) is(are) returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/plotting/localmodes.jl#L4-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.create_hypercube-Union{Tuple{T}, Tuple{Array{T,1},T}} where T&lt;:AbstractFloat" href="#BAT.create_hypercube-Union{Tuple{T}, Tuple{Array{T,1},T}} where T&lt;:AbstractFloat"><code>BAT.create_hypercube</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">create_hypercube{T&lt;:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume</code></pre><p>creates a hypercube shaped spatial volume</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/hyper_rectangle.jl#L2-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.create_hyperrectangle-Union{Tuple{I}, Tuple{T}, Tuple{I,DataSet{T,I},T,HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.create_hyperrectangle-Union{Tuple{I}, Tuple{T}, Tuple{I,DataSet{T,I},T,HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.create_hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function creates a hyper-rectangle around each starting sample. It starts by building a hyper-cube  and subsequently adapts each face individually, thus turning the hyper-cube into a hyper-rectangle. The faces are adjusted in a way to match the shape of the distribution as best as possible.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/hyper_rectangle.jl#L343-L348">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.effective_sample_size-Tuple{AbstractArray,AbstractArray{T,1} where T}" href="#BAT.effective_sample_size-Tuple{AbstractArray,AbstractArray{T,1} where T}"><code>BAT.effective_sample_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">effective_sample_size(params::AbstractArray, weights::AbstractVector; with_weights=true)</code></pre><p>Effective size estimation for a (multidimensional) ElasticArray. By default applies the Kish approximation with the weigths available, but can be turned off (with_weights=false).</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/statistics/effective_sample_size.jl#L72-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.effective_sample_size-Tuple{DensitySampleVector}" href="#BAT.effective_sample_size-Tuple{DensitySampleVector}"><code>BAT.effective_sample_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">effective_sample_size(samples::DensitySampleVector; with_weights=true)</code></pre><p>Effective size estimation for a (multidimensional) DensitySampleVector. By default applies the Kish approximation with the weigths available, but can be turned off (with_weights=false).</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/statistics/effective_sample_size.jl#L92-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.effective_sample_size-Union{Tuple{AbstractArray{T1,1}}, Tuple{T1}, Tuple{T2}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1}}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},AbstractArray{Int64,1}}} where T1&lt;:Real where T2&lt;:Number" href="#BAT.effective_sample_size-Union{Tuple{AbstractArray{T1,1}}, Tuple{T1}, Tuple{T2}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1}}, Tuple{AbstractArray{T1,1},AbstractArray{T2,1},AbstractArray{Int64,1}}} where T1&lt;:Real where T2&lt;:Number"><code>BAT.effective_sample_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Effective size estimation for a vector of samples xv. If a weight vector w is provided, the Kish approximation is applied.</p><p>By default computes the autocorrelation up to the square root of the number of entries in the vector, unless an explicit list of lags is provided (kv).</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/statistics/effective_sample_size.jl#L45-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.eval_density_logval!" href="#BAT.eval_density_logval!"><code>BAT.eval_density_logval!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eval_density_logval!(...)</code></pre><p>Internal function to first apply bounds and then evaluate density.</p><p>Guarantees that for out-of-bounds parameters:</p><ul><li><code>density_logval</code> is not called</li><li>log value of density is set to (resp. returned as) <code>-Inf</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/densities/density.jl#L199-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.eval_prior_posterior_logval!" href="#BAT.eval_prior_posterior_logval!"><code>BAT.eval_prior_posterior_logval!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">BAT.eval_prior_posterior_logval!(...)</code></pre><p>Internal function to first apply bounds to the parameters and then compute prior and posterior log valued.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/densities/bayesian_model.jl#L37-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.exec_capabilities" href="#BAT.exec_capabilities"><code>BAT.exec_capabilities</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">exec_capabilities(f, args...)::ExecCapabilities</code></pre><p>Determines the execution capabilities of a function <code>f</code> that supports an <code>ExecContext</code> argument, when called with arguments <code>args...</code>. The <code>ExecContext</code> argument itself is excluded from <code>args...</code> for <code>exec_capabilities</code>.</p><p>Before calling <code>f</code>, the caller must use</p><pre><code class="language-none">exec_capabilities(f, args...)</code></pre><p>to determine the execution capabilities of <code>f</code> with the intended arguments, and take the resulting <code>ExecCapabilities</code> into account. If <code>f</code> is not thread-safe (but remote-safe), and the caller needs to run it on multiple threads, the caller may deep-copy the function arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/scheduling/execcontext.jl#L106-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.find_hypercube_centers-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},WhiteningResult{T},HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.find_hypercube_centers-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},WhiteningResult{T},HMISettings}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.find_hypercube_centers</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">find_hypercube_centers(dataset::DataSet{T, I}, whiteningresult::WhiteningResult, settings::HMISettings)::Vector{I}</code></pre><p>finds possible starting points for the hyperrectangle creation</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/hyper_rectangle.jl#L49-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.gr_Rsqr-Tuple{AbstractArray{#s78,1} where #s78&lt;:MCMCBasicStats}" href="#BAT.gr_Rsqr-Tuple{AbstractArray{#s78,1} where #s78&lt;:MCMCBasicStats}"><code>BAT.gr_Rsqr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">gr_Rsqr(stats::AbstractVector{&lt;:MCMCBasicStats})</code></pre><p>Gelman-Rubin <span>$$R^2$$</span> for all parameters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/samplers/mcmc/mcmc_convergence.jl#L24-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.hyperrectangle_creationproccess!-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},T,HMISettings,Array{IntegrationVolume{T,I,HyperRectVolume{T}},1},Array{HyperRectVolume{T},1},Array{I,1},Base.Threads.Atomic{I},ProgressMeter.Progress}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.hyperrectangle_creationproccess!-Union{Tuple{I}, Tuple{T}, Tuple{DataSet{T,I},T,HMISettings,Array{IntegrationVolume{T,I,HyperRectVolume{T}},1},Array{HyperRectVolume{T},1},Array{I,1},Base.Threads.Atomic{I},ProgressMeter.Progress}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.hyperrectangle_creationproccess!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function assigns each thread its own hyper-rectangle to build, if in multithreading-mode.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/hm_integration_rectangle.jl#L104-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.initial_params!" href="#BAT.initial_params!"><code>BAT.initial_params!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">BAT.initial_params!(
    params::Union{AbstractVector{&lt;:Real},VectorOfSimilarVectors{&lt;:Real}},
    rng::AbstractRNG,
    model::AbstractBayesianModel,
    algorithm::MCMCAlgorithm
)::typeof(params)</code></pre><p>Fill <code>params</code> with random initial parameters suitable for <code>model</code> and <code>algorithm</code>. The default implementation will try to draw the initial parameters from the prior of the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/samplers/mcmc/mcmc_algorithm.jl#L36-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.modify_hypercube!-Union{Tuple{T}, Tuple{HyperRectVolume{T},Array{T,1},T}} where T&lt;:AbstractFloat" href="#BAT.modify_hypercube!-Union{Tuple{T}, Tuple{HyperRectVolume{T},Array{T,1},T}} where T&lt;:AbstractFloat"><code>BAT.modify_hypercube!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">create_hypercube!{T&lt;:Real}(origin::Vector{T}, edgelength::T)::HyperRectVolume</code></pre><p>resizes a hypercube shaped spatial volume</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/hyper_rectangle.jl#L20-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.modify_integrationvolume!-Union{Tuple{I}, Tuple{T}, Tuple{IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,DataSet{T,I},HyperRectVolume{T}}, Tuple{IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat" href="#BAT.modify_integrationvolume!-Union{Tuple{I}, Tuple{T}, Tuple{IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,DataSet{T,I},HyperRectVolume{T}}, Tuple{IntegrationVolume{T,I,V} where V&lt;:SpatialVolume,DataSet{T,I},HyperRectVolume{T},Bool}} where I&lt;:Integer where T&lt;:AbstractFloat"><code>BAT.modify_integrationvolume!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">modify_integrationvolume!(intvol::IntegrationVolume{T, I}, dataset::DataSet{T, I}, spvol::HyperRectVolume{T}, searchpts::Bool = true)</code></pre><p>updates an integration volume with new boundaries. Recalculates the pointcloud and volume.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/integration/ahmi/integration_volume.jl#L20-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.unsafe_density_logval" href="#BAT.unsafe_density_logval"><code>BAT.unsafe_density_logval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">BAT.unsafe_density_logval(
    density::AbstractDensity,
    params::AbstractVector{&lt;:Real},
    exec_context::ExecContext = ExecContext()
)</code></pre><p>Unsafe variant of <code>density_logval</code>, implementations may rely on</p><ul><li><code>size(params, 1) == nparams(density)</code></li></ul><p>The caller <em>must</em> ensure that these conditions are met!</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/densities/density.jl#L89-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.unsafe_density_logval!-Tuple{AbstractArray{#s45,1} where #s45&lt;:Real,AbstractDensity,ArraysOfArrays.ArrayOfSimilarArrays{#s31,1,1,2,P} where P&lt;:AbstractArray{#s31,2} where #s31&lt;:Real,ExecContext}" href="#BAT.unsafe_density_logval!-Tuple{AbstractArray{#s45,1} where #s45&lt;:Real,AbstractDensity,ArraysOfArrays.ArrayOfSimilarArrays{#s31,1,1,2,P} where P&lt;:AbstractArray{#s31,2} where #s31&lt;:Real,ExecContext}"><code>BAT.unsafe_density_logval!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">BAT.unsafe_density_logval!(
    r::AbstractVector{&lt;:Real},
    density::AbstractDensity,
    params::VectorOfSimilarVectors{&lt;:Real},
    exec_context::ExecContext
)</code></pre><p>Unsafe variant of <code>density_logval!</code>, implementations may rely on</p><ul><li><code>size(params, 1) == nparams(density)</code></li><li><code>size(params, 2) == length(r)</code></li></ul><p>The caller <em>must</em> ensure that these conditions are met!</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/densities/density.jl#L166-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BAT.wgt_effective_sample_size-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Real" href="#BAT.wgt_effective_sample_size-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T&lt;:Real"><code>BAT.wgt_effective_sample_size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">wgt_effective_sample_size(w::AbstractVector{T})</code></pre><p>Kish&#39;s approximation for weighted samples effective<em>sample</em>size estimation. Computes the weighting factor for weigthed samples, where w is the vector of weigths.</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/statistics/effective_sample_size.jl#L33-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.intersect-Tuple{ExecCapabilities,ExecCapabilities}" href="#Base.intersect-Tuple{ExecCapabilities,ExecCapabilities}"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">intersect(a:ExecCapabilities, b:ExecCapabilities)</code></pre><p>Get the intersection of execution capabilities of a and b, i.e. the <code>ExecCapabilities</code> that should be used when to functions are used in combination (e.g. in sequence).</p></div></div><a class="source-link" target="_blank" href="https://github.com/bat/BAT.jl/blob/e8c18f17234c0c44df995bafb4cc8bd1021937cb/src/scheduling/execcontext.jl#L76-L82">source</a></section><footer><hr/><a class="previous" href="../tutorial/"><span class="direction">Previous</span><span class="title">Tutorial</span></a><a class="next" href="../developing/"><span class="direction">Next</span><span class="title">Developer instructions</span></a></footer></article></body></html>
