var documenterSearchIndex = {"docs":
[{"location":"list_of_algorithms/#List-of-BAT-algorithms","page":"List of algorithms","title":"List of BAT algorithms","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT offers multiple algorithms for sampling, integration and optimization:","category":"page"},{"location":"list_of_algorithms/#Sampling-algorithms","page":"List of algorithms","title":"Sampling algorithms","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT function: bat_sample","category":"page"},{"location":"list_of_algorithms/#IIDSampling","page":"List of algorithms","title":"IIDSampling","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT sampling algorithm type: IIDSampling","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"bat_sample(target.prior, IIDSampling(nsamples=10^5))","category":"page"},{"location":"list_of_algorithms/#Metropolis-Hastings","page":"List of algorithms","title":"Metropolis-Hastings","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT sampling algorithm type: MCMCSampling, MCMC algorithm subtype: MetropolisHastings","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"bat_sample(target, MCMCSampling(mcalg = MetropolisHastings(), nsteps = 10^5, nchains = 4))","category":"page"},{"location":"list_of_algorithms/#Hamiltonian-MC","page":"List of algorithms","title":"Hamiltonian MC","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT sampling algorithm type: MCMCSampling, MCMC algorithm subtype: HamiltonianMC","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"import AdvancedHMC, ForwardDiff\nset_batcontext(ad = ADSelector(ForwardDiff))\nbat_sample(target, MCMCSampling(mcalg = HamiltonianMC()))","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"Requires the AdvancedHMC Julia package to be loaded explicitly.","category":"page"},{"location":"list_of_algorithms/#Reactive-Nested-Sampling-(experimental)","page":"List of algorithms","title":"Reactive Nested Sampling (experimental)","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT sampling algorithm type: ReactiveNestedSampling","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"import UltraNest\nbat_sample(target, ReactiveNestedSampling())","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"Requires the UltraNest Julia package to be loaded explicitly.","category":"page"},{"location":"list_of_algorithms/#Ellipsoidal-Nested-Sampling-(experimental)","page":"List of algorithms","title":"Ellipsoidal Nested Sampling (experimental)","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT sampling algorithm type: EllipsoidalNestedSampling","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"import NestedSamplers\nbat_sample(target, EllipsoidalNestedSampling())","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"Requires the NestedSamplers Julia package to be loaded explicitly.","category":"page"},{"location":"list_of_algorithms/#Sobol-Sampler","page":"List of algorithms","title":"Sobol Sampler","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT sampling algorithm type: SobolSampler","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"bat_sample(target, SobolSampler(nsamples=10^5))","category":"page"},{"location":"list_of_algorithms/#Grid-Sampler","page":"List of algorithms","title":"Grid Sampler","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT sampling algorithm type: GridSampler","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"bat_sample(target, GridSampler(ppa=100))","category":"page"},{"location":"list_of_algorithms/#Prior-Importance-Sampler","page":"List of algorithms","title":"Prior Importance Sampler","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT sampling algorithm type: PriorImportanceSampler","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"bat_sample(target, PriorImportanceSampler(nsamples=10^5))","category":"page"},{"location":"list_of_algorithms/#Integration-algorithms","page":"List of algorithms","title":"Integration algorithms","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT function: bat_integrate","category":"page"},{"location":"list_of_algorithms/#Vegas-Integration","page":"List of algorithms","title":"Vegas Integration","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT integration algorithm type: VEGASIntegration","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"import Cuba\nbat_integrate(target, VEGASIntegration())","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"Requires the Cuba Julia package to be loaded explicitly.","category":"page"},{"location":"list_of_algorithms/#Suave-Integration","page":"List of algorithms","title":"Suave Integration","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT integration algorithm type: SuaveIntegration","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"import Cuba\nbat_integrate(target, SuaveIntegration())","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"Requires the Cuba Julia package to be loaded explicitly.","category":"page"},{"location":"list_of_algorithms/#Cuhre-Integration","page":"List of algorithms","title":"Cuhre Integration","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT integration algorithm type: CuhreIntegration","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"import Cuba\nbat_integrate(target, CuhreIntegration())","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"Requires the Cuba Julia package to be loaded explicitly.","category":"page"},{"location":"list_of_algorithms/#Divonne-Integration","page":"List of algorithms","title":"Divonne Integration","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT integration algorithm type: DivonneIntegration ","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"import Cuba\nbat_integrate(target, DivonneIntegration())","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"Requires the Cuba Julia package to be loaded explicitly.","category":"page"},{"location":"list_of_algorithms/#Integration-via-Bridge-Sampling-(experimental)","page":"List of algorithms","title":"Integration via Bridge Sampling (experimental)","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT integration algorithm type: BridgeSampling ","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"bat_integrate(EvaluatedMeasure(target, smpls), BridgeSampling())","category":"page"},{"location":"list_of_algorithms/#Mode-finding-algorithms","page":"List of algorithms","title":"Mode finding algorithms","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT function: bat_findmode","category":"page"},{"location":"list_of_algorithms/#Optim.jl-Optimization-Algorithms","page":"List of algorithms","title":"Optim.jl Optimization Algorithms","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT mode finding algorithm type: OptimAlg.","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"using Optim\nbat_findmode(target, OptimAlg(optalg = Optim.NelderMead()))\n\nimport ForwardDiff\nset_batcontext(ad = ADSelector(ForwardDiff))\nbat_findmode(target, OptimAlg(optalg = Optim.LBFGS()))","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"Requires the Optim Julia package to be loaded explicitly.","category":"page"},{"location":"list_of_algorithms/#Optimization.jl-Optimization-Algorithms","page":"List of algorithms","title":"Optimization.jl Optimization Algorithms","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT mode finding algorithm type: OptimizationAlg.","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"using OptimizationOptimJL\n\nalg = OptimizationAlg(; \n    optalg = OptimizationOptimJL.ParticleSwarm(n_particles=10), \n    maxiters=200, \n    kwargs=(f_calls_limit=50,)\n)\nbat_findmode(target, alg)","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"Requires one of the Optimization.jl packages to be loaded explicitly.","category":"page"},{"location":"list_of_algorithms/#Maximum-Sample-Estimator","page":"List of algorithms","title":"Maximum Sample Estimator","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT mode finding algorithm type: MaxDensitySearch ","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"bat_findmode(smpls, MaxDensitySearch())","category":"page"},{"location":"list_of_algorithms/#File-I/O","page":"List of algorithms","title":"File-I/O","text":"","category":"section"},{"location":"list_of_algorithms/#Plain-HDF5","page":"List of algorithms","title":"Plain HDF5","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"BAT I/O algorithm type: BATHDF5IO ","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"import HDF5\nbat_write(\"results.h5\", smpls)\n\n# ... later ...\n\nsmpls = bat_read(\"results.h5\").result","category":"page"},{"location":"list_of_algorithms/#JLD2","page":"List of algorithms","title":"JLD2","text":"","category":"section"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"Not BAT-specific, JLD2 is able to handle complex Julia data structures in general.","category":"page"},{"location":"list_of_algorithms/","page":"List of algorithms","title":"List of algorithms","text":"using FileIO\nimport JLD2\nFileIO.save(\"results.jld2\", Dict(\"smpls\" => smpls))\n\n# ... later ...\n\nsmpls = FileIO.load(\"results.jld2\", \"smpls\")","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"BAT.jl is written in the Julia programming language. To use BAT.jl, you will need to install Julia itself, the BAT.jl Julia package, and some additional Julia packages. Depending on your use case, you may also want to need a Python installation with certain Python packages (optional).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Table of contents:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Pages = [\"installation.md\"]\nDepth = 3","category":"page"},{"location":"installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia is available for Linux, OS-X and Windows, and easy to install:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download Julia.\nExtract the archive (Linux), resp. drag Julia into Applications (OS-X) or run the installer (Windows).\nYou may want to add the Julia bin directory to your $PATH. To get the location of the Julia bin directory on OS-X or Windows, start a Julia session (via applications menu) and run the Julia command Sys.BINDIR.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"note: Note\nBAT.jl requires Julia >= v1.10, we recommend to use the latest stable Julia version for optimal performance.","category":"page"},{"location":"installation/#Installing-BAT.jl-and-related-Julia-packages","page":"Installation","title":"Installing BAT.jl and related Julia packages","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"BAT.jl is provided as a registered Julia package. To install it, simply run","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> pkg\"add BAT\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"However, you will likely need other Julia packages too. We recommend that you install certain statistics, plotting, I/O and array packages as well:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> pkg\"add BAT ArraysOfArrays Distributions ElasticArrays IntervalSets Parameters Plots StatsBase Tables TypedTables\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"In addition, these packages will need to be installed and loaded (using PackageName or import PackageName) to enable some optional BAT algorithms/functionalities:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> pkg\"add AutoDiffOperators AdvancedHMC Cuba Folds HDF5 NestedSamplers Optim\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the latest development version of BAT (main branch) instead of the latest stable release, use","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> pkg\"add BAT#main\"","category":"page"},{"location":"installation/#Installing-Visual-Studio-Code-and-Jupyter-(Optional)","page":"Installation","title":"Installing Visual Studio Code and Jupyter (Optional)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Please download and install the lastest Julia release.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"You may also want to install Visual Studio Code with the VS-Code Julia extension and/or a have a working Jupyter installation. JupyterLab Desktop is easy to install (but a full Anaconda or custom Python installation with Jupyter will work too, of course). For details regarding Julia and Jupyter, see the IJulia.jl documentation.","category":"page"},{"location":"installation/#IJulia-(Jupyter-Julia-kernel)","page":"Installation","title":"IJulia (Jupyter Julia kernel)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To use the the Julia Jupyter kernel, you need to add the package \"IJulia.jl\":","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"On Linux, simply use","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg\"add IJulia\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"On OS-X, if you have an existing Jupyter installation (e.g. via Anaconda) and would like Julia to use it (instead of an internal Conda installation, see above), use (e.g.)","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"ENV[\"JUPYTER\"] = \"$(homedir())/opt/anaconda3/bin/jupyter\"; pkg\"add IJulia\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"On Windows, if would like Julia to use an existing Jupyter installation (see above), use something like","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"ENV[\"JUPYTER\"] = \"DRIVE:/path/to/your/anaconda/.../jupyter.exe\"; pkg\"add IJulia\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia will remember the chosen Jupyter installation permanently, ENV[\"JUPYTER\"] only needs to be set the first time you run pkg\"add IJulia\".","category":"page"},{"location":"installation/#Environment-variables","page":"Installation","title":"Environment variables","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You may want/need to set the following environment variables:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"$PATH: Include the Julia bin-directory in your binary search path, see above. On OS-X and Windows, Visual Studio Code should detect the path your Julia binary automatically, if installed in the default location.\n$JULIA_NUM_THREADS: Number of threads to use for Julia multi-threading\n$JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR: If you want Julia to install packages in another location than $HOME/.julia.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"See the Julia manual for a description of other Julia-specific environment variables.","category":"page"},{"location":"installation/#Additional-customization-options","page":"Installation","title":"Additional customization options","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Note: If you want Julia to install packages in another location than $HOME/.julia, set the environment variables JULIA_DEPOT_PATH and JULIA_PKG_DEVDIR (see above).","category":"page"},{"location":"stable_api/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"stable_api/","page":"API Documentation","title":"API Documentation","text":"This is the stable public API of BAT. Forward/backward compatibility follows Julia's semantic versioning rules.","category":"page"},{"location":"stable_api/","page":"API Documentation","title":"API Documentation","text":"DocTestSetup  = quote\n    using BAT\nend","category":"page"},{"location":"stable_api/#Types","page":"API Documentation","title":"Types","text":"","category":"section"},{"location":"stable_api/","page":"API Documentation","title":"API Documentation","text":"Pages = [\"stable_api.md\"]\nOrder = [:type]","category":"page"},{"location":"stable_api/#Functions-and-macros","page":"API Documentation","title":"Functions and macros","text":"","category":"section"},{"location":"stable_api/","page":"API Documentation","title":"API Documentation","text":"Pages = [\"stable_api.md\"]\nOrder = [:macro, :function]","category":"page"},{"location":"stable_api/#Documentation","page":"API Documentation","title":"Documentation","text":"","category":"section"},{"location":"stable_api/","page":"API Documentation","title":"API Documentation","text":"\nbat_convergence\nbat_default\nbat_eff_sample_size\nbat_findmedian\nbat_findmode\nbat_initval\nbat_integrate\nbat_read\nbat_report\nbat_sample\nbat_write\nbat_transform\n\nget_batcontext\nset_batcontext\n\ndistbind\ndistprod\nlbqintegral\n\nAbstractMCMCWeightingScheme\nAbstractPosteriorMeasure\nAbstractTransformTarget\nAdaptiveMHTuning\nAssumeConvergence\nAutocorLenAlgorithm\nBATContext\nBATHDF5IO\nBATIOAlgorithm\nBrooksGelmanConvergence\nCuhreIntegration\nDensitySample\nDensitySampleVector\nDivonneIntegration\nDoNotTransform\nEffSampleSizeAlgorithm\nEffSampleSizeFromAC\nEvaluatedMeasure\nExplicitInit\nGelmanRubinConvergence\nGeyerAutocorLen\nHamiltonianMC\nIdentityTransformAlgorithm\nIIDSampling\nInitFromIID\nInitFromSamples\nInitFromTarget\nInitvalAlgorithm\nIntegrationAlgorithm\nKishESS\nMaxDensitySearch\nMCMCAlgorithm\nMCMCBurninAlgorithm\nMCMCChainPoolInit\nMCMCInitAlgorithm\nMCMCMultiCycleBurnin\nMCMCNoOpTuning\nMCMCSampling\nMCMCTuningAlgorithm\nMetropolisHastings\nMHProposalDistTuning\nModeAsDefined\nOptimAlg\nOptimizationAlg\nOrderedResampling\nPosteriorMeasure\nPriorSubstitution\nPriorToGaussian\nPriorToUniform\nRandResampling\nRepetitionWeighting\nSampleMedianEstimator\nSokalAutocorLen\nSuaveIntegration\nTransformAlgorithm\nVEGASIntegration\nBinningAlgorithm\nFixedNBins\nFreedmanDiaconisBinning\nRiceBinning\nScottBinning\nSquareRootBinning\nSturgesBinning\nToRealVector\n\nBAT.AbstractMedianEstimator\nBAT.AbstractModeEstimator\nBAT.AbstractSamplingAlgorithm\nBAT.ConvergenceTest","category":"page"},{"location":"stable_api/#BAT.bat_convergence","page":"API Documentation","title":"BAT.bat_convergence","text":"bat_convergence(\n    algoutput,\n    [algorithm::ConvergenceTest],\n    [context::BATContext]\n)\n\nCheck if an algorithm has converged, based on it's output algoutput\n\nReturns a NamedTuple of the shape\n\n(result, ...)\n\nresult indicates whether algoutput and must either be a Bool or support convert(Bool, result). It should typically contains measures of algorithm convergence, like a convergence value and it's threshold, etc.\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_convergence, add methods to bat_convergence_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_default","page":"API Documentation","title":"BAT.bat_default","text":"bat_default(f::Base.Callable, argname::Symbol, objectives...)\nbat_default(f::Base.Callable, argname::Val, objectives...)\n\nGet the default value for argument argname of function f to use for objective(s).\n\nobjective(s) are mandatory arguments of function f that semantically constitute it's main objective(s), and that that a good default choice of optional arguments (e.g. choice of algorithm(s), etc.) may depend on. Which arguments are considered to be objectives is function-specific.\n\nFor example:\n\nbat_default(bat_sample, :algorithm, density::PosteriorMeasure) == MetropolisHastings()\nbat_default(bat_sample, Val(:algorithm), samples::DensitySampleVector) == OrderedResampling()\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_eff_sample_size","page":"API Documentation","title":"BAT.bat_eff_sample_size","text":"bat_eff_sample_size(\n    v::Union{AbstractVector{<:Real},AbstractVectorOfSimilarVectors{<:Real}},\n    [algorithm::EffSampleSizeAlgorithm],\n    [context::BATContext]\n)\n\nbat_eff_sample_size(\n    smpls::DensitySampleVector,\n    [algorithm::EffSampleSizeAlgorithm],\n    [context::BATContext]\n)\n\nEstimate effective sample size estimation for variate series v, resp. density samples smpls, separately for each degree of freedom.\n\nReturns a NamedTuple of the shape\n\n(result = eff_sample_size, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_eff_sample_size, add methods to bat_eff_sample_size_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_findmedian","page":"API Documentation","title":"BAT.bat_findmedian","text":"bat_findmedian(\n    samples::DensitySampleVector\n)\n\nThe function computes the median of marginalized samples.\n\nReturns a NamedTuple of the shape\n\n(result = v, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_findmedian, add methods to bat_findmedian_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_findmode","page":"API Documentation","title":"BAT.bat_findmode","text":"bat_findmode(\n    target::BAT.AnySampleable,\n    [algorithm::BAT.AbstractModeEstimator],\n    [context::BATContext]\n)::DensitySampleVector\n\nEstimate the global mode of target.\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_findmode, add methods to bat_findmode_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_initval","page":"API Documentation","title":"BAT.bat_initval","text":"bat_initval(\n    target::BAT.MeasureLike,\n    [algorithm::BAT.InitvalAlgorithm],\n    [context::BATContext]\n)::V\n\nbat_initval(\n    target::BAT.MeasureLike,\n    n::Integer,\n    [algorithm::BAT.InitvalAlgorithm],\n    [context::BATContext]\n)::AbstractVector{<:V}\n\nGenerate one or n random initial/starting value(s) suitable for target.\n\nAssuming the variates of target are of type T, returns a NamedTuple of the shape\n\n(result = X::AbstractVector{T}, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_initval, add methods likebat_initval_impl(target::MeasureLike, algorithm::InitvalAlgorithm, context::BATContext)\nbat_initval_impl(target::MeasureLike, n::Integer, algorithm::InitvalAlgorithm, context::BATContext)to bat_initval_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_integrate","page":"API Documentation","title":"BAT.bat_integrate","text":"bat_integrate(\n    target::AnySampleable,\n    [algorithm::IntegrationAlgorithm],\n    [context::BATContext]\n)::DensitySampleVector\n\nCalculate the integral (evidence) of target.\n\nReturns a NamedTuple of the shape\n\n(result = X::Measurements.Measurement, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_integrate, add methods to bat_integrate_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_read","page":"API Documentation","title":"BAT.bat_read","text":"bat_read(\n    filename::AbstractString,\n    [key,]\n    [algorithm::BATIOAlgorithm]\n)\n\nRead data (optionally selected by key) from filename using algorithm.\n\nExample:\n\nsmpls = bat_read(\"samples.hdf5\", smpls).result\n\nReturns (result = content, ...)\n\nResult properties not listed here are specific to the output algorithm and are not part of the stable public API.\n\nSee bat_write.\n\nCurrently supported file formats are:\n\nHDF5 with file extension \".h5\" or \".hdf5\"\n\nnote: Note\nHDF5 I/O functionality is only available when the HDF5 package is loaded (e.g. via import HDF5).\n\nnote: Note\nDo not add add algorithms to bat_read, add algorithms to bat_read_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_report","page":"API Documentation","title":"BAT.bat_report","text":"bat_report(obj...)::Markdown.MD\n\nGenerate a report on the given object(s).\n\nSpecialize bat_report! instead of bat_report.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_sample","page":"API Documentation","title":"BAT.bat_sample","text":"bat_sample(\n    target::BAT.AnySampleable,\n    [algorithm::BAT.AbstractSamplingAlgorithm],\n    [context::BATContext]\n)::DensitySampleVector\n\nDraw samples from target using algorithm.\n\nDepending on sampling algorithm, the samples may be independent or correlated (e.g. when using MCMC).\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_sample, add methods to bat_sample_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_write","page":"API Documentation","title":"BAT.bat_write","text":"bat_write(\n    filename::AbstractString,\n    content,\n    [algorithm::BATIOAlgorithm]\n)\n\nWrite content to file filename using algorithm.\n\nExample:\n\nsmpls = bat_sample(posterior, ...).result\nbat_write(\"samples.hdf5\", smpls)\n\nReturns (result = filename, ...)\n\nResult properties not listed here are specific to the output algorithm and are not part of the stable public API.\n\nSee bat_read.\n\nCurrently supported file formats are:\n\nHDF5 with file extension \".h5\" or \".hdf5\"\n\nnote: Note\nHDF5 I/O functionality is only available when the HDF5 package is loaded (e.g. via import HDF5).\n\nnote: Note\nDo not add add algorithms to bat_write, add algorithms to bat_write_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.bat_transform","page":"API Documentation","title":"BAT.bat_transform","text":"bat_transform(\n    how::AbstractTransformTarget,\n    object,\n    [algorithm::TransformAlgorithm]\n)\n\nbat_transform(\n    f,\n    object,\n    [algorithm::TransformAlgorithm]\n)\n\nTransform object to another variate space defined/implied by target, res. using the transformation function f.\n\nReturns a NamedTuple of the shape\n\n(result = newdensity, trafo = vartrafo::Function, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\n\n\nAs a convenience,\n\nflat_smpls, f_flatten = bat_transform(Vector, measure)\nflat_smpls, f_flatten = bat_transform(Vector, samples)\n\ncan be used to flatten a the variate type of a measure (res. samples of a measure) to something like Vector{<:Real}.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.get_batcontext","page":"API Documentation","title":"BAT.get_batcontext","text":"get_batcontext()::BATContext\nget_batcontext(obj)::BATContext\n\nGets resp. sets the default computational context for BAT.\n\nWill create and set a new default context if none exists.\n\nNote: get_batcontext() does not have a stable return type. Code that needs type stability should pass a context to algorithms explicitly. BAT algorithms that call other algorithms must forward their context automatically, so context is always type stable within nested BAT algorithms.\n\nSee BATContext and set_batcontext.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.set_batcontext","page":"API Documentation","title":"BAT.set_batcontext","text":"set_batcontext(new_context::BATContext)\n\nset_batcontext(;\n    precision = ...,\n    rng = ...,\n    ad = ...\n)\n\nSets the default computational context for BAT.\n\nSee BATContext and get_batcontext.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.distbind","page":"API Documentation","title":"BAT.distbind","text":"distbind(f_k, dist, ::typeof(merge))\n\nPerforms a generalized monadic bind, in the functional programming sense, with a transition kernel f_k, a distribution dist, using merge to control the type of \"flattening\".\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.distprod","page":"API Documentation","title":"BAT.distprod","text":"distprod(;a = some_dist, b = some_other_dist, ...)\ndistprod(();a = some_dist, b = some_other_dist, ...))\ndistprod([dist1, dist2, dist2, ...])\n\nGenerate a product of distributions, returning either a distribution that has NamedTuples as variates, or arrays as variates.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.lbqintegral","page":"API Documentation","title":"BAT.lbqintegral","text":"lbqintegral(integrand, measure)\nlbqintegral(likelihood, prior)\n\nReturns an object that represents the Lebesgue integral over a function in respect to s reference measure. It is also the non-normalized posterior measure that results from integrating the likelihood of a given observation in respect to a prior measure.\n\n\n\n\n\n","category":"function"},{"location":"stable_api/#BAT.AbstractMCMCWeightingScheme","page":"API Documentation","title":"BAT.AbstractMCMCWeightingScheme","text":"abstract type AbstractMCMCWeightingScheme{T<:Real}\n\nAbstract class for weighting schemes for MCMC samples.\n\nWeight values will have type T.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractPosteriorMeasure","page":"API Documentation","title":"BAT.AbstractPosteriorMeasure","text":"abstract type AbstractPosteriorMeasure <: BATMeasure end\n\nAbstract type for posterior probability densities.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractTransformTarget","page":"API Documentation","title":"BAT.AbstractTransformTarget","text":"abstract type AbstractTransformTarget\n\nAbstract type for probability density transformation targets.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AdaptiveMHTuning","page":"API Documentation","title":"BAT.AdaptiveMHTuning","text":"struct AdaptiveMHTuning <: MHProposalDistTuning\n\nAdaptive MCMC tuning strategy for Metropolis-Hastings samplers.\n\nAdapts the proposal function based on the acceptance ratio and covariance of the previous samples.\n\nConstructors:\n\nAdaptiveMHTuning(; fields...)\n\nFields:\n\nλ::Float64: Controls the weight given to new covariance information in adapting the     proposal distribution. Default: 0.5\nα::IntervalSets.ClosedInterval{Float64}: Metropolis-Hastings acceptance ratio target, tuning will try to adapt     the proposal distribution to bring the acceptance ratio inside this interval. Default: ClosedInterval(0.15, 0.35)\nβ::Float64: Controls how much the spread of the proposal distribution is     widened/narrowed depending on the current MH acceptance ratio. Default: 1.5\nc::IntervalSets.ClosedInterval{Float64}: Interval for allowed scale/spread of the proposal distribution. Default: ClosedInterval(0.0001, 100.0)\nr::Real: Reweighting factor. Take accumulated sample statistics of previous     tuning cycles into account with a relative weight of r. Set to     0 to completely reset sample statistics between each tuning cycle. Default: 0.5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AssumeConvergence","page":"API Documentation","title":"BAT.AssumeConvergence","text":"struct AssumeConvergence <: ConvergenceTest\n\nNo-op convergence algorithm for bat_convergence, will always declare convergence.\n\nConstructors:\n\nAssumeConvergence(converged::Bool = true)\n\nFields:\n\nconverged::Bool: Default: true\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AutocorLenAlgorithm","page":"API Documentation","title":"BAT.AutocorLenAlgorithm","text":"abstract type AutocorLenAlgorithm\n\nAbstract type for integrated autocorrelation length estimation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.BATContext","page":"API Documentation","title":"BAT.BATContext","text":"struct BATContext{T}\n\nExperimental feature, not yet part of stable public API.\n\nSet the default computational context for BAT.\n\nConstructors:\n\nBATContext{T}(rng::AbstractRNG, cunit::AbstractComputeUnit, ADSelector::AD)\n\nBATContext(;\n    precision::Type{<:AbstractFloat} = ...,\n    rng::AbstractRNG = ...,\n    cunit::HeterogeneousComputing.AbstractComputeUnit = ...,\n    ad::AutoDiffOperators.ADSelector = ...,\n)\n\nSee get_batcontext and set_batcontext.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.BATHDF5IO","page":"API Documentation","title":"BAT.BATHDF5IO","text":"struct BATHDF5IO <: BATIOAlgorithm\n\nSelects the BAT HDF5 format as the output format.\n\nSee bat_write and bat_read.\n\nConstructors:\n\nBATHDF5IO()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.BATIOAlgorithm","page":"API Documentation","title":"BAT.BATIOAlgorithm","text":"abstract type BATIOAlgorithm\n\nAbstract type for density transformation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.BrooksGelmanConvergence","page":"API Documentation","title":"BAT.BrooksGelmanConvergence","text":"struct BrooksGelmanConvergence <: ConvergenceTest\n\nBrooks-Gelman maximum R^2 convergence test.\n\nConstructors:\n\nBrooksGelmanConvergence(; fields...)\n\nFields:\n\nthreshold::Float64: Default: 1.1\ncorrected::Bool: Default: false\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.CuhreIntegration","page":"API Documentation","title":"BAT.CuhreIntegration","text":"struct CuhreIntegration <: IntegrationAlgorithm\n\nCuhreIntegration integration algorithm.\n\nConstructors:\n\nCuhreIntegration(; fields...)\n\nFields:\n\ntrafo::AbstractTransformTarget: Default: PriorToUniform()\nrtol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:RTOL))\natol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:ATOL))\nminevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MINEVALS))\nmaxevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXEVALS))\nkey::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:KEY))\nnthreads::Int64: Default: Base.Threads.nthreads()\nstrict::Bool: Default: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DensitySample","page":"API Documentation","title":"BAT.DensitySample","text":"struct DensitySample\n\nA weighted sample drawn according to an statistical density, e.g. a BAT.MeasureLike.\n\nConstructors:\n\nDensitySampleVector(v::Any, logd::Real, weight::Real, info::Any, aux::Any)\n\nFields:\n\nv::Any: variate value\nlogd::Real: log(density) value at v\nweight::Real: Weight of the sample\ninfo::Any: Additional info on the provenance of the sample. Content depends     on the sampling algorithm.\naux::Any: Custom user-defined information attached to the sample.\n\nUse DensitySampleVector to store vectors of multiple samples with an efficient column-based memory layout.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DensitySampleVector","page":"API Documentation","title":"BAT.DensitySampleVector","text":"struct DensitySampleVector <: AbstractVector{<:DensitySample}\n\nA vector of DensitySample elements.\n\nDensitySampleVector is currently a type alias for StructArrays.StructArray{<:DensitySample,...}, though this is subject to change without deprecation.\n\nConstructors:\n\n    DensitySampleVector(\n        (\n            v::AbstractVector{<:AbstractVector{<:Real}},\n            logd::AbstractVector{<:Real},\n            weight::AbstractVector{<:Real},\n            info::AbstractVector{<:Any},\n            aux::AbstractVector{<:Any}\n        )\n    )\n\n    DensitySampleVector(\n            v::AbstractVector,\n            logval::AbstractVector{<:Real};\n            weight::Union{AbstractVector{<:Real}, Symbol} = fill(1, length(eachindex(v))),\n            info::AbstractVector = fill(nothing, length(eachindex(v))),\n            aux::AbstractVector = fill(nothing, length(eachindex(v)))\n        )\n\nWith weight = :multiplicity repeated samples will be replaced by a single sample, with a weight equal to the number of repetitions.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DivonneIntegration","page":"API Documentation","title":"BAT.DivonneIntegration","text":"struct DivonneIntegration <: IntegrationAlgorithm\n\nDivonneIntegration integration algorithm.\n\nConstructors:\n\nDivonneIntegration(; fields...)\n\nFields:\n\ntrafo::AbstractTransformTarget: Default: PriorToUniform()\nrtol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:RTOL))\natol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:ATOL))\nminevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MINEVALS))\nmaxevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXEVALS))\nkey1::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:KEY1))\nkey2::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:KEY2))\nkey3::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:KEY3))\nmaxpass::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXPASS))\nborder::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:BORDER))\nmaxchisq::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXCHISQ))\nmindeviation::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MINDEVIATION))\nngiven::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NGIVEN))\nldxgiven::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:LDXGIVEN))\nnextra::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NEXTRA))\nnthreads::Int64: Default: Base.Threads.nthreads()\nstrict::Bool: Default: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.DoNotTransform","page":"API Documentation","title":"BAT.DoNotTransform","text":"struct DoNotTransform <: AbstractTransformTarget\n\nThe identity density transformation target, specifies that densities should not be transformed.\n\nConstructors:\n\nDoNotTransform()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.EffSampleSizeAlgorithm","page":"API Documentation","title":"BAT.EffSampleSizeAlgorithm","text":"abstract type EffSampleSizeAlgorithm\n\nAbstract type for integrated autocorrelation length estimation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.EffSampleSizeFromAC","page":"API Documentation","title":"BAT.EffSampleSizeFromAC","text":"struct EffSampleSizeFromAC <: EffSampleSizeAlgorithm\n\nEffective sample size estimation based on the integrated autocorrelation length of the samples.\n\nConstructors:\n\nEffSampleSizeFromAC(; fields...)\n\nFields:\n\nacalg::AutocorLenAlgorithm: Default: GeyerAutocorLen()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.EvaluatedMeasure","page":"API Documentation","title":"BAT.EvaluatedMeasure","text":"struct EvaluatedMeasure <: BATMeasure\n\nCombined a measure with samples, and other information on it.\n\nConstructors:\n\nEvaluatedMeasure(\n    measure;\n    samples = ..., approx = ..., mass = ..., mode = ...,\n    _generator = ...\n)\n\nnote: Note\nField _generator does not form part of the stable public API and is subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ExplicitInit","page":"API Documentation","title":"BAT.ExplicitInit","text":"struct ExplicitInit <: InitvalAlgorithm\n\nUses initial values from a given vector of one or more values/variates. The values are used in the order they appear in the vector, not randomly.\n\nConstructors:\n\nExplicitInit(; fields...)\n\nFields:\n\nxs::AbstractVector\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.GelmanRubinConvergence","page":"API Documentation","title":"BAT.GelmanRubinConvergence","text":"struct GelmanRubinConvergence <: ConvergenceTest\n\nGelman-Rubin maximum R^2 convergence test.\n\nConstructors:\n\nGelmanRubinConvergence(; fields...)\n\nFields:\n\nthreshold::Float64: Default: 1.1\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.GeyerAutocorLen","page":"API Documentation","title":"BAT.GeyerAutocorLen","text":"struct GeyerAutocorLen <: AutocorLenAlgorithm\n\nIntegrated autocorrelation length estimation based on Geyer’s initial monotone sequence criterion\n\nSee C. J. Geyer, \"Practical Markov Chain Monte Carlo\" (1992) and C. J. Geyer, \"Introduction to Markov Chain Monte Carlo\" (2011).\n\nConstructors:\n\nGeyerAutocorLen()\n\nThe same algorithm is used by STAN (v2.21) and MCMCChains.jl (v3.0, function ess_rhat).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.HamiltonianMC","page":"API Documentation","title":"BAT.HamiltonianMC","text":"struct HamiltonianMC <: MCMCAlgorithm\n\nThe Hamiltonian Monte Carlo (HMC) sampling algorithm.\n\nUses the HMC implementation provided by the package AdvancedHMC.\n\nHMC uses gradients of the target measure's density, so your BATContext needs to include an ADSelector to specify which automatic differentiation backend should be used.\n\nNote: The fields of HamiltonianMC are still subject to change, and not\n\nyet part of stable public BAT API!*\n\nConstructors:\n\nHamiltonianMC(; fields...)\n\nFields:\n\nmetric::BAT.HMCMetric: Default: DiagEuclideanMetric()\nintegrator::Any: Default: extdefault(pkgext(Val(:AdvancedHMC)), Val(:DEFAULTINTEGRATOR))\ntermination::Any: Default: extdefault(pkgext(Val(:AdvancedHMC)), Val(:DEFAULTTERMINATION_CRITERION))\ntuning::BAT.HMCTuningAlgorithm: Default: StanHMCTuning()\n\nnote: Note\nHamiltonianMC is only available if the AdvancedHMC package is loaded (e.g. via import AdvancedHMC). \n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.IdentityTransformAlgorithm","page":"API Documentation","title":"BAT.IdentityTransformAlgorithm","text":"struct IdentityTransformAlgorithm <: TransformAlgorithm\n\nA no-op density transform algorithm that leaves any density unchanged.\n\nConstructors:\n\nIdentityTransformAlgorithm()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.IIDSampling","page":"API Documentation","title":"BAT.IIDSampling","text":"struct IIDSampling <: AbstractSamplingAlgorithm\n\nSample via Random.rand.\n\nConstructors:\n\nIIDSampling(; fields...)\n\nFields:\n\nnsamples::Int64: Default: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitFromIID","page":"API Documentation","title":"BAT.InitFromIID","text":"struct InitFromIID <: InitvalAlgorithm\n\nGenerates initial values for sampling, optimization, etc. by random resampling from a given set of samples.\n\nConstructors:\n\nInitFromIID()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitFromSamples","page":"API Documentation","title":"BAT.InitFromSamples","text":"struct InitFromSamples <: InitvalAlgorithm\n\nGenerates initial values for sampling, optimization, etc. by direct sampling from a given i.i.d. sampleable source.\n\nConstructors:\n\nInitFromSamples()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitFromTarget","page":"API Documentation","title":"BAT.InitFromTarget","text":"struct InitFromTarget <: InitvalAlgorithm\n\nGenerates initial values for sampling, optimization, etc. by direct i.i.d. sampling a suitable component of that target density (e.g. it's prior) that supports it.\n\nIf the target is supports direct i.i.d. sampling, e.g. because it is a distribution, initial values are sampled directly from the target.\nIf the target is a posterior density, initial values are sampled from the prior (or the prior's prior if the prior is a posterior itself, etc.).\nIf the target is a sampled density, initial values are (re-)sampled from the available samples.\n\nConstructors:\n\nInitFromTarget()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.InitvalAlgorithm","page":"API Documentation","title":"BAT.InitvalAlgorithm","text":"abstract type BAT.InitvalAlgorithm\n\nAbstract type for BAT initial/starting value generation algorithms.\n\nMany algorithms in BAT, like MCMC and optimization, need initial/starting values.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.IntegrationAlgorithm","page":"API Documentation","title":"BAT.IntegrationAlgorithm","text":"abstract type IntegrationAlgorithm\n\nAbstract type for integration algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.KishESS","page":"API Documentation","title":"BAT.KishESS","text":"struct KishESS <: EffSampleSizeAlgorithm\n\nKish's effective sample size estimator, uses only the sample weights.\n\nConstructors:\n\nKishESS()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MaxDensitySearch","page":"API Documentation","title":"BAT.MaxDensitySearch","text":"MaxDensitySearch <: AbstractModeEstimator\n\nConstructors:\n\nMaxDensitySearch()\n\nEstimate the mode as the variate with the highest posterior density value within a given set of samples.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCAlgorithm","page":"API Documentation","title":"BAT.MCMCAlgorithm","text":"abstract type MCMCAlgorithm\n\nAbstract type for Markov chain Monte Carlo algorithms.\n\nTo implement a new MCMC algorithm, subtypes of both MCMCAlgorithm and MCMCIterator are required.\n\nnote: Note\nThe details of the MCMCIterator and MCMCAlgorithm API required to implement a new MCMC algorithm currently do not (yet) form part of the stable API and are subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCBurninAlgorithm","page":"API Documentation","title":"BAT.MCMCBurninAlgorithm","text":"abstract type MCMCBurninAlgorithm\n\nAbstract type for MCMC burn-in algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCChainPoolInit","page":"API Documentation","title":"BAT.MCMCChainPoolInit","text":"struct MCMCChainPoolInit <: MCMCInitAlgorithm\n\nMCMC chain pool initialization strategy.\n\nConstructors:\n\nMCMCChainPoolInit(; fields...)\n\nFields:\n\ninit_tries_per_chain::IntervalSets.ClosedInterval{Int64}: Default: ClosedInterval(8, 128)\nnsteps_init::Int64: Default: 1000\ninitval_alg::InitvalAlgorithm: Default: InitFromTarget()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCInitAlgorithm","page":"API Documentation","title":"BAT.MCMCInitAlgorithm","text":"abstract type MCMCInitAlgorithm\n\nAbstract type for MCMC initialization algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCMultiCycleBurnin","page":"API Documentation","title":"BAT.MCMCMultiCycleBurnin","text":"struct MCMCMultiCycleBurnin <: MCMCBurninAlgorithm\n\nA multi-cycle MCMC burn-in algorithm.\n\nConstructors:\n\nMCMCMultiCycleBurnin(; fields...)\n\nFields:\n\nnsteps_per_cycle::Int64: Default: 10000\nmax_ncycles::Int64: Default: 30\nnsteps_final::Int64: Default: div(nstepspercycle, 10)\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCNoOpTuning","page":"API Documentation","title":"BAT.MCMCNoOpTuning","text":"MCMCNoOpTuning <: MCMCTuningAlgorithm\n\nNo-op tuning, marks MCMC chains as tuned without performing any other changes on them. Useful if chains are pre-tuned or tuning is an internal part of the MCMC sampler implementation.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCSampling","page":"API Documentation","title":"BAT.MCMCSampling","text":"struct MCMCSampling <: AbstractSamplingAlgorithm\n\nSamples a probability density using Markov chain Monte Carlo.\n\nConstructors:\n\nMCMCSampling(; fields...)\n\nFields:\n\nmcalg::MCMCAlgorithm: Default: MetropolisHastings()\ntrafo::AbstractTransformTarget: Default: bat_default(MCMCSampling, Val(:trafo), mcalg)\nnchains::Int64: Default: 4\nnsteps::Int64: Default: bat_default(MCMCSampling, Val(:nsteps), mcalg, trafo, nchains)\ninit::MCMCInitAlgorithm: Default: bat_default(MCMCSampling, Val(:init), mcalg, trafo, nchains, nsteps)\nburnin::MCMCBurninAlgorithm: Default: bat_default(MCMCSampling, Val(:burnin), mcalg, trafo, nchains, nsteps)\nconvergence::BAT.ConvergenceTest: Default: BrooksGelmanConvergence()\nstrict::Bool: Default: true\nstore_burnin::Bool: Default: false\nnonzero_weights::Bool: Default: true\ncallback::Function: Default: nop_func\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MCMCTuningAlgorithm","page":"API Documentation","title":"BAT.MCMCTuningAlgorithm","text":"abstract type MCMCTuningAlgorithm\n\nAbstract type for MCMC tuning algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MetropolisHastings","page":"API Documentation","title":"BAT.MetropolisHastings","text":"struct MetropolisHastings <: MCMCAlgorithm\n\nMetropolis-Hastings MCMC sampling algorithm.\n\nConstructors:\n\nMetropolisHastings(; fields...)\n\nFields:\n\nproposal::Distributions.ContinuousDistribution: Default: TDist(1.0)\nweighting::AbstractMCMCWeightingScheme: Default: RepetitionWeighting()\ntuning::MHProposalDistTuning: Default: AdaptiveMHTuning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.MHProposalDistTuning","page":"API Documentation","title":"BAT.MHProposalDistTuning","text":"abstract type MHProposalDistTuning\n\nAbstract type for Metropolis-Hastings tuning strategies for proposal distributions.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ModeAsDefined","page":"API Documentation","title":"BAT.ModeAsDefined","text":"struct ModeAsDefined <: AbstractModeEstimator\n\nGet the mode as defined by the density, resp. the underlying distribution (if available), via StatsBase.mode.\n\nConstructors:\n\nModeAsDefined()        \n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.OptimAlg","page":"API Documentation","title":"BAT.OptimAlg","text":"OptimAlg\n\nSelects an optimization algorithm from the Optim.jl package.\n\nNote that when using first order algorithms like Optim.LBFGS, your BATContext needs to include an ADSelector that specifies which automatic differentiation backend should be used.\n\nConstructors:\n\nOptimAlg(; fields...)\n\noptimalg must be an Optim.AbstractOptimizer.\n\nFields:\n\noptalg::Any: Default: extdefault(pkgext(Val(:Optim)), Val(:DEFAULTOPTALG))\ntrafo::AbstractTransformTarget: Default: PriorToGaussian()\ninit::InitvalAlgorithm: Default: InitFromTarget()\nmaxiters::Int64: Default: 1000\nmaxtime::Float64: Default: NaN\nabstol::Float64: Default: NaN\nreltol::Float64: Default: 0.0\nkwargs::NamedTuple: Default: (;)\n\nnote: Note\nThis algorithm is only available if the Optim package is loaded (e.g. via     import Optim.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.OptimizationAlg","page":"API Documentation","title":"BAT.OptimizationAlg","text":"OptimizationAlg\n\nSelects an optimization algorithm from the Optimization.jl package. Note that when using first order algorithms like OptimizationOptimJL.LBFGS, your BATContext needs to include an ADSelector that specifies which automatic differentiation backend should be used. Constructors:\n\nOptimizationAlg(; fields...)\n\noptalg must be an Optimization.AbstractOptimizer. The field kwargs can be used to pass additional keywords to the optimizers See the Optimization.jl documentation for the available keyword arguments. Fields:\n\noptalg::Any: Default: extdefault(pkgext(Val(:Optimization)), Val(:DEFAULTOPTALG))\ntrafo::AbstractTransformTarget: Default: PriorToGaussian()\ninit::InitvalAlgorithm: Default: InitFromTarget()\nmaxiters::Int64: Default: 1000\nmaxtime::Float64: Default: NaN\nabstol::Float64: Default: NaN\nreltol::Float64: Default: 0.0\nkwargs::NamedTuple: Default: (;)\n\nnote: Note\nThis algorithm is only available if the Optimization package or any of its submodules, like OptimizationOptimJL, is loaded (e.g. via     import Optimization).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.OrderedResampling","page":"API Documentation","title":"BAT.OrderedResampling","text":"struct OrderedResampling <: AbstractSamplingAlgorithm\n\nEfficiently resamples from a given series of samples, keeping the order of samples.\n\nCan be used to efficiently convert weighted samples into samples with unity weights.\n\nConstructors:\n\nOrderedResampling(; fields...)\n\nFields:\n\nnsamples::Int64: Default: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PosteriorMeasure","page":"API Documentation","title":"BAT.PosteriorMeasure","text":"struct PosteriorMeasure{Li,Pr<:AbstractMeasure} <: AbstractPosteriorMeasure\n\nA representation of a PosteriorMeasure, based a likelihood and prior. Likelihood and prior be accessed via\n\ngetlikelihood(posterior::PosteriorMeasure)::Li\ngetprior(posterior::PosteriorMeasure)::Pr\n\nConstructors:\n\nPosteriorMeasure(likelihood, prior)\nPosteriorMeasure{T<:Real}(likelihood, prior)\n\nFields:\n\nlikelihood::Any\nprior::MeasureBase.AbstractMeasure\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PriorSubstitution","page":"API Documentation","title":"BAT.PriorSubstitution","text":"struct PriorSubstitution <: TransformAlgorithm\n\nSubstitute the prior by a given distribution and transform the likelihood accordingly. The log(abs(jacobian)) of the transformation does not need to be auto-differentiable even for operations that use the gradient of the posterior.\n\nConstructors:\n\nPriorSubstitution()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PriorToGaussian","page":"API Documentation","title":"BAT.PriorToGaussian","text":"struct PriorToGaussian <: AbstractTransformTarget\n\nSpecifies that posterior densities should be transformed in a way that makes their pior equivalent to a standard multivariate normal distribution with an identity covariance matrix.\n\nConstructors:\n\nPriorToGaussian()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.PriorToUniform","page":"API Documentation","title":"BAT.PriorToUniform","text":"struct PriorToUniform <: AbstractTransformTarget\n\nSpecifies that posterior densities should be transformed in a way that makes their pior equivalent to a uniform distribution over the unit hypercube.\n\nConstructors:\n\nPriorToUniform()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RandResampling","page":"API Documentation","title":"BAT.RandResampling","text":"struct RandResampling <: AbstractSamplingAlgorithm\n\nResamples from a given set of samples.\n\nConstructors:\n\nRandResampling(; fields...)\n\nFields:\n\nnsamples::Int64: Default: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RepetitionWeighting","page":"API Documentation","title":"BAT.RepetitionWeighting","text":"struct RepetitionWeighting{T<:AbstractFloat} <: AbstractMCMCWeightingScheme{T}\n\nSample weighting scheme suitable for sampling algorithms which may repeated samples multiple times in direct succession (e.g. MetropolisHastings). The repeated sample is stored only once, with a weight equal to the number of times it has been repeated (e.g. because a Markov chain has not moved during a sampling step).\n\nConstructors:\n\nRepetitionWeighting()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SampleMedianEstimator","page":"API Documentation","title":"BAT.SampleMedianEstimator","text":"struct SampleMedianEstimator <: AbstractMedianEstimator\n\nGet median values from samples using standard Julia statistics functions.\n\nConstructors:\n\nSampleMedianEstimator()        \n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SokalAutocorLen","page":"API Documentation","title":"BAT.SokalAutocorLen","text":"struct SokalAutocorLen <: AutocorLenAlgorithm\n\nIntegrated autocorrelation length estimation based on the automated windowing procedure descibed in A. D. Sokal, \"Monte Carlo Methods in Statistical Mechanics\" (1996)\n\nSame procedure is used by the emcee Python package (v3.0).\n\nConstructors:\n\nSokalAutocorLen(; fields...)\n\nFields:\n\nc::Int64: Step size for window search Default: 5\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SuaveIntegration","page":"API Documentation","title":"BAT.SuaveIntegration","text":"struct SuaveIntegration <: IntegrationAlgorithm\n\nSuaveIntegration integration algorithm.\n\nConstructors:\n\nSuaveIntegration(; fields...)\n\nFields:\n\ntrafo::AbstractTransformTarget: Default: PriorToUniform()\nrtol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:RTOL))\natol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:ATOL))\nminevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MINEVALS))\nmaxevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXEVALS))\nnnew::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NNEW))\nnmin::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NMIN))\nflatness::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:FLATNESS))\nnthreads::Int64: Default: Base.Threads.nthreads()\nstrict::Bool: Default: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.TransformAlgorithm","page":"API Documentation","title":"BAT.TransformAlgorithm","text":"abstract type TransformAlgorithm\n\nAbstract type for density transformation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.VEGASIntegration","page":"API Documentation","title":"BAT.VEGASIntegration","text":"struct VEGASIntegration <: IntegrationAlgorithm\n\nVEGASIntegration integration algorithm.\n\nConstructors:\n\nVEGASIntegration(; fields...)\n\nFields:\n\ntrafo::AbstractTransformTarget: Default: PriorToUniform()\nrtol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:RTOL))\natol::Float64: Default: ext_default(pkgext(Val(:Cuba)), Val(:ATOL))\nminevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MINEVALS))\nmaxevals::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:MAXEVALS))\nnstart::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NSTART))\nnincrease::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NINCREASE))\nnbatch::Int64: Default: ext_default(pkgext(Val(:Cuba)), Val(:NBATCH))\nnthreads::Int64: Default: Base.Threads.nthreads()\nstrict::Bool: Default: true\n\nnote: Note\nThis functionality is only available when the Cuba package is loaded (e.g. via import CUBA).\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.BinningAlgorithm","page":"API Documentation","title":"BAT.BinningAlgorithm","text":"abstract type BinningAlgorithm\n\nAbstract type for binning algorithms.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.FixedNBins","page":"API Documentation","title":"BAT.FixedNBins","text":"FixedNBins(nbins::Int)\n\nSelects a fixed number of bins.\n\nConstructor: FixedNBins(; fields...)\n\nFields:\n\nnbins::Int64: Default: 200\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.FreedmanDiaconisBinning","page":"API Documentation","title":"BAT.FreedmanDiaconisBinning","text":"struct FreedmanDiaconisBinning <: BinningAlgorithm\n\nSelects automatic binning based on the Freedman–Diaconis rule.\n\nConstructor: FreedmanDiaconisBinning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.RiceBinning","page":"API Documentation","title":"BAT.RiceBinning","text":"struct RiceBinning <: BinningAlgorithm\n\nSelects automatic binning based on the Rice rule.\n\nConstructor: RiceBinning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ScottBinning","page":"API Documentation","title":"BAT.ScottBinning","text":"struct ScottBinning <: BinningAlgorithm\n\nSelects automatic binning based on Scott's normal reference rule.\n\nConstructor: ScottBinning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SquareRootBinning","page":"API Documentation","title":"BAT.SquareRootBinning","text":"struct SquareRootBinning <: BinningAlgorithm\n\nSelects automatic binning based on the Square-root choice.\n\nConstructor: SquareRootBinning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.SturgesBinning","page":"API Documentation","title":"BAT.SturgesBinning","text":"struct SturgesBinning <: BinningAlgorithm\n\nSelects automatic binning based on Sturges' formula.\n\nConstructor: SturgesBinning()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ToRealVector","page":"API Documentation","title":"BAT.ToRealVector","text":"struct ToRealVector <: AbstractTransformTarget\n\nSpecifies that the input should be transformed into a measure over the space of real-valued flat vectors.\n\nConstructors:\n\nToRealVector()\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractMedianEstimator","page":"API Documentation","title":"BAT.AbstractMedianEstimator","text":"abstract type BAT.AbstractMedianEstimator\n\nAbstract type for BAT optimization algorithms.\n\nA typical application for optimization in BAT is mode estimation (see bat_findmode),\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractModeEstimator","page":"API Documentation","title":"BAT.AbstractModeEstimator","text":"abstract type BAT.AbstractModeEstimator\n\nAbstract type for BAT optimization algorithms.\n\nA typical application for optimization in BAT is mode estimation (see bat_findmode),\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.AbstractSamplingAlgorithm","page":"API Documentation","title":"BAT.AbstractSamplingAlgorithm","text":"abstract type BAT.AbstractSamplingAlgorithm\n\nAbstract type for BAT sampling algorithms. See bat_sample.\n\n\n\n\n\n","category":"type"},{"location":"stable_api/#BAT.ConvergenceTest","page":"API Documentation","title":"BAT.ConvergenceTest","text":"abstract type ConvergenceTest\n\nAbstract type for integrated autocorrelation length estimation algorithms.\n\n\n\n\n\n","category":"type"},{"location":"faq/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"... to be written ...","category":"page"},{"location":"developing/#Developer-Instructions","page":"Developer instructions","title":"Developer Instructions","text":"","category":"section"},{"location":"developing/#Documentation-Generation","page":"Developer instructions","title":"Documentation Generation","text":"","category":"section"},{"location":"developing/","page":"Developer instructions","title":"Developer instructions","text":"To generate and view a local version of the documentation, run","category":"page"},{"location":"developing/","page":"Developer instructions","title":"Developer instructions","text":"cd docs\njulia make.jl","category":"page"},{"location":"developing/","page":"Developer instructions","title":"Developer instructions","text":"then open \"docs/build/index.html\" in your browser.","category":"page"},{"location":"developing/#Code-Reloading","page":"Developer instructions","title":"Code Reloading","text":"","category":"section"},{"location":"developing/","page":"Developer instructions","title":"Developer instructions","text":"When changing the code of BAT.jl and testing snippets and examples in the REPL, automatic code reloading comes in very handy. Try out Revise.jl.","category":"page"},{"location":"internal_api/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"note: Note\nThis is the documentation of BAT's internal API. The internal API is fully accessible to users, but all aspects of it are subject to change without deprecation. Functionalities of the internal API that, over time, turn out to require user access (e.g. to support advanced use cases) will be evolved to gain a stable interface and then promoted to the public API.","category":"page"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"DocTestSetup  = quote\n    using BAT\nend","category":"page"},{"location":"internal_api/#Types","page":"Internal API","title":"Types","text":"","category":"section"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"Pages = [\"internal_api.md\"]\nOrder = [:type]","category":"page"},{"location":"internal_api/#Functions-and-macros","page":"Internal API","title":"Functions and macros","text":"","category":"section"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"Pages = [\"internal_api.md\"]\nOrder = [:macro, :function]","category":"page"},{"location":"internal_api/#Documentation","page":"Internal API","title":"Documentation","text":"","category":"section"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"BAT.AbstractSampleGenerator\nBAT.AnySampleable\nBAT.BasicMvStatistics\nBAT.BATMeasure\nBAT.BATPushFwdMeasure\nBAT.BATPwrMeasure\nBAT.BATWeightedMeasure\nBAT.CholeskyPartialWhitening\nBAT.CholeskyWhitening\nBAT.DensitySampleMeasure\nBAT.ENSAutoProposal\nBAT.ENSBound\nBAT.ENSEllipsoidBound\nBAT.ENSMultiEllipsoidBound\nBAT.ENSNoBounds\nBAT.ENSProposal\nBAT.ENSRandomWalk\nBAT.ENSSlice\nBAT.ENSUniformly\nBAT.FullMeasureTransform\nBAT.LFDensity\nBAT.LFDensityWithGrad\nBAT.LogDVal\nBAT.MCMCIterator\nBAT.MCMCSampleGenerator\nBAT.MeasureLike\nBAT.NoWhitening\nBAT.OnlineMvCov\nBAT.OnlineMvMean\nBAT.OnlineUvMean\nBAT.OnlineUvVar\nBAT.SampleTransformation\nBAT.StandardMvNormal\nBAT.StandardMvUniform\nBAT.StandardUvNormal\nBAT.StandardUvUniform\nBAT.StatisticalWhitening\nBAT.UnshapeTransformation\nBAT.WhiteningAlgorithm\n\nBAT.logvalof\nBAT.bat_report!\nBAT.fft_autocor\nBAT.fft_autocov\nBAT.argchoice_msg\nBAT.bg_R_2sqr\nBAT.checked_logdensityof\nBAT.drop_low_weight_samples\nBAT.find_marginalmodes\nBAT.get_bin_centers\nBAT.getlikelihood\nBAT.getprior\nBAT.gr_Rsqr\nBAT.is_log_zero\nBAT.issymmetric_around_origin\nBAT.log_zero_density\nBAT.repetition_to_weights\nBAT.smallest_credible_intervals\nBAT.sum_first_dim\nBAT.supports_rand\nBAT.trunc_logpdf_ratio\nBAT.truncate_dist_hard\nBAT.measure_support","category":"page"},{"location":"internal_api/#BAT.AbstractSampleGenerator","page":"Internal API","title":"BAT.AbstractSampleGenerator","text":"abstract type AbstractSampleGenerator\n\nBAT-internal, not part of stable public API.\n\nAbstract super type for sample generators.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.AnySampleable","page":"Internal API","title":"BAT.AnySampleable","text":"BAT.AnySampleable = Union{...}\n\nUnion of all types that BAT can sample from:\n\nBAT.MeasureLike\nBAT.DensitySampleVector\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BasicMvStatistics","page":"Internal API","title":"BAT.BasicMvStatistics","text":"BasicMvStatistics{T<:Real,W}\n\nBAT-internal, not part of stable public API.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BATMeasure","page":"Internal API","title":"BAT.BATMeasure","text":"abstract type BATMeasure <:AbstractMeasure\n\nBAT-internal, not part of stable public API.\n\nSubtypes must implement DensityInterface.logdensityof and ValueShapes.varshape.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BATPushFwdMeasure","page":"Internal API","title":"BAT.BATPushFwdMeasure","text":"BATPushFwdMeasure\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BATPwrMeasure","page":"Internal API","title":"BAT.BATPwrMeasure","text":"BATPwrMeasure\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.BATWeightedMeasure","page":"Internal API","title":"BAT.BATWeightedMeasure","text":"struct BATWeightedMeasure <: BATMeasure\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.CholeskyPartialWhitening","page":"Internal API","title":"BAT.CholeskyPartialWhitening","text":"struct CholeskyPartialWhitening <: WhiteningAlgorithm\n\nBAT-internal, not part of stable public API.\n\nWhitening transformation based on a Cholesky transformation of the empirical sample covariance matrix.\n\nOnly transforms dimensions (degrees of freedom) for which the marginalized distribution asymptotically approaches zero in the positive and negative direction.\n\nConstructors:\n\nCholeskyPartialWhitening()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.CholeskyWhitening","page":"Internal API","title":"BAT.CholeskyWhitening","text":"struct CholeskyWhitening <: WhiteningAlgorithm\n\nBAT-internal, not part of stable public API.\n\nWhitening transformation based on a Cholesky transformation of the empirical sample covariance matrix.\n\nConstructors:\n\nCholeskyWhitening()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.DensitySampleMeasure","page":"Internal API","title":"BAT.DensitySampleMeasure","text":"DensitySampleMeasure\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSAutoProposal","page":"Internal API","title":"BAT.ENSAutoProposal","text":"struct BAT.ENSAutoProposal <: ENSProposal\n\nExperimental feature, not part of stable public API.\n\nChoose the proposal depending from the number of dimensions:      ndims < 10: Proposals.Uniform,       10 ≤ ndims ≤ 20: Proposals.RWalk,       ndims > 20: Proposals.Slice\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSBound","page":"Internal API","title":"BAT.ENSBound","text":"abstract type ENSBound\n\nExperimental feature, not part of stable public API.\n\nAbstract type for the bounds of the sampling region used by EllipsoidalNestedSampling.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSEllipsoidBound","page":"Internal API","title":"BAT.ENSEllipsoidBound","text":"struct BAT.ENSEllipsoidBound <: ENSBound\n\nExperimental feature, not part of stable public API.\n\nEllipsoid bound means that a n-dimensional ellipsoid limits the sampling volume.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSMultiEllipsoidBound","page":"Internal API","title":"BAT.ENSMultiEllipsoidBound","text":"struct BAT.ENSMultiEllipsoidBound <: ENSBound\n\nExperimental feature, not part of stable public API.\n\nMulti ellipsoid bound means that there are multiple elliposid in an optimal clustering are used to limit the sampling volume.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSNoBounds","page":"Internal API","title":"BAT.ENSNoBounds","text":"struct BAT.ENSNoBounds <: ENSBound\n\nExperimental feature, not part of stable public API.\n\nNo bounds means that the whole volume from the unit Cube is used to find new points.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSProposal","page":"Internal API","title":"BAT.ENSProposal","text":"abstract type ENSProposal\n\nExperimental feature, not part of stable public API.\n\nAbstract type for the algorithms to propose new live points used used by EllipsoidalNestedSampling.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSRandomWalk","page":"Internal API","title":"BAT.ENSRandomWalk","text":"struct BAT.ENSRandomWalk <: ENSProposal\n\nExperimental feature, not part of stable public API.\n\nNew live point is proposed by using a random walk away from an existing live point.\n\nConstructors:\n\nENSRandomWalk(; fields...)\n\nFields:\n\nratio::Float64: Acceptance ratio for the random walk. Default: 0.5\nwalks::Int64: Minimum number of random walk steps. Default: 25\nscale::Float64: Scale of the proposal distribution. Default: 1.0\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSSlice","page":"Internal API","title":"BAT.ENSSlice","text":"struct BAT.ENSSlice <: ENSProposal\n\nExperimental feature, not part of stable public API.\n\nNew live point is proposed by a serie of random slices from an existing live-point.\n\nConstructors:\n\nENSSlice(; fields...)\n\nFields:\n\nslices::Int64: Minimum number of slices Default: 5\nscale::Float64: Scale of the proposal distribution. Default: 1.0\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.ENSUniformly","page":"Internal API","title":"BAT.ENSUniformly","text":"struct BAT.ENSUniformly <: ENSProposal\n\nExperimental feature, not part of stable public API.\n\nEach point in the bounding volume has an uniform chance to be proposed as a new live point.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.FullMeasureTransform","page":"Internal API","title":"BAT.FullMeasureTransform","text":"struct FullMeasureTransform <: TransformAlgorithm\n\nBAT-internal, not part of stable public API.\n\nTransform the density as a whole a given specified target space. Operations that use the gradient of the density will require to the log(abs(jacobian)) of the transformation to be auto-differentiable.\n\nConstructors:\n\nFullMeasureTransform()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.LFDensity","page":"Internal API","title":"BAT.LFDensity","text":"struct BAT.LFDensity{F}\n\nBAT-internal, not part of stable public API.\n\nWraps a log-density function log_f.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.LFDensityWithGrad","page":"Internal API","title":"BAT.LFDensityWithGrad","text":"BAT.LFDensityWithGrad{F,G} <: BATDensity\n\nBAT-internal, not part of stable public API.\n\nConstructors:\n\nLFDensityWithGrad(logf, valgradlogf)\n\nA density defined by a function that computes it's logarithmic value at given points, as well as a function that computes both the value and the gradient.\n\nIt must be safe to execute both functions in parallel on multiple threads and processes.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.LogDVal","page":"Internal API","title":"BAT.LogDVal","text":"struct LogDVal{T<:Real}\n\nLogDVal is deprecated and will be removed in future major or even minor BAT versions.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.MCMCIterator","page":"Internal API","title":"BAT.MCMCIterator","text":"abstract type MCMCIterator end\n\nBAT-internal, not part of stable public API.\n\nRepresents the current state of an MCMC chain.\n\nnote: Note\nThe details of the MCMCIterator and MCMCAlgorithm API (see below) currently do not form part of the stable API and are subject to change without deprecation.\n\nTo implement a new MCMC algorithm, subtypes of both MCMCAlgorithm and MCMCIterator are required.\n\nThe following methods must be defined for subtypes of MCMCIterator (e.g. SomeMCMCIter<:MCMCIterator):\n\nBAT.getalgorithm(chain::SomeMCMCIter)::MCMCAlgorithm\n\nBAT.mcmc_target(chain::SomeMCMCIter)::BATMeasure\n\nBAT.get_context(chain::SomeMCMCIter)::BATContext\n\nBAT.mcmc_info(chain::SomeMCMCIter)::MCMCIteratorInfo\n\nBAT.nsteps(chain::SomeMCMCIter)::Int\n\nBAT.nsamples(chain::SomeMCMCIter)::Int\n\nBAT.current_sample(chain::SomeMCMCIter)::DensitySample\n\nBAT.sample_type(chain::SomeMCMCIter)::Type{<:DensitySample}\n\nBAT.samples_available(chain::SomeMCMCIter, nonzero_weights::Bool = false)::Bool\n\nBAT.get_samples!(samples::DensitySampleVector, chain::SomeMCMCIter, nonzero_weights::Bool)::typeof(samples)\n\nBAT.next_cycle!(chain::SomeMCMCIter)::SomeMCMCIter\n\nBAT.mcmc_step!(\n    chain::SomeMCMCIter\n    callback::Function,\n)::nothing\n\nThe following methods are implemented by default:\n\ngetalgorithm(chain::MCMCIterator)\nmcmc_target(chain::MCMCIterator)\nDensitySampleVector(chain::MCMCIterator)\nmcmc_iterate!(chain::MCMCIterator, ...)\nmcmc_iterate!(chains::AbstractVector{<:MCMCIterator}, ...)\nisvalidchain(chain::MCMCIterator)\nisviablechain(chain::MCMCIterator)\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.MCMCSampleGenerator","page":"Internal API","title":"BAT.MCMCSampleGenerator","text":"BAT.MCMCSampleGenerator\n\nBAT-internal, not part of stable public API.\n\nMCMC sample generator.\n\nConstructors:\n\nMCMCSampleGenerator(chain::AbstractVector{<:MCMCIterator})\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.MeasureLike","page":"Internal API","title":"BAT.MeasureLike","text":"BAT.MeasureLike = Union{...}\n\nBAT-internal, not part of stable public API.\n\nUnion of all types that BAT will accept as a measures or convert to measures.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.NoWhitening","page":"Internal API","title":"BAT.NoWhitening","text":"struct NoWhitening <: WhiteningAlgorithm\n\nBAT-internal, not part of stable public API.\n\nNo-op whitening transformation, leaves samples unchanged.\n\nConstructors:\n\nNoWhitening()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineMvCov","page":"Internal API","title":"BAT.OnlineMvCov","text":"OnlineMvCov{T<:AbstractFloat,W} <: AbstractMatrix{T}\n\nBAT-internal, not part of stable public API.\n\nImplementation based on variance calculation Algorithms of Welford and West.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineMvMean","page":"Internal API","title":"BAT.OnlineMvMean","text":"OnlineMvMean{T<:AbstractFloat} <: AbstractVector{T}\n\nBAT-internal, not part of stable public API.\n\nMultivariate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineUvMean","page":"Internal API","title":"BAT.OnlineUvMean","text":"OnlineUvMean{T<:AbstractFloat}\n\nBAT-internal, not part of stable public API.\n\nUnivariate mean implemented via Kahan-Babuška-Neumaier summation.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.OnlineUvVar","page":"Internal API","title":"BAT.OnlineUvVar","text":"OnlineUvVar{T<:AbstractFloat,W}\n\nBAT-internal, not part of stable public API.\n\nImplementation based on variance calculation Algorithms of Welford and West.\n\nW must either be Weights (no bias correction) or one of AnalyticWeights, FrequencyWeights or ProbabilityWeights to specify the desired bias correction method.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.SampleTransformation","page":"Internal API","title":"BAT.SampleTransformation","text":"struct SampleTransformation <: TransformAlgorithm\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardMvNormal","page":"Internal API","title":"BAT.StandardMvNormal","text":"StandardMvNormal{T<:Real} <: Distributions.AbstractMvNormal\n\nA standard n-dimensional multivariate normal distribution with it's mean at the origin and an identity covariance matrix.\n\nConstructor:\n\n    StandardMvNormal(n::Integer)\n    StandardMvNormal{T<:Real}(n::Integer)\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardMvUniform","page":"Internal API","title":"BAT.StandardMvUniform","text":"StandardMvUniform{T<:Real} <: Distributions.Distribution{Multivariate,Continuous}\n\nA standard n-dimensional multivariate uniform distribution, from zero to one in each dimension.\n\nConstructor:\n\n    StandardMvUniform(n::Integer)\n    StandardMvUniform{T<:Real}(n::Integer)\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardUvNormal","page":"Internal API","title":"BAT.StandardUvNormal","text":"StandardUvNormal{T<:Real} <: Distributions.Distribution{Univariate,Continuous}\n\nA standard normal distribution with a mean of zero and a variance of one.\n\nConstructor:\n\n    StandardUvNormal()\n    StandardUvNormal{T<:Real}()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StandardUvUniform","page":"Internal API","title":"BAT.StandardUvUniform","text":"StandardUvUniform{T<:Real} <: Distributions.Distribution{Univariate,Continuous}\n\nA standard uniform distribution between zero and one.\n\nConstructor:\n\n    StandardUvUniform()\n    StandardUvUniform{T<:Real}()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.StatisticalWhitening","page":"Internal API","title":"BAT.StatisticalWhitening","text":"struct StatisticalWhitening <: WhiteningAlgorithm\n\nBAT-internal, not part of stable public API.\n\nWhitening transformation based statistical whitening. CholeskyPartialWhitening\n\nConstructors:\n\nStatisticalWhitening()\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.UnshapeTransformation","page":"Internal API","title":"BAT.UnshapeTransformation","text":"struct UnshapeTransformation <: TransformAlgorithm\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.WhiteningAlgorithm","page":"Internal API","title":"BAT.WhiteningAlgorithm","text":"abstract type WhiteningAlgorithm\n\nBAT-internal, not part of stable public API.\n\nAbstract type for sample whitening algorithms.\n\n\n\n\n\n","category":"type"},{"location":"internal_api/#BAT.logvalof","page":"Internal API","title":"BAT.logvalof","text":"logvalof(r::NamedTuple{(...,:log,...)})::Real\nlogvalof(r::LogDVal)::Real\n\nBAT-internal, not part of stable public API.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.bat_report!","page":"Internal API","title":"BAT.bat_report!","text":"BAT.bat_report!(md::Markdown.MD, obj)\n\nBAT-internal, not part of stable public API.\n\nAdd report on obj to md.\n\nSee bat_report.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.fft_autocor","page":"Internal API","title":"BAT.fft_autocor","text":"fft_autocor(v::AbstractVector{<:Real})\nfft_autocor(v::AbstractVectorOfSimilarVectors{<:Real})\n\nBAT-internal, not part of stable public API.\n\nCompute the autocorrelation function (ACF) of variate series v, separately for each degree of freedom.\n\nUses FFT, in contract to StatsBase.autocor.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.fft_autocov","page":"Internal API","title":"BAT.fft_autocov","text":"fft_autocov(v::AbstractVector{<:Real})\nfft_autocov(v::AbstractVectorOfSimilarVectors{<:Real})\n\nBAT-internal, not part of stable public API.\n\nCompute the autocovariance of of variate series v, separately for each degree of freedom.\n\nUses FFT, in contract to StatsBase.autocov.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.argchoice_msg","page":"Internal API","title":"BAT.argchoice_msg","text":"argchoice_msg(f::Base.Callable, argname::Val, x)\n\nBAT-internal, not part of stable public API.\n\nGenerates an information message regarding the choice of value x for argument argname of function f.\n\nThe value x will often be the result of bat_default.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.bg_R_2sqr","page":"Internal API","title":"BAT.bg_R_2sqr","text":"bg_R_2sqr(stats::AbstractVector{<:MCMCBasicStats}; corrected::Bool = false)\nbg_R_2sqr(samples::AbstractVector{<:DensitySampleVector}; corrected::Bool = false)\n\nBAT-internal, not part of stable public API.\n\nBrooks-Gelman R_2^2 for all DOF. If normality is assumed, 'corrected' should be set to true to account for the sampling variability.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.checked_logdensityof","page":"Internal API","title":"BAT.checked_logdensityof","text":"checked_logdensityof(measure::AbstractMeasure, v::Any, T::Type{<:Real})\n\nBAT-internal, not part of stable public API.\n\nEvaluates the measure's log-density value via DensityInterface.logdensityof and performs additional checks.\n\nThrows a BAT.EvalException on any of these conditions:\n\nThe variate shape of measure (if known) does not match the shape of v.\nThe return value of DensityInterface.logdensityof is NaN.\nThe return value of DensityInterface.logdensityof is an equivalent of positive infinity.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.drop_low_weight_samples","page":"Internal API","title":"BAT.drop_low_weight_samples","text":"drop_low_weight_samples(\n    samples::DensitySampleVector,\n    fraction::Real = 10^-4\n)\n\nBAT-internal, not part of stable public API.\n\nDrop fraction of the total probability mass from samples to filter out the samples with the lowest weight.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.find_marginalmodes","page":"Internal API","title":"BAT.find_marginalmodes","text":"find_marginalmodes(marg::MarginalDist)\n\nBAT-internal, not part of stable public API.\n\nFind the modes of a MarginalDist. Returns a vector of the bin-centers of the bin(s) with the heighest weight.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.get_bin_centers","page":"Internal API","title":"BAT.get_bin_centers","text":"get_bin_centers(marg::MarginalDist)\n\nBAT-internal, not part of stable public API.\n\nReturns a vector of the bin-centers.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.getlikelihood","page":"Internal API","title":"BAT.getlikelihood","text":"getlikelihood(posterior::AbstractPosteriorMeasure)::BATDenstiy\n\nBAT-internal, not part of stable public API.\n\nThe likelihood density of posterior. The likelihood may or may not be normalized.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.getprior","page":"Internal API","title":"BAT.getprior","text":"getprior(posterior::AbstractPosteriorMeasure)::BATMeasure\n\nBAT-internal, not part of stable public API.\n\nThe prior density of posterior. The prior may or may not be normalized.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.gr_Rsqr","page":"Internal API","title":"BAT.gr_Rsqr","text":"gr_Rsqr(stats::AbstractVector{<:MCMCBasicStats})\ngr_Rsqr(samples::AbstractVector{<:DensitySampleVector})\n\nBAT-internal, not part of stable public API.\n\nGelman-Rubin R^2 for all DOF.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.is_log_zero","page":"Internal API","title":"BAT.is_log_zero","text":"BAT.is_log_zero(x::Real, T::Type = typeof(x)}\n\nBAT-internal, not part of stable public API.\n\nCheck if x is an equivalent of log of zero, resp. negative infinity, in respect to type T.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.issymmetric_around_origin","page":"Internal API","title":"BAT.issymmetric_around_origin","text":"issymmetric_around_origin(d::Distribution)\n\nBAT-internal, not part of stable public API.\n\nReturns true (resp. false) if the Distribution is symmetric (resp. non-symmetric) around the origin.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.log_zero_density","page":"Internal API","title":"BAT.log_zero_density","text":"BAT.log_zero_density(T::Type{<:Real})\n\nlog-density value to assume for regions of implicit zero density, e.g. outside of variate/parameter bounds/support.\n\nReturns an equivalent of negative infinity.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.repetition_to_weights","page":"Internal API","title":"BAT.repetition_to_weights","text":"repetition_to_weights(v::AbstractVector)\n\nBAT-internal, not part of stable public API.\n\nDrop (subsequently) repeated samples by adding weights.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.smallest_credible_intervals","page":"Internal API","title":"BAT.smallest_credible_intervals","text":"smallest_credible_intervals(\n    X::AbstractVector{<:Real}, W::AbstractWeights = UnitWeights(...);\n    nsigma_equivalent::Integer = 1\n)\n\nBAT-internal, not part of stable public API.\n\nFind smalles credible intervals with nsigma_equivalent of 1, 2 or 3 (containing 68.27%, 90.00%, 95.45% or 99.73% of the total probability mass).\n\n\n\n\n\nsmallest_credible_intervals(smpl::DensitySampleVector{<:AbstractVector{<:Real}}; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.sum_first_dim","page":"Internal API","title":"BAT.sum_first_dim","text":"@propagate_inbounds sum_first_dim(A::AbstractArray, j::Integer, ks::Integer...)\n\nBAT-internal, not part of stable public API.\n\nCalculate the equivalent of sum(A[:, j, ks...]).\n\n\n\n\n\n@propagate_inbounds sum_first_dim(A::AbstractArray)\n\nBAT-internal, not part of stable public API.\n\nIf A is a vector, return sum(A), else sum(A, 1)[:].\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.supports_rand","page":"Internal API","title":"BAT.supports_rand","text":"supports_rand(m)\n\nBAT-internal, not part of stable public API.\n\nConvert a measure-like object m supports rand.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.trunc_logpdf_ratio","page":"Internal API","title":"BAT.trunc_logpdf_ratio","text":"BAT.trunc_logpdf_ratio(orig_dist::Distribution{TP}, trunc_dist::Distribution{TP})::AbstractFloat\n\nBAT-internal, not part of stable public API.\n\nComputes the log-ratio between the amplitude of the PDF of a truncated distribution and the original (untruncted) distribution, within the support of the truncated one.\n\nThe PDF of both distributions must have the same shape within the support of trunc_dist and may only differ in amplitude.\n\nMainly used to implement BAT.truncate_batmeasure, in conjunction with BAT.truncate_dist_hard.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.truncate_dist_hard","page":"Internal API","title":"BAT.truncate_dist_hard","text":"BAT.truncate_dist_hard(dist::Distribution{Univariate}, bounds::Interval)::Distribution{Univariate}\nBAT.truncate_dist_hard(dist::Distribution{Multivariate}, bounds::AbstractArray{<:Interval})::Distribution{Multivariate}\n\nBAT-internal, not part of stable public API.\n\nGeneralized variant of Distributions.truncated - also handles multivariate distributions and operates on a best-effort basis: If distributions cannot be truncated, may return the original distribution.\n\nReturns a NamedTuple\n\n    (dist = trunc_dist, logweight = logweight)\n\nwith the truncated distribution and the log-PDF amplitude difference to the original (see BAT.trunc_logpdf_ratio).\n\nMainly used to implement BAT.truncate_batmeasure.\n\n\n\n\n\n","category":"function"},{"location":"internal_api/#BAT.measure_support","page":"Internal API","title":"BAT.measure_support","text":"measure_support(measure::AbstractMeasure)\n\nBAT-internal, not part of stable public API.\n\nGet the parameter bounds of measure. May return a IntervalsSets.Domain or BAT.UnknownDomain\n\n\n\n\n\n","category":"function"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"plotting/#Plot-Recipes","page":"Plotting","title":"Plot Recipes","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The plot recipes described below apply for plotting samples. Only the plotting of estimators (mean, standard deviation, global mode and local mode) is currently only supported for samples.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Also see the plotting tutorial for examples and further information on the plotting options.","category":"page"},{"location":"plotting/#1D-plots","page":"Plotting","title":"1D plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(\n    samples::DensitySampleVector,\n    vsel::Union{Integer, Symbol, Expr};\n    intervals = BAT.default_credibilities,\n    bins = 200,\n    colors = BAT.default_colors,\n    interval_labels = [],\n    mean = false,\n    std = false,\n    globalmode = false,\n    marginalmode = true,\n    filter = false,\n    closed = :left\n)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Required inputs:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"samples::DensitySampleVector: samples to be plotted\nvsel::Union{Integer, Symbol, Expr}: index or name of the parameter to be plotted","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"seriestype::Symbol = :smallest_intervals: plot style        ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"available seriestypes:\n* `:smallest_intervals` (default for samples), alias `:HDR`\n* `:central_intervals`\n* `:histogram`, alias `:steppost`\n* `:stephist`","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"bins::Union{Integer, AbstractRange} = 200: number of histogram bins or bin edges.\nintervals::Array{<:Real, 1} = [0.683, 0.955, 0.997]: probability to be enclosed in the smallest/central intervals when using the corresponding seriestypes\ncolors::Array{Symbol, 1} = [:chartreuse2, :yellow, :red]: colors of the smallest/central interval regions, in same order as the values in intervals\nmean::Union{Dict, Bool} = true: indicate mean value (currently only for samples), calculated via bat_stats().mean.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The plot style of the mean can be customized using a Dict.  For mean = true, the default style is:   Dict(\"linestyle\" => :solid, \"linewidth\" => 1, \"linecolor\" => :dimgrey, \"alpha\" => 1, \"label\" => \"mean\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"std::Union{Dict, Bool} = true: indicate the standard deviation of the mean (currently only for samples), calculated from bat_stats().cov. The style of the standard deviation can be customized using a Dict.  For std = true, the default style is:   ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Dict(\"fillcolor\" => :grey, \"fillalpha\" => 0.5, \"label\" => \"std. dev.\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"globalmode::Union{Dict, Bool} = true: indicate global mode (currently only for samples), calculated via bat_stats().mode.  The style of the global mode can be passed as a Dict.  For globalmode = true, the default style is:  ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dash, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"global mode\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"marginalmode::Union{Dict, Bool} = true: indicate the marginal mode(s), i.e. the center of the highest histogram bin(s) (currently only for samples). The style can be passed as a Dict. If marginalmode = true, the default style is:  ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dot, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"marginal mode\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(only for samples) filter::Bool = false: if true, BAT.drop_low_weight_samples() is applied before plotting\nclosed = :left: see StatsBase.Histogram","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments for attributes supported by Plots.jl can also be passed to the function.","category":"page"},{"location":"plotting/#2D-plots","page":"Plotting","title":"2D plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(\n    samples::DensitySampleVector,\n    vsel::Union{NTuple{2, Integer}, NTuple{2, Union{Symbol, Expr}}};\n    intervals = BAT.default_credibilities,\n\tinterval_labels = [],\n    colors = BAT.default_colors,\n\tbins = 200,\n    mean = false,\n    std = false,\n    globalmode = false,\n    marginalmode = true,\n\tsmoothing = 0,\n    diagonal = Dict(),\n    upper = Dict(),\n    right = Dict(),\n    filter = false,\n    closed = :left\n)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Required inputs:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"samples::DensitySampleVector: samples to be plotted\nvsel::Union{NTuple{2, Integer}, NTuple{2, Union{Symbol, Expr}}}: indices or names of the two parameters to be plotted","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"seriestype::Symbol = :smallest_intervals: plot style  ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"available seriestypes:\n* `:smallest_intervals` (default for samples)\n* `:smallest_intervals_contour`\n* `:smallest_intervals_contourf`: filled contours)\n* `:histogram`, alias `:hist`, alias `:histogram2d`\n* `:scatter`","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"bins::Union{Integer, NTuple{2, Integer}, NTuple{2, AbstractRange}} = 200: number of histogram bins or bin edges. Use a NTuple{2, Union{Integer, AbstractRange}} to specify bins/edges of x and y axes separately.\nintervals::Array{<:Real, 1} = [0.683, 0.955, 0.997]  probability to be enclosed in the smallest intervals when using the corresponding seriestypes\ninterval_labels = []  label of the intervals as strings, LatexStrings are possible.\ncolors::Array{Symbol, 1} = [:chartreuse2, :yellow, :red] colors of the smallest interval regions, in same order as the values in intervals\nmean::Union{Dict, Bool} = true: indicate mean value (currently only for samples) , calculated via bat_stats().mean.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The plot style of the mean can be customized using a Dict.  For mean = true, the default style is: Dict(\"markercolor\" => :black, \"markersize\" => 4, \"markeralpha\" => 1, \"markershape\" => :circle, \"markerstrokealpha\" => 1, \"markerstrokecolor\" => :black, \"markerstrokestyle\" => :solid, \"markerstrokewidth\" => 1, \"label\" => \"mean\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"std::Union{Bool} = true: indicate the standard deviation of the mean as errorbars (currently only for samples), calculated from bat_stats().cov. The style of the errorbars can be customized using the markerstroke... options in mean.\nglobalmode::Union{Dict, Bool} = true: indicate global mode (currently only for samples), calculated via bat_stats().mode.  The style of the global mode can be passed as a Dict.  For globalmode = true, the default style is:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dash, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"global mode\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"marginalmode::Union{Dict, Bool} = true: indicate the marginalmode(s), i.e. the center of the highest histogram bin(s) (currently only for samples). The style can be passed as a Dict. If marginalmode = true, the default style is:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Dict(\"linestyle\" => :dot, \"linewidth\" => 1, \"linecolor\" => :black, \"alpha\" => 1, \"label\" => \"marginal mode\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"smoothing = 0: When plotting contours, a Gaussian filtering can be applied for smoothing the contour lines. The keyword smoothing accepts  positive real number (or a tuple of two positive real numbers), specifying the standard deviation of the Gaussian kernel (for each dimension) of the filtering.\ndiagonal = Dict(): Used only for the seriestype :marginal. The dictionary can contain the seriestypes and plot options for 2D distributions explained above to modify the 2D plot of the marginal plot. Nested Dictionaries are possible to modify the styles of the estimators as described above\nupper = Dict() and right = Dict():  Used only for the seriestype :marginal. The dictionaries can contain the seriestypes and plot options for 1D distributions explained above to modify the upper and right plots of the 1D marginal distributions. Nested Dictionaries are possible to modify the styles of the estimators as described above\nfilter::Bool = false: if true, BAT.drop_low_weight_samples() is applied before plotting\nclosed = :left: see StatsBase.Histogram","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments for attributes supported by Plots.jl can also be passed to the function.","category":"page"},{"location":"plotting/#1D-and-2D-overview-plots","page":"Plotting","title":"1D & 2D overview plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(\n\tsamples::DensitySampleVector;\n    vsel=collect(1:5),\n\tbins = 200,\n    mean=false,\n    std=false,\n    globalmode=false,\n    marginalmode=false,\n    diagonal = Dict(),\n    upper = Dict(),\n    lower = Dict(),\n    vsel_label = []\n)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Plot a grid with the 1D marginalized distributions on the diagonal and all combinations of the 2D marginalized distributions in the lower and upper triangle.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Required inputs:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"samples::DensitySampleVector: samples to be plotted","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Keyword arguments:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"vsel = collect(1:5): indices or parameter names of the parameters to be plotted. By default (up to) the first five parameters are plotted.\nbins::Union{Integer, Tuple{Union{Integer, AbstractRange}}, NamedTuple} = 200: Number of bins or bin edges\nmean::Bool = false: Indicate mean value, calculated via  bat_stats().mean, in all plots (currently only for samples)\nstd::Bool = false: Indicate the standard deviation of the mean calculated from bat_stats().cov in all plots (currently only for samples)\nglobalmode::Bool = false: Indicate global mode, calculated via bat_stats().mode, in all plots (currently only for samples)\nmarginalmode::Bool = false: Indicate local mode(s), i.e. the center of the highest histogram bin(s), in all plots (currently only for samples)\ndiagonal = Dict(): The dictionary can contain the seriestypes and plot options for 1D distributions explained above to modify the plots of the 1D marginal distributions on the diagonal of the grid. Nested Dictionaries are possible to modify the styles of the estimators as described above\nlower = Dict() and upper = Dict():  The dictionaries can contain the seriestypes and plot options for 2D distributions explained above to modify the 2D plots in the lower and upper triangles of the grid. Nested Dictionaries are possible to modify the styles of the estimators as described above\nvsel_label = []: parameter label as strings, LatexStrings are possible","category":"page"},{"location":"experimental_api/#Experimental-features","page":"Experimental Features","title":"Experimental features","text":"","category":"section"},{"location":"experimental_api/","page":"Experimental Features","title":"Experimental Features","text":"These are experimental features. Forward/backward compatibility does not follow Julia's semantic versioning rules. Instead, compatibility is only guaranteed across changes in patch version, but not across changes of minor (or major) version.","category":"page"},{"location":"experimental_api/","page":"Experimental Features","title":"Experimental Features","text":"The features listed here are likely to transition to the stable API in future versions, but may still evolve in a API-breaking fashion during that process.","category":"page"},{"location":"experimental_api/","page":"Experimental Features","title":"Experimental Features","text":"ARPWeighting\nbat_compare\nbat_integrated_autocorr_len\nbat_marginalmode\nBAT.auto_renormalize\nBAT.batsampleable\nBAT.BinnedModeEstimator\nBAT.DistributionTransform\nBAT.enable_error_log\nBAT.error_log\nBAT.EvalException\nBAT.ext_default\nBAT.get_adselector\nBAT.PackageExtension\nBAT.pkgext\nBAT.set_rng\nbatmeasure\nBridgeSampling\nEllipsoidalNestedSampling\nGridSampler\nHierarchicalDistribution\nPriorImportanceSampler\nReactiveNestedSampling\nSobolSampler\ntruncate_batmeasure\nValueAndThreshold","category":"page"},{"location":"experimental_api/#BAT.ARPWeighting","page":"Experimental Features","title":"BAT.ARPWeighting","text":"ARPWeighting{T<:AbstractFloat} <: AbstractMCMCWeightingScheme{T}\n\nExperimental feature, not part of stable public API.\n\nSample weighting scheme suitable for accept/reject-based sampling algorithms (e.g. MetropolisHastings). Both accepted and rejected samples become part of the output, with a weight proportional to their original acceptance probability.\n\nConstructors:\n\nARPWeighting()\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.bat_compare","page":"Experimental Features","title":"BAT.bat_compare","text":"bat_compare(\n    samples_1::DensitySampleVector,\n    samples_2::DensitySampleVector;\n    nsamples::Symbol=:effective\n)\n\nCompares two DensitySampleVectors given by samples_1 and samples_2 applying the Kolmogorov-Smirnov test for all marginals.\n\nnsamples specifies how to define a number of samples in the Kolmogorov-Smirnov distribution. The default value is nsamples=:effective, which uses the effective number of samples estimated by bat_eff_sample_size. The optimal keywords:\n\n:length  — length of the DensitySamplesVector is used\n:weights — the sum of the weights is used\n\nReturns a NamedTuple of the shape\n\n(result = X::TypedTables.Table, ...)\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.bat_integrated_autocorr_len","page":"Experimental Features","title":"BAT.bat_integrated_autocorr_len","text":"bat_integrated_autocorr_len(\n    v::_ACLenTarget,\n    algorithm::AutocorLenAlgorithm = GeyerAutocorLen(),\n    [context::BATContext]\n)\n\nExperimental feature, not yet part of stable public API.\n\nEstimate the integrated autocorrelation length of variate series v, separately for each degree of freedom.\n\nReturns a NamedTuple of the shape\n\n(result = integrated_autocorr_len, ...)\n\nResult properties not listed here are algorithm-specific and are not part of the stable public API.\n\nnote: Note\nDo not add add methods to bat_integrated_autocorr_len, add methods to bat_integrated_autocorr_len_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.bat_marginalmode","page":"Experimental Features","title":"BAT.bat_marginalmode","text":"bat_marginalmode(\n    target::DensitySampleVector,\n    algorithm::AbstractModeEstimator,\n    [context::BATContext]\n)::DensitySampleVector\n\nExperimental feature, not part of stable public API.\n\nEstimates a marginal mode of target by finding the maximum of marginalized posterior for each dimension.\n\nReturns a NamedTuple of the shape\n\n(result = X::DensitySampleVector, ...)\n\nnote: Note\nDo not add add methods to bat_marginalmode, add methods to bat_marginalmode_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.auto_renormalize","page":"Experimental Features","title":"BAT.auto_renormalize","text":"BAT.auto_renormalize(measure::MeasureBase.AbstractMeasure)\n\nExperimental feature, not part of stable public API.\n\nReturns (result = new_measure, logweight = logweight).\n\nTries to automatically renormalize measure if a maxium log-m value is available, returns measure unchanged otherwise.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.batsampleable","page":"Experimental Features","title":"BAT.batsampleable","text":"batsampleable(obj)\n\nExperimental feature, not part of stable public API.\n\nConvert obj into something that BAT can sample from.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.BinnedModeEstimator","page":"Experimental Features","title":"BAT.BinnedModeEstimator","text":"struct BinnedMarginalModes <: AbstractModeEstimator\n\nExperimental feature, not part of stable public API.\n\nBin data to estimate modes.\n\nConstructor: BinnedModeEstimator(; fields...)\n\nFields:\n\nbinning::Any: Default: FreedmanDiaconisBinning()\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.DistributionTransform","page":"Experimental Features","title":"BAT.DistributionTransform","text":"abstract type DistributionTransform <: Function\n\nExperimental feature, not part of stable public API.\n\nTransform variate values between distributions\n\nConstructors:\n\nDistributionTransform(target_dist, source_dist)\nDistributionTransform(Uniform, source_dist)\nDistributionTransform(Normal, source_dist)\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.enable_error_log","page":"Experimental Features","title":"BAT.enable_error_log","text":"BAT.enable_error_log(enable::Bool = true)\n\nExperimental feature, not part of stable public API.\n\nEnable/disable BAT's error (exception) log.\n\nThe error log is disabled by default.\n\nSee BAT.error_log.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.error_log","page":"Experimental Features","title":"BAT.error_log","text":"BAT.error_log()\n\nExperimental feature, not part of stable public API.\n\nGet a log of certain exceptions throws by BAT, e.g. density evaluation errors.\n\nThe error log is disabled by default, use BAT.enable_error_log to enable it.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.EvalException","page":"Experimental Features","title":"BAT.EvalException","text":"struct EvalException <: Exception\n\nConstructors:\n\nEvalException(func::Function, measure::AbstractMeasure, v::Any, ret::Any)\n\nFields:\n\nfunc::Function: Density evaluation function that failed.\nmeasure::MeasureBase.AbstractMeasure: Density being evaluated.\nv::Any: Variate at which the evaluation of measure (applying f to d at v) failed.\nret::Any: Cause of failure, either the invalid return value of f on d at v, or another expection (on rethrow).\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.ext_default","page":"Experimental Features","title":"BAT.ext_default","text":"BAT.ext_default(::PackageExtension{SomePackage}, ::Val{:SomeLabel}, args; kwargs...)\n\nExperimental feature, not part of stable public API.\n\nReturns the default value selected by :SomeLabel within the context of the package extension that depends on SomePackage.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.get_adselector","page":"Experimental Features","title":"BAT.get_adselector","text":"BAT.get_adselector(context::BATContext)\n\nExperimental feature, not yet part of stable public API.\n\nReturns the automatic differentiation selector specified in context.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.PackageExtension","page":"Experimental Features","title":"BAT.PackageExtension","text":"abstract type PackageExtension{pkgname}\n\nExperimental feature, not part of stable public API.\n\nRepresents a package extension that requires the package pkgname to be loaded.\n\nDo not construct instances of PackageExtension directly, use pkgext(:pkgname) instead which will check that the required extension is active.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.pkgext","page":"Experimental Features","title":"BAT.pkgext","text":"BAT.pkgext(:SomePackage)::PackageExtension\nBAT.pkgext(Val(:SomePackage))::PackageExtension\n\nExperimental feature, not part of stable public API.\n\nReturns the PackageExtension instance that depends on the package SomePackage. Will throw an error if the extension is not active (because SomePackage` hasn't been loaded).\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.set_rng","page":"Experimental Features","title":"BAT.set_rng","text":"BAT.set_rng(context::BATContext, rng::AbstractRNG)::BATContext\n\nExperimental feature, not yet part of stable public API.\n\nReturns a copy of context with the random number generator set to rng.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.batmeasure","page":"Experimental Features","title":"BAT.batmeasure","text":"batmeasure(obj)\n\nExperimental feature, not part of stable public API.\n\nConvert a measure-like obj to a measure that is compatible with BAT.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.BridgeSampling","page":"Experimental Features","title":"BAT.BridgeSampling","text":"struct BridgeSampling <: IntegrationAlgorithm\n\nExperimental feature, not part of stable public API.\n\nBridgeSampling integration algorithm.\n\nConstructors:\n\nBridgeSampling(; fields...)\n\nFields:\n\ntrafo::AbstractTransformTarget: Default: PriorToGaussian()\nessalg::EffSampleSizeAlgorithm: Default: EffSampleSizeFromAC()\nstrict::Bool: Default: true\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.EllipsoidalNestedSampling","page":"Experimental Features","title":"BAT.EllipsoidalNestedSampling","text":"struct EllipsoidalNestedSampling <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nUses the julia package NestedSamplers.jl to use nested sampling algorithm.\n\nConstructors:\n\nEllipsoidalNestedSampling(; fields...)\n\nFields:\n\ntrafo::AbstractTransformTarget: Default: begin     pkgext(Val(:NestedSamplers))     #= /home/runner/work/BAT.jl/BAT.jl/src/extdefs/nestedsamplers_defs.jl:149 =#     PriorToUniform() end\nnum_live_points::Int64: Number of live-points. Default: 1000\nbound::BAT.ENSBound: Volume around the live-points. Default: ENSEllipsoidBound()\nproposal::BAT.ENSProposal: Algorithm used to choose new live-points. Default: ENSAutoProposal()\nenlarge::Float64: Scale factor for the volume. Default: 1.25\nmin_ncall::Int64: Number of iterations before the first bound will be fit. Default: 2numlivepoints\nmin_eff::Float64: Efficiency before fitting the first bound. Default: 0.1\ndlogz::Float64: Default: 0.01\nmax_iters::Any: Default: Inf\nmax_ncalls::Any: Default: 10 ^ 7\nmaxlogl::Any: Default: Inf\n\nnote: Note\nThis functionality is only available when the NestedSamplers.jl package  is loaded (e.g. via import).\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.GridSampler","page":"Experimental Features","title":"BAT.GridSampler","text":"struct GridSampler <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nSample from equidistantly distributed points in each dimension.\n\nConstructors:\n\nGridSampler(; fields...)\n\nFields:\n\ntrafo::AbstractTransformTarget: Default: PriorToUniform()\nppa::Int64: Default: 100\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.HierarchicalDistribution","page":"Experimental Features","title":"BAT.HierarchicalDistribution","text":"struct HierarchicalDistribution <: ContinuousDistribution\n\nExperimental feature, not part of stable public API.\n\nA hierarchical distribution, useful for hierarchical models/priors.\n\nConstructors:\n\nHierarchicalDistribution(f::Function, primary_dist::NamedTupleDist)\n\nwith a functon f that returns a ContinuousDistribution for any variate v drawn from primary_dist.\n\nExample:\n\nhd = HierarchicalDistribution(\n    v -> NamedTupleDist(\n        baz = fill(Normal(v.bar, v.foo), 3)\n    ),\n    NamedTupleDist(\n        foo = Exponential(3.5),\n        bar = Normal(2.0, 1.0)\n    )\n)\n\nvarshape(hd) == NamedTupleShape(\n    foo = ScalarShape{Real}(),\n    bar = ScalarShape{Real}(),\n    baz = ArrayShape{Real}(3)\n)\n\nv = rand(hd)\n\nnote: Note\nAll fields of HierarchicalDistribution are considered internal and subject to change without deprecation.\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.PriorImportanceSampler","page":"Experimental Features","title":"BAT.PriorImportanceSampler","text":"struct PriorImportanceSampler <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nImportance sampler using IID samples from the prior.\n\nConstructors:\n\nPriorImportanceSampler(; fields...)\n\nFields:\n\nnsamples::Int64: Default: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.ReactiveNestedSampling","page":"Experimental Features","title":"BAT.ReactiveNestedSampling","text":"struct ReactiveNestedSampling <: AbstractUltraNestAlgorithmReactiv\n\nExperimental feature, not part of stable public API.\n\nUltraNest reactive nested sampling algorithm with.\n\nUses the UltraNest Python package, via UltraNest.jl (and PyCall).\n\nConstructors:\n\nReactiveNestedSampling(; fields...)\n\nFields:\n\ntrafo::AbstractTransformTarget: Default: begin     pkgext(Val(:UltraNest))     #= /home/runner/work/BAT.jl/BAT.jl/src/extdefs/ultranest_defs.jl:34 =#     PriorToUniform() end\nnum_test_samples::Int64: Test transform and likelihood with this number of random points for errors first. Useful to catch bugs. Default: 2\ndraw_multiple::Bool: If efficiency goes down, dynamically draw more points from the region between ndrawmin and ndrawmax. If set to False, few points are sampled at once. Default: true\nnum_bootstraps::Int64: Number of logZ estimators and MLFriends region bootstrap rounds. Default: 30\nndraw_min::Int64: Minimum number of points to simultaneously propose. Increase this if your likelihood makes vectorization very cheap. Default: 128\nndraw_max::Int64: Maximum number of points to simultaneously propose. Increase this if your likelihood makes vectorization very cheap. Memory allocation may be slow for extremely high values. Default: 65536\nupdate_interval_volume_fraction::Float64: Update region when the volume shrunk by this amount. Default: 0.8\nlog_interval::Int64: Update stdout status line every log_interval iterations. Default: -1\nshow_status::Bool: Show integration progress as a status line. Default: true\nviz_callback::Union{Nothing, Function}: Callback function when region was rebuilt. Allows to show current state of the live points. Default: nothing\ndlogz::Float64: Target evidence uncertainty. This is the std between bootstrapped logz integrators. Default: 0.5\ndKL::Float64: Target posterior uncertainty. This is the Kullback-Leibler divergence in nat between bootstrapped integrators. Default: 0.5\nfrac_remain::Float64: Integrate until this fraction of the integral is left in the remainder. Set to a low number (1e-2 … 1e-5) to make sure peaks are discovered. Set to a higher number (0.5) if you know the posterior is simple. Default: 0.01\nLepsilon::Float64: Terminate when live point likelihoods are all the same, within Lepsilon tolerance. Increase this when your likelihood function is inaccurate, to avoid unnecessary search. Default: 0.001\nmin_ess::Int64: Target number of effective posterior samples. Default: 400\nmax_iters::Int64: maximum number of integration iterations. Default: -1\nmax_ncalls::Int64: Stop after this many likelihood evaluations. Default: -1\nmax_num_improvement_loops::Int64: The algorithm tries to assess iteratively where more samples are needed. This number limits the number of improvement loops. Default: -1\nmin_num_live_points::Int64: Minimum number of live points throughout the run. Default: 400\ncluster_num_live_points::Int64: Require at least this many live points per detected cluster. Default: 40\ninsertion_test_window::Float64: z-score used as a threshold for the insertion order test. Set to infinity to disable. Default: 10.0\ninsertion_test_zscore_threshold::Float64: Number of iterations after which the insertion order test is reset. Default: 2.0\nexecutor::Any: Executor for posterior evaluation. Default: default_executor()\n\nnote: Note\nThis functionality is only available when the UltraNest package is loaded (e.g. via import UltraNest).\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.SobolSampler","page":"Experimental Features","title":"BAT.SobolSampler","text":"struct SobolSampler <: AbstractSamplingAlgorithm\n\nExperimental feature, not part of stable public API.\n\nSample from Sobol sequence. Also see Sobol.jl.\n\nConstructors:\n\nSobolSampler(; fields...)\n\nFields:\n\ntrafo::AbstractTransformTarget: Default: PriorToUniform()\nnsamples::Int64: Default: 10 ^ 5\n\n\n\n\n\n","category":"type"},{"location":"experimental_api/#BAT.truncate_batmeasure","page":"Experimental Features","title":"BAT.truncate_batmeasure","text":"BAT.truncate_batmeasure(density::BATMeasure, bounds::AbstractArray{<:Interval})::BATMeasure\n\nExperimental feature, not part of stable public API.\n\nTruncate density to bounds, the resulting density will be effectively zero outside of those bounds. In contrast Distributions.truncated, truncate_batmeasure does not renormalize the density.\n\nRequires varshape(density) isa ArrayShape.\n\nOnly supports densities that are essentially products of univariate distributions, as well as posterior densities with such densities as priors.\n\n\n\n\n\n","category":"function"},{"location":"experimental_api/#BAT.ValueAndThreshold","page":"Experimental Features","title":"BAT.ValueAndThreshold","text":"struct ValueAndThreshold{name}\n\nExperimental feature, not part of stable public API.\n\nHolds a (target) value, a comparison function and a threshold.\n\nConstructor: ValueAndThreshold{name}(value, cmp_function, threshold)\n\nConverts to a Bool accoring to cmp_function(value, threshold)\n\nExample:\n\nconvert(Bool, ValueAndThreshold{:max_error}(3.4, <, 5.2)) == true\n\n\n\n\n\n","category":"type"},{"location":"#BAT.jl-Documentation","page":"Home","title":"BAT.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BAT.jl is a Bayesian Analysis Toolkit in Julia. It is a high-performance tool box for Bayesian inference with statistical models expressed in a general-purpose programming language instead of a domain-specific language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Typical applications for this package are parameter inference given a model (in the form of a likelihood function and prior), the comparison of different models in the light of a given data set, and the test of the validity of a model to represent the data set at hand. BAT.jl provides access to the full Bayesian posterior distribution to enable parameter estimation, limit setting and uncertainty propagation. BAT.jl also provides supporting functionality like plotting recipes and reporting functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BAT.jl is implemented in pure Julia and allows for a flexible definition of mathematical models and applications while enabling the user to code for the performance required for computationally expensive numerical operations. BAT.jl provides implementations (internally and via other Julia packages) of algorithms for sampling, optimization and integration. BAT's main focus is on the analysis of complex custom models. It is designed to enable parallel code execution at various levels (running multiple MCMC chains in parallel is provided out-of-the-box).","category":"page"},{"location":"","page":"Home","title":"Home","text":"It's possible to use BAT.jl with likelihood functions implemented in languages other than Julia: Julia allows for calling code in C and Fortran, C++, Python and several other languages directly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BAT.jl originated as a rewrite/redesign of BAT, the Bayesian Analysis Toolkit in C++. BAT.jl now offer a different set of functionality and a wider variety of algorithms than it's C++ predecessor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nBAT.jl requires Julia >= v1.10, we recommend to use the latest stable Julia version for optimal performance.","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    # \"basics.md\",\n    \"installation.md\",\n    \"tutorial.md\",\n    # \"faq.md\",\n    # \"examples.md\",\n    # \"algorithms.md\",\n    # \"benchmarks.md\",\n    # \"publications.md\",\n    \"api.md\",\n    \"developing.md\",\n    \"license.md\",\n]\nDepth = 1","category":"page"},{"location":"#Citing-BAT.jl","page":"Home","title":"Citing BAT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When using BAT.jl for research, teaching or similar, please cite Schulz et al. \"BAT.jl: A Julia-Based Tool for Bayesian Inference\", SNCS (2021).","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Schulz:2021BAT,\n  author  = {Schulz, Oliver and Beaujean, Frederik and Caldwell, Allen and Grunwald, Cornelius and Hafych, Vasyl and Kr{\\\"o}ninger, Kevin and Cagnina, Salvatore La and R{\\\"o}hrig, Lars and Shtembari, Lolian},\n  journal = {SN Computer Science},\n  title   = {BAT.jl: A Julia-Based Tool for Bayesian Inference},\n  year    = {2021},\n  issn    = {2661-8907},\n  month   = {Apr},\n  number  = {3},\n  pages   = {210},\n  volume  = {2},\n  day     = {12},\n  doi     = {10.1007/s42979-021-00626-4},\n  url     = {https://doi.org/10.1007/s42979-021-00626-4},\n}","category":"page"},{"location":"#Learning-(more-about)-Julia","page":"Home","title":"Learning (more about) Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BAT.jl supersedes BAT in C++. If you're considering to switch to BAT.jl, but you're new to Julia and want to learn more about the the language, here are a few resources to get started:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Julia website provides many links to introductory videos and written tutorials, e.g. \"Intro to Julia\", Think Julia: How to Think Like a Computer Scientist and \"The Fast Track to Julia\". If you are familiar with MATLAB or Python, you may also want to take a look at the \"MATLAB–Python–Julia cheatsheet\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"The in-depth article Why Numba and Cython are not substitutes for Julia explains how Julia addresses several fundamental challenges inherent to scientific high-performance computing.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We acknowledge the contributions from all the BAT.jl users, they help us make BAT.jl a better project. Your help is most welcome!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Development of BAT.jl has been supported by funding from","category":"page"},{"location":"","page":"Home","title":"Home","text":"Deutsche Forschungsgemeinschaft (DFG, German Research Foundation)\nEuropean Union Framework Programme for Research and Innovation Horizon 2020 (2014-2020) under the Marie Sklodowska-Curie Grant Agreement No.765710","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"tutorial_lit.jl\"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates a simple application of BAT.jl: A Bayesian fit of a histogram with two Gaussian peaks.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Table of contents:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pages = [\"tutorial.md\"]\nDepth = 3","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note: This tutorial is somewhat verbose, as it aims to be easy to follow for users who are new to Julia. For the same reason, we deliberately avoid making use of Julia features like closures, anonymous functions, broadcasting syntax, performance annotations, etc.","category":"page"},{"location":"tutorial/#Input-Data-Generation","page":"Tutorial","title":"Input Data Generation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, let's generate some synthetic data to fit. We'll need the Julia standard-library packages \"Random\", \"LinearAlgebra\" and \"Statistics\", as well as the packages \"Distributions\" and \"StatsBase\":","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Random, LinearAlgebra, Statistics, Distributions, StatsBase","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As the underlying truth of our input data/histogram, let us choose the expected count to follow the sum of two Gaussian peaks with peak areas of 500 and 1000, a mean of -1.0 and 2.0 and a standard error of 0.5. Then","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"data = vcat(\n    rand(Normal(-1.0, 0.5), 500),\n    rand(Normal( 2.0, 0.5), 1000)\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"resulting in a vector of floating-point numbers:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"typeof(data) == Vector{Float64}","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we'll create a histogram of that data, this histogram will serve as the input for the Bayesian fit:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hist = append!(Histogram(-2:0.1:4), data)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using the Julia \"Plots\" package","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we can plot the histogram:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data\"\n)\nsavefig(\"tutorial-data.pdf\")\nsavefig(\"tutorial-data.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Data)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's define our fit function - the function that we expect to describe the data histogram, at each x-Axis position x, depending on a given set p of model parameters:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function fit_function(p::NamedTuple{(:a, :mu, :sigma)}, x::Real)\n    p.a[1] * pdf(Normal(p.mu[1], p.sigma), x) +\n    p.a[2] * pdf(Normal(p.mu[2], p.sigma), x)\nend\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The fit parameters (model parameters) a (peak areas) and mu (peak means) are vectors, parameter sigma (peak width) is a scalar, we assume it's the same for both Gaussian peaks.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The true values for the model/fit parameters are the values we used to generate the data:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"true_par_values = (a = [500, 1000], mu = [-1.0, 2.0], sigma = 0.5)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's visually compare the histogram and the fit function, using these true parameter values, to make sure everything is set up correctly:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    normalize(hist, mode=:density),\n    st = :steps, label = \"Data\",\n    title = \"Data and True Statistical Model\"\n)\nplot!(\n    -4:0.01:4, x -> fit_function(true_par_values, x),\n    label = \"Truth\"\n)\nsavefig(\"tutorial-data-and-truth.pdf\")\nsavefig(\"tutorial-data-and-truth.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Data and True Statistical Model)","category":"page"},{"location":"tutorial/#Bayesian-Fit","page":"Tutorial","title":"Bayesian Fit","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we'll perform a Bayesian fit of the generated histogram, using BAT, to infer the model parameters from the data histogram.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition to the Julia packages loaded above, we need BAT itself, as well as IntervalSets:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using BAT, DensityInterface, IntervalSets","category":"page"},{"location":"tutorial/#Likelihood-Definition","page":"Tutorial","title":"Likelihood Definition","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, we need to define the likelihood for our problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT expects likelihoods to implements the DensityInterface API. We can simply wrap a log-likelihood function with DensityInterface.logfuncdensity to make it compatible.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For performance reasons, functions should not access global variables directly. So we'll use an anonymous function inside of a let-statement to capture the value of the global variable hist in a local variable h (and to shorten function name fit_function to f, purely for convenience). DensityInterface.logfuncdensity then turns the log-likelihood function into a DensityInterface density object.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"likelihood = let h = hist, f = fit_function\n    # Histogram counts for each bin as an array:\n    observed_counts = h.weights\n\n    # Histogram binning:\n    bin_edges = h.edges[1]\n    bin_edges_left = bin_edges[1:end-1]\n    bin_edges_right = bin_edges[2:end]\n    bin_widths = bin_edges_right - bin_edges_left\n    bin_centers = (bin_edges_right + bin_edges_left) / 2\n\n    logfuncdensity(function (params)\n        # Log-likelihood for a single bin:\n        function bin_log_likelihood(i)\n            # Simple mid-point rule integration of fit function `f` over bin:\n            expected_counts = bin_widths[i] * f(params, bin_centers[i])\n            # Avoid zero expected counts for numerical stability:\n            logpdf(Poisson(expected_counts + eps(expected_counts)), observed_counts[i])\n        end\n\n        # Sum log-likelihood over bins:\n        idxs = eachindex(observed_counts)\n        ll_value = bin_log_likelihood(idxs[1])\n        for i in idxs[2:end]\n            ll_value += bin_log_likelihood(i)\n        end\n\n        return ll_value\n    end)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT makes use of Julia's parallel programming facilities if possible, e.g. to run multiple Markov chains in parallel. Therefore, log-likelihood (and other) code must be thread-safe. Mark non-thread-safe code with @critical (provided by Julia package ParallelProcessingTools).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Support for automatic parallelization across multiple (local and remote) Julia processes is planned, but not implemented yet.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that Julia currently starts only a single thread by default. Set the the environment variable JULIA_NUM_THREADS to specify the desired number of Julia threads.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can evaluate likelihood, e.g. at the true parameter values:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"logdensityof(likelihood, true_par_values)","category":"page"},{"location":"tutorial/#Prior-Definition","page":"Tutorial","title":"Prior Definition","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we need to choose a sensible prior for the fit:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"prior = distprod(\n    a = [Weibull(1.1, 5000), Weibull(1.1, 5000)],\n    mu = [-2.0..0.0, 1.0..3.0],\n    sigma = Weibull(1.2, 2)\n)\n\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT supports most Distributions.Distribution types, and combinations of them, as priors.","category":"page"},{"location":"tutorial/#Bayesian-Model-Definition","page":"Tutorial","title":"Bayesian Model Definition","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given the likelihood and prior definition, a BAT.PosteriorMeasure is simply defined via","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"posterior = PosteriorMeasure(likelihood, prior)\nnothing # hide","category":"page"},{"location":"tutorial/#Parameter-Space-Exploration-via-MCMC","page":"Tutorial","title":"Parameter Space Exploration via MCMC","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now use Markov chain Monte Carlo (MCMC) to explore the space of possible parameter values for the histogram fit.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To increase the verbosity level of BAT logging output, you may want to set the Julia logging level for BAT to debug via ENV[\"JULIA_DEBUG\"] = \"BAT\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can generate a set of MCMC samples via bat_sample. We'll use 4 MCMC chains with 10^5 MC steps in each chain (after tuning/burn-in):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"samples = bat_sample(posterior, MCMCSampling(mcalg = MetropolisHastings(), nsteps = 10^5, nchains = 4)).result\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's calculate some statistics on the posterior samples:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"Truth: $true_par_values\")\nprintln(\"Mode: $(mode(samples))\")\nprintln(\"Mean: $(mean(samples))\")\nprintln(\"Stddev: $(std(samples))\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Internally, BAT often needs to represent variates as flat real-valued vectors:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"unshaped_samples, f_flatten = bat_transform(Vector, samples)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The statisics above (mode, mean and std-dev) are presented in shaped form. However, it's not possible to represent statistics with matrix shape, e.g. the parameter covariance matrix, this way. So the covariance has to be accessed in unshaped form:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"par_cov = cov(unshaped_samples)\nprintln(\"Covariance: $par_cov\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use bat_report to generate an overview of the sampling result and parameter estimates (based on the marginal distributions):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"bat_report(samples)","category":"page"},{"location":"tutorial/#Visualization-of-Results","page":"Tutorial","title":"Visualization of Results","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT.jl comes with an extensive set of plotting recipes for \"Plots.jl\". We can plot the marginalized distribution for a single parameter (e.g. parameter 3, i.e. μ[1]):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples, :(mu[1]),\n    mean = true, std = true, globalmode = true, marginalmode = true,\n    nbins = 50, title = \"Marginalized Distribution for mu[1]\"\n)\nsavefig(\"tutorial-single-par.pdf\")\nsavefig(\"tutorial-single-par.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Marginalized Distribution for mu_1)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"or plot the marginalized distribution for a pair of parameters (e.g. parameters 3 and 5, i.e. μ[1] and σ), including information from the parameter stats:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples, (:(mu[1]), :sigma),\n    mean = true, std = true, globalmode = true, marginalmode = true,\n    nbins = 50, title = \"Marginalized Distribution for mu[1] and sigma\"\n)\nplot!(BAT.MCMCBasicStats(samples), (3, 5))\nsavefig(\"tutorial-param-pair.png\")\nsavefig(\"tutorial-param-pair.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Marginalized Distribution for mu_1 and sigma)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also create an overview plot of the marginalized distribution for all pairs of parameters:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(\n    samples,\n    mean = false, std = false, globalmode = true, marginalmode = false,\n    nbins = 50\n)\nsavefig(\"tutorial-all-params.png\")\nsavefig(\"tutorial-all-params.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Pairwise Correlation between Parameters)","category":"page"},{"location":"tutorial/#Integration-with-Tables.jl","page":"Tutorial","title":"Integration with Tables.jl","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DensitySamplesVector supports the Tables.jl interface, so it is a table itself. We can also convert it to other table types, e.g. a TypedTables.Table:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TypedTables\n\ntbl = Table(samples)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"or a DataFrames.DataFrame, etc.","category":"page"},{"location":"tutorial/#Comparison-of-Truth-and-Best-Fit","page":"Tutorial","title":"Comparison of Truth and Best Fit","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As a final step, we retrieve the parameter values at the mode, representing the best-fit parameters","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"samples_mode = mode(samples)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Like the samples themselves, the result can be viewed in both shaped and unshaped form. samples_mode is presented as a 0-dimensional array that contains a NamedTuple, this representation preserves the shape information:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"samples_mode isa NamedTuple","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"samples_mode is only an estimate of the mode of the posterior distribution. It can be further refined using bat_findmode:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Optim\n\nfindmode_result = bat_findmode(\n    posterior,\n    OptimAlg(optalg = Optim.NelderMead(), init = ExplicitInit([samples_mode]))\n)\n\nfit_par_values = findmode_result.result","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's plot the data and fit function given the true parameters and MCMC samples","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(-4:0.01:4, fit_function, samples)\n\nplot!(\n    normalize(hist, mode=:density),\n    color=1, linewidth=2, fillalpha=0.0,\n    st = :steps, fill=false, label = \"Data\",\n    title = \"Data, True Model and Best Fit\"\n)\n\nplot!(-4:0.01:4, x -> fit_function(true_par_values, x), color=4, label = \"Truth\")\nsavefig(\"tutorial-data-truth-bestfit.pdf\")\nsavefig(\"tutorial-data-truth-bestfit.svg\"); nothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Data, True Model and Best Fit)","category":"page"},{"location":"tutorial/#Fine-grained-control","page":"Tutorial","title":"Fine-grained control","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT provides fine-grained control over the MCMC algorithm options, the MCMC chain initialization, tuning/burn-in strategy and convergence testing. All option value used in the following are the default values, any or all may be omitted.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We'll sample using the The Metropolis-Hastings MCMC algorithm:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mcmcalgo = MetropolisHastings(\n    weighting = RepetitionWeighting(),\n    tuning = AdaptiveMHTuning()\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT requires a counter-based random number generator (RNG), since it partitions the RNG space over the MCMC chains. This way, a single RNG seed is sufficient for all chains and results are reproducible even under parallel execution. By default, BAT uses a Philox4x RNG initialized with a random seed drawn from the system entropy pool:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Random123\nrng = Philox4x()\ncontext = BATContext(rng = Philox4x())\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By default, MetropolisHastings() uses the following options.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For Markov chain initialization:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"init = MCMCChainPoolInit()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the MCMC burn-in procedure:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"burnin = MCMCMultiCycleBurnin()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For convergence testing:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"convergence = BrooksGelmanConvergence()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To generate MCMC samples with explicit control over all options, use something like","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"samples = bat_sample(\n    posterior,\n    MCMCSampling(\n        mcalg = mcmcalgo,\n        nchains = 4,\n        nsteps = 10^5,\n        init = init,\n        burnin = burnin,\n        convergence = convergence,\n        strict = true,\n        store_burnin = false,\n        nonzero_weights = true,\n        callback = (x...) -> nothing\n    ),\n    context\n).result\nnothing # hide","category":"page"},{"location":"tutorial/#Saving-result-data-to-files","page":"Tutorial","title":"Saving result data to files","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The package FileIO.jl(in conjunction with JLD2.jl) offers a convenient way to store results like posterior samples to file:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FileIO\nimport JLD2\nFileIO.save(\"results.jld2\", Dict(\"samples\" => samples))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"JLD2 persists the full information (including value shapes), so you can reload exactly the same data into memory in a new Julia session via","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FileIO\nimport JLD2\nsamples = FileIO.load(\"results.jld2\", \"samples\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"provided you use compatible versions of BAT and it's dependencies. Note that JLD2 is not a long-term stable file format. Also note that this functionality is provided by FileIO.jl and JLD2.jl and not part of the BAT API itself.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT.jl itself can write samples to standard HDF5 files in a form suitable for long-term storage (via HDF5.jl):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"import HDF5\nbat_write(\"results.h5\", samples)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The resulting files have an intuitive HDF5 layout and can be read with the standard HDF5 libraries, so they are easily accessible from other programming languages as well. Not all value shape information can be preserved, though. To read BAT.jl HDF5 sample data, use","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using BAT\nimport HDF5\nsamples = bat_read(\"results.h5\").result","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BAT.jl's HDF5 file format may evolve over time, but future versions of BAT.jl will be able to read HDF5 sample data written by this version of BAT.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
